# Модель памяти C++

## Модель памяти C++
- С++ - кроссплатформенный язык высокого уровня
    - Платформы могут очень сильно различаться
    - Компилятор и стандартная библиотека позволяют создавать эффективный код
- Когда стандартные решения не подходят, можно приблизиться к «железу», чтобы оптимально распорядиться ресурсами компьютера
---

## 1. Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?

Объект в C++ — это область памяти, которая:
- Объект – регион в памяти, обладающий свойствами
    - Размер
    - Выравнивание
    - Тип
    - Продолжительность времени жизни
    - Опциональное имя

Свойства объекта:
- Размер (sizeof): количество байт, занимаемых в памяти.
- Выравнивание (alignof): требования к расположению в памяти.
- Время жизни: от создания (конструктор) до уничтожения (деструктор).
- Тип: определяет допустимые операции и интерпретацию битов.
- Адрес: каждый объект имеет уникальный адрес (кроме nullptr, битовых полей и некоторых оптимизаций).

### Представление целых чисел в памяти компьютера
- Тип char занимает одну ячейку памяти (байт) размером, как правило, 8 бит
- Размер short и int и long кратен размеру char
    - Размер типа short <= Размер типа int
    - При этом число записывается в позиционной системе счисления с основанием 2разрядность байта
    - Порядок записи байтов, представляющих число в памяти, зависит от архитектуры системы
        - Little-endian, big-endian, middle-endian

---

## 2. Что такое выравнивание? Для чего оно используется?
Выравнивание — это требование, чтобы адрес объекта в памяти был кратен некоторому числу (обычно степени двойки: 1, 2, 4, 8, 16...).

Для чего нужно:
- Эффективность доступа: процессор быстрее читает/пишет данные, если они выровнены (иначе возможны penalties или даже segfault на некоторых архитектурах, например ARM).
- Атомарность операций: некоторые инструкции (например, CAS — Compare-And-Swap) требуют выровненных данных.
- Совместимость с аппаратурой: например, SSE/AVX-инструкции требуют выравнивания на 16/32 байта.

```c++
struct A {
    char c;      // 1 байт
    int i;       // 4 байта, обычно требует выравнивания на 4
};
// Размер может быть 8 из-за выравнивания (3 байта padding после `c`).
```

---

## 3. Чем размер объекта отличается от его выравнивания?
- Размер (sizeof): сколько байт занимает объект в памяти, включая padding (дополнение для выравнивания полей).
- Выравнивание (alignof): на какое число должен быть выровнен адрес объекта.

```c++
struct B {
    double d;    // 8 байт, выравнивание обычно 8
    char c;      // 1 байт
};
static_assert(sizeof(B) == 16);   // Размер (8 + 1 + 7 padding)
static_assert(alignof(B) == 8);   // Выравнивание (по double)
```


---

## 4. Выравнивание структур.
Правила выравнивания структур:
- Выравнивание структуры = максимальное выравнивание среди её полей.
- Компилятор добавляет padding (пустые байты) между полями и в конце, чтобы каждое поле было выровнено правильно.

```c++
struct C {
    char a;      // 1 байт
    int b;       // 4 байта, требует выравнивания на 4 → после `a` будет 3 байта padding
    short c;     // 2 байта
};  // Размер: 1 + 3(pad) + 4 + 2 = 10 → но структура выровнена на 4, поэтому добавится ещё 2 байта в конец.
static_assert(sizeof(C) == 12);   // 1 + 3 + 4 + 2 + 2(pad)
static_assert(alignof(C) == 4);
```

Управление выравниванием:
- alignas — явно задать выравнивание:
```c++
struct alignas(16) D { ... };  // Выравнивание 16 байт
```
- `#pragma pack` — уменьшить выравнивание (полезно для плотных структур, но может снизить производительность):
```c++
#pragma pack(push, 1)
struct E { char a; int b; };  // Размер 5 (без padding)
#pragma pack(pop)
```

---

## 5. Как узнать размер объекта?
sizeof: оператор, возвращающий размер в байтах.
```c++
std::cout << sizeof(int);  // Например, 4
std::cout << sizeof(C);    // Для структуры C из примера — 12
```

---

## 6. Как узнать выравнивание объекта?
alignof (C++11): оператор, возвращающий выравнивание типа.
```c++
std::cout << alignof(int);  // Например, 4
std::cout << alignof(C);    // Для структуры C — 4
```

std::alignment_of (из <type_traits>):
```c++
std::cout << std::alignment_of_v<int>;  // Аналогично alignof
```

### Размеры и выравнивание объектов
```c++
#include <iostream>
 
using namespace std;
 
struct Sportsman
{
  int id;
  double height;
};
 
int main()
{
  cout << "char: size="s << sizeof(char) << ", alignment="s << alignof(char) << endl;
  cout << "int: size="s << sizeof(int) << ", alignment="s << alignof(int) << endl;
  cout << "double: size="s << sizeof(double) << ", alignment="s << alignof(double) << endl;
  cout << "Sportsman: size="s << sizeof(Sportsman) << ", alignment="s 
       << alignof(Sportsman) << endl;
}
```

## Дополнительные нюансы
- Выравнивание массивов:
  - Каждый элемент массива T[N] имеет выравнивание alignof(T).
  - Поэтому между элементами padding не добавляется.
- Динамическая память (new, malloc):
  - new и malloc гарантируют, что выделенная память будет выровнена для любого стандартного типа.
  - Для пользовательских выравниваний (alignas) в C++17 появился std::aligned_alloc.
- Специфичные для платформы ограничения:
  - На x86 доступ к невыровненным данным возможен, но медленнее.
  - На ARM (и некоторых других) невыровненный доступ приводит к alignment fault.
- Битовые поля:
  - Не имеют адреса, поэтому их выравнивание сложнее (обычно упаковываются в исходный тип).
- Пустые классы:
  - Размер пустого класса ≥ 1 байт (для уникальности адресов).
  - Выравнивание пустого класса обычно 1 (но может быть изменено через alignas).
