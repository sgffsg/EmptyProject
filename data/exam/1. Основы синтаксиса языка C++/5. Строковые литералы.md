# Строковые литералы


## 1. Как объявляется строковый литерал в языке C++?
Строковый литерал — это последовательность символов, заключённая в двойные кавычки:

```c++
const char* str = "Hello, World!";  // Классический строковый литерал
const wchar_t* wstr = L"Привет!";   // Широкий строковый литерал
```
- Тип обычного строкового литерала — `const char[N]` (массив константных символов).
- Литералы автоматически завершаются нулевым символом `\0`.

---

## 2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
Управляющие последовательности начинаются с обратного слеша (\) и позволяют вставлять специальные символы:

### '\n' — Перевод строки (LF)
Перевод строки (Line Feed, LF)

`Назначение`: Перемещает курсор на следующую строку.

Пример
```c++
std::cout << "Первая строка\nВторая строка";

Result:
Первая строка
Вторая строка
```

### '\t' — Табуляция
`Назначение`: Вставляет пробелы до следующей позиции табуляции (обычно 4 или 8 символов).

Пример:
```c++
std::cout << "Имя:\tАнна\nВозраст:\t25";

Result:
Имя:    Анна
Возраст:        25
```

- Количество пробелов зависит от настроек терминала/редактора.

### '\r' — Возврат каретки (Carriage Return, CR)
`Назначение`: Возвращает курсор в начало строки.

Пример:
```c++
std::cout << "Загрузка...\rГотово!";

Result:
Готово!..
```

- Используется для перезаписи строки (например, в индикаторах прогресса).
- В файлах Windows CR+LF (\r\n) — стандарт конца строки.


### '\0' — Нулевой символ
`Назначение`: Маркер конца строки в C-строках.

Пример:
```c++
char str[] = {'H', 'i', '\0'};
std::cout << str;  // Выведет "Hi"
```

- Без `\0` функции типа strlen будут читать память дальше, пока не найдут случайный 0.

### '\\' — Обратный слеш
`Назначение`: Для вывода самого символа `\`.

Пример:
```c++
std::cout << "Путь: C:\\Windows\\System32";

Result: 
Путь: C:\Windows\System32
```

- Обязателен в путях файловых систем.

### '\'' — Одинарная кавычка
`Назначение`: Для вывода символа `'` внутри символьного литерала.

Пример:
```c++
char quote = '\'';
std::cout << quote;  // Выведет '
```

- Без экранирования: `'''` — ошибка компиляции.

### '\"' — Двойная кавычка
`Назначение`: Для вывода `"` внутри строкового литерала.

Пример:
```c++
std::cout << "Он сказал: \"Привет!\"";

Result:
Он сказал: "Привет!"
```

- Внутри "..." кавычки можно экранировать только так.

### '\xHH' — Символ с HEX-кодом HH
`Назначение`: Вставка символа по шестнадцатеричному коду.

Пример:
```c++
std::cout << "\x48\x69";  // Hi (H=0x48, i=0x69)
```

- Должен содержать ровно 2 HEX-цифры.
- Пример с ошибкой: "\xZ" — невалидный символ.

### '\OOO' — Символ с OCT-кодом OOO
`Назначение`: Вставка символа по восьмеричному коду.

Пример:
```c++
std::cout << "\110\151";  // Hi (H=110 в OCT, i=151 в OCT)
```

- Должен содержать от 1 до 3 восьмеричных цифр.
- Максимальное значение: '\377' (255 в десятичной).

```c++
char c1 = '\xFF';    // HEX
char c2 = '\377';    // OCT
```

- Важно: Для `char` значения >127 могут быть отрицательными (если char знаковый).
- Используйте `unsigned char` для корректной работы с кодами 128-255.

---

## 3. Каким образом можно задать пустую строку в языке C++?
Пустая строка объявляется как пара двойных кавычек без символов между ними:

```c++
const char* empty = "";  // Пустая строка (содержит только '\0')
```

Проверка на пустоту: 
```c++
if (empty[0] == '\0') 
{ 
    /* строка пуста */ 
}
```

---

## 4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
Соседние строковые литералы автоматически объединяются на этапе компиляции:

```c++
const char* combined = "Hello" " " "World!";  // Эквивалентно "Hello World!"
```

- Работает только для литералов, разделённых пробелом/переносом строки.
- Нельзя использовать переменные: "Hello" + variable — ошибка.

---

## 5. Как строковые литералы представляются в памяти?
Строковый литерал хранится в статической памяти (read-only секция):

```c++
"Hello" → | 'H' | 'e' | 'l' | 'l' | 'o' | '\0' |
```

- Литералы с одинаковым содержимым могут указывать на один и тот же адрес (оптимизация компилятора).
- Попытка изменить литерал — неопределённое поведение (UB):

```c++
char* ptr = "Hello";  // Опасное приведение (лучше использовать const char*)
ptr[0] = 'h';         // UB!
```

---

## 6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы?
Позволяют игнорировать управляющие последовательности. Объявляются как `R"(...)"`:

```c++
const char* raw = R"(C:\Files\new\file.txt)";  // Слеши и \n не экранируются
```

Для многострочных строк:
```c++
const char* multiline = R"(
    Line 1
    Line 2
)";
```

Можно использовать пользовательский разделитель (для случаев, когда строка содержит `)"`):
```c++
R"delim(Текст с )" внутри)delim"
```

---

## 7. Чем отличаются эти строковые литералы: L"Hello" от "Hello"?
Строковые литералы L"Hello" и "Hello" отличаются типом символов, которые они представляют:

- `Hello` — литерал, в котором символы представлены типом `char`
- `L"Hello"` — литерал, в котором символы представлены типом `wchar_t`

- Это означает, что в первом случае каждый символ хранится в одном байте, а во втором — в двух байтах (например, в кодировке Unicode). learn.microsoft.comrsdn.org
- Важно, что кодировка символов в строковых литералах не фиксирована в стандарте и определяется реализацией компилятора. Например, на многих платформах и компиляторах размер wchar_t — два байта, но это не обязательно.

```c++
std::cout << sizeof("A");    // 2 (char + '\0')
std::wcout << sizeof(L"A");  // 4 или 8 (зависит от размера wchar_t)
```

---

## 8. Что произойдет, если записать "abcd" "ef"?
Результат — объединённая строка "abcdef":

```c++
const char* s = "abcd" "ef";  // Эквивалентно "abcdef"
```

---

## 9. Приведите пример строки с escape-последовательностью.
```c++
const char* example = "Примеры:\n\t• Табуляция\n\t• Кавычка: \"\n\t• Слеш: \\";

Result:
Примеры:
    • Табуляция
    • Кавычка: "
    • Слеш: \
```

---

## 10. Приведите пример сырого строкового литерала, содержащего обратный слеш.
```c++
const char* raw_path = R"(C:\Program Files\Project)";
const char* raw_regex = R"(\d+\.\d+)";  // Регулярное выражение
```

---

## Дополнительные нюансы
- UTF-8/16/32 литералы:
  - `const char8_t* utf8 = u8"UTF-8 текст";`  // C++20
  - `const char16_t* utf16 = u"UTF-16 текст";`
  - `const char32_t* utf32 = U"UTF-32 текст";`

- Размер литерала:
  - `const char* str = "Hello";`
  - `size_t len = sizeof(str) - 1;`  // 5 (без учёта '\0')

- Сравнение литералов:
- `if ("Hello" == "Hello") { /* Может быть true или false (зависит от компилятора) */ }`
- Лучше использовать `strcmp()` или `std::string`.

- Многострочные литералы без R:
- `const char* text = "Line 1\n"`
<br> `"Line 2";`  // Аналогично "Line 1\nLine 2"
- 
- Использование в шаблонах:
- `std::string s = "Hello";`  // Неявное преобразование литерала в std::string