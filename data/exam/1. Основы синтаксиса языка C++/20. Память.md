Вот подробные ответы на все ваши вопросы:

---

### **1. Различие между статическим, автоматическим и динамическим выделением памяти**
- **Статическое выделение** – память выделяется на этапе компиляции и существует на протяжении всей работы программы.
    - *Пример:* глобальные переменные, `static`-переменные.
- **Автоматическое выделение** – память выделяется при входе в блок (например, функцию) и освобождается при выходе.
    - *Пример:* локальные переменные в функциях.
- **Динамическое выделение** – память выделяется и освобождается вручную (`new`/`delete`, `malloc`/`free`).
    - *Пример:* создание объектов в куче.

---

### **2. Пример статического выделения памяти**
```c++
int global_var = 42;  // Статическая память (глобальная переменная)

void foo() {
    static int static_var = 10;  // Статическая память (локальная static-переменная)
}
```

---

### **3. Как работает автоматическое выделение памяти в C++?**
Автоматическая память управляется через **стек вызовов**:
- При вызове функции её локальные переменные размещаются в стеке.
- При выходе из функции память автоматически освобождается.
- Не требует ручного управления.

```c++
void bar() {
    int x = 5;  // Автоматическое выделение (в стеке)
}  // Память освобождается здесь
```

---

### **4. Преимущество динамического выделения памяти**
- **Гибкость**: можно создавать объекты с произвольным временем жизни.
- **Размер может быть неизвестен на этапе компиляции** (например, массивы переменной длины).
- **Разделение данных между функциями** (например, возврат больших структур без копирования).

---

### **5. Срок жизни объекта при статическом выделении**
- **Глобальные переменные** – от начала программы до её завершения.
- **Локальные `static`-переменные** – от первого вызова функции до завершения программы.

---

### **6. Основные недостатки динамического выделения памяти**
- **Утечки памяти**, если не освобождать (`delete`/`free`).
- **Фрагментация кучи** – снижение производительности.
- **Накладные расходы** на управление памятью (аллокация/освобождение медленнее стека).
- **Опасность висячих указателей** (использование после `delete`).

---

### **7. Почему динамическое выделение требует больше накладных расходов?**
- **Поиск свободного блока** в куче сложнее, чем работа со стеком.
- **Синхронизация** в многопоточных программах (куча общая).
- **Дополнительные метаданные** – система хранит информацию о размере блока, его состоянии и т. д.

---

### **8. Что такое стек вызовов и как он связан с автоматическим выделением?**
- **Стек вызовов (call stack)** – структура данных, хранящая информацию о вызовах функций (адреса возврата, локальные переменные).
- **Автоматическая память** выделяется в стеке при входе в функцию и освобождается при выходе.

---

### **9. Что такое куча (heap) и как она используется в C++?**
- **Куча** – область динамической памяти, управляемая вручную (`new`/`delete`, `malloc`/`free`).
- Используется для:
    - Создания объектов с произвольным временем жизни.
    - Больших массивов или структур.
    - Разделения данных между функциями.

---

### **10. Создание и удаление одиночного объекта в динамической памяти**
```c++
int* ptr = new int(42);  // Конструкция
delete ptr;              // Удаление и освобождение памяти
```

---

### **11. Создание и удаление массива в динамической памяти**
```c++
int* arr = new int[10];  // Создание массива
delete[] arr;            // Удаление (важно использовать delete[])
```

---

### **12. Что произойдёт при использовании непарных `new/delete`?**
- `new` + `delete[]` или `new[]` + `delete` → **неопределённое поведение** (UB).
- Возможные последствия: утечки, повреждение кучи, краш программы.

---

### **13. Что такое размещающий `new` и как он используется?**
Размещающий `new` (**placement new**) позволяет создать объект в заранее выделенной памяти:
```c++
#include <new>

char buffer[sizeof(int)];  // Сырая память
int* ptr = new (buffer) int(42);  // Размещающий new
```

---

### **14. Как правильно выровнять память для размещающего `new`?**
Используйте `alignas` или `std::aligned_storage`:
```c++
alignas(int) char buffer[sizeof(int)];
int* ptr = new (buffer) int(42);
```

---

### **15. Как разрушить объект, созданный размещающим `new`?**
Нужно явно вызвать деструктор:
```c++
ptr->~int();  // Деструктор без освобождения памяти
```

---

### **16. Функции стандартной библиотеки для работы с сырой памятью**
- `std::construct_at` – создаёт объект в указанной памяти.
- `std::uninitialized_copy` – копирует элементы в неинициализированную память.
- `std::uninitialized_move` – перемещает элементы в неинициализированную память.
- `std::destroy_at` – вызывает деструктор.

---

### **17. Разница между `std::uninitialized_copy` и `std::uninitialized_move`**
- `uninitialized_copy` – копирует элементы, сохраняя исходные.
- `uninitialized_move` – перемещает элементы (исходные могут быть в невалидном состоянии).

---

### **18. Как работает `std::destroy_at` и зачем он нужен?**
Вызывает деструктор для объекта по указателю:
```c++
std::destroy_at(ptr);  // Эквивалентно ptr->~T()
```
Нужен для ручного управления временем жизни в сырой памяти.

---

### **19. Пример `std::construct_at`**
```c++
#include <memory>

alignas(std::string) char buf[sizeof(std::string)];
auto* str = std::construct_at(reinterpret_cast<std::string*>(buf), "Hello");
std::destroy_at(str);
```

---

### **20. Что такое утечка памяти и как её избежать?**
**Утечка памяти** – ситуация, когда выделенная память не освобождается.  
**Как избежать:**
- Используйте умные указатели (`std::unique_ptr`, `std::shared_ptr`).
- Следуйте **RAII** (ресурсы освобождаются в деструкторах).
- В современных C++ минимизируйте прямое использование `new`/`delete`.

```c++
// Без утечки:
auto ptr = std::make_unique<int>(42);  // Автоматически удалится
```

---

Если нужны дополнительные пояснения по какому-то пункту, уточните!