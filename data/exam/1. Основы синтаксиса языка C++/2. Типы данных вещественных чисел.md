# Типы данных вещественных чисел


## Какие типы вещественных чисел существуют в C++?
### Числа с плавающей запятой:
#### Хранят вещественные числа различного размера и точности
- float
- double
- long double
#### Гарантированы следующе соотношения размеров вещественных типов данных:
- sizeof(float) <= sizeof(double)
- sizeof(double) <= sizeof(long double)
#### Могут поддерживать специальные значения:
- Положительная и отрицательная бесконечности (INFINITY)
- Отрицательный ноль равен положительному нулю
1. `1.0/0.0  ==  INFINITY`
2. `1.0/-0.0 == -INFINITY`
- Не-числа(not-a-number, NaN) <br>
    Несравнимы на равенство ни с чем (включая самих себя)

Они хранят числа приблизительно. Точность представления меняется от удаленности от 0
Числа ближе к 0 хранятся с большей точностью, чем те которые дальше
---

## Как объявить переменную вещественного типа в C++?
```c++
float f = 3.14f;      // 'f' или 'F' указывает на float
double d = 3.14;      // по умолчанию литерал - double
long double ld = 3.14L; // 'L' или 'l' указывает на long double
```
---

## Каковы диапазоны значений для различных типов вещественных чисел в C++?
- `float`	32	±1.18×10⁻³⁸ до ±3.4×10³⁸	~6–9
- `double`	64	±2.23×10⁻³⁰⁸ до ±1.8×10³⁰⁸	~15–18
- `long double`	80/128	±3.37×10⁻⁴⁹³² до ±1.18×10⁴⁹³²	~18–36

Минимальные/максимальные значения можно получить через <limits>:
```c++
#include <limits>
std::numeric_limits<float>::min();   // наименьшее положительное нормализованное
std::numeric_limits<float>::max();   // максимальное значение
std::numeric_limits<float>::epsilon(); // машинный эпсилон (разница между 1 и следующим представимым числом)
```
---

## Какие операции можно выполнять с вещественными числами в C++?
- Арифметические: +, -, *, /, fma(a, b, c) (fused multiply-add).
- Сравнение: ==, !=, <, >, <=, >=.
- Присваивание: =, +=, -=, *=, /=.
- Инкремент/декремент: ++, -- (но редко используется).
- Битовые операции не применяются (не имеет смысла).

Особенности:
Могут поддерживать специальные значения:
- Положительная и отрицательная бесконечности (INFINITY)
- Отрицательный ноль равен положительному нулю
1. `1.0/0.0  ==  INFINITY`
2. `1.0/-0.0 == -INFINITY`
- Деление на ноль (1.0 / 0.0) даёт ±inf (не UB, в отличие от целых чисел).
- 0.0 / 0.0 даёт `NaN` (Not a Number).
---

## Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
- Если один операнд long double → другой приводится к long double.
- Иначе, если один double → другой к double.
- Иначе, если один float → другой к float.
- Иначе оба операнда целочисленные (идут целочисленные преобразования).

Пример:
```c++
float f = 1.5f;
double d = 2.5;
auto result = f * d;  // тип результата - double
```
---

## Какие математические функции доступны в C++ для работы с вещественными числами?
Из <cmath> (C++17 также <math.h> и std:: версии):
- Базовые: sqrt(), cbrt(), pow(), hypot().
- Тригонометрия: sin(), cos(), tan(), asin(), atan2().
- Экспонента/логарифм: exp(), log(), log10().
- Округление: floor(), ceil(), round(), trunc().
- Другое: fabs(), fmod(), remainder(), copysign().

```c++
#include <cmath>
double x = std::sin(3.14) + std::log(10.0);
```
---

## Как проверить, является ли вещественное число положительным или отрицательным в C++?
```c++
double x = -5.0;
if (x > 0.0) {
    // положительное
} 
else if (x < 0.0) {
    // отрицательное
} 
else {
    // ноль (или -0.0, но -0.0 == 0.0 в C++)
}
```

Проверить знак можно через `std::signbit(x)` (из <cmath>).

---

## Как проверить, является ли вещественное число целым в C++?
```c++
double x = 5.0;
if (x == std::floor(x)) {  // или std::trunc(x)
    // целое
}
```

- std::modf(x, &int_part) == 0.0 (разделяет на целую и дробную части).
- Учитывайте погрешности: 5.0 может быть 4.999999999 из-за потери точности.
---

## Как округлить вещественное число до целого в C++?
- std::round(x) – ближайшее целое (половинки округляет от нуля).
- std::floor(x) – вниз (к −∞).
- std::ceil(x) – вверх (к +∞).
- std::trunc(x) – отбрасывает дробную часть (к нулю).
- Приведение к int – просто отбрасывает дробную часть (как trunc).

```c++
double x = 3.7;
int a = static_cast<int>(x);       // 3
int b = std::round(x);             // 4
```

- Приведение больших double к int может вызвать UB (если не помещается в int).
---

## Как сравнить два вещественных числа на равенство в C++?
- Из-за погрешностей прямое == ненадёжно. Лучше использовать пороговое сравнение:
```c++
bool almost_equal(double a, double b, double epsilon = 1e-9) {
    return std::fabs(a - b) < epsilon;
}
```

- Сравнение с учётом масштаба чисел:
```c++
bool almost_equal_rel(double a, double b, double rel_epsilon = 1e-8) {
    return std::fabs(a - b) <= (std::fabs(a) + std::fabs(b)) * rel_epsilon;
}
```
- В C++20 есть std::numeric_limits<T>::epsilon() для машинного эпсилона.
---

## Какой тип будет у литерала 2e+10? В чем разница между 1.5, 1.5f и 1.5L?
- 2e+10 – по умолчанию `double`.
- 1.5 – `double`.
- 1.5f – `float` (суффикс f или F).
- 1.5L – `long double` (суффикс L или l).

Примечание:
- Без суффикса всегда double.
- Суффиксы влияют на точность и размер в памяти.

Дополнительные нюансы
- NaN и inf можно проверить:

```c++
#include <cmath>
std::isnan(x);  // true, если x - NaN
std::isinf(x);  // true, если x - ±inf
```

- Денормализованные числа – очень близкие к нулю, но не нули (могут быть медленными).
- Поведение strictfp (из Java) в C++ отсутствует – вычисления могут использовать повышенную точность.