# Операторы

## 1. Что произойдёт при выполнении выражения 17 / 5, если оба операнда имеют тип int?
При делении целых чисел (int / int) результат тоже будет целым числом (int), дробная часть отбрасывается (не округляется!):

```c++
int result = 17 / 5;  // Результат: 3
```

Если нужен дробный результат, один из операндов нужно привести к float/double:
```c++
double result = 17.0 / 5;  // 3.4
```

Отрицательные числа:
```c++
-17 / 5 = -3 (дробная часть всё равно отбрасывается).
```

---

## 2. Чем отличается поведение оператора % при работе с int и float?
Для `int`: Возвращает остаток от деления.
```c++
int a = 17 % 5;  // 2 (17 = 3*5 + 2)
```

Для `float/double`: В C++ оператор `%` не работает с дробными числами. Для этого есть `fmod()` из <cmath>:
```c++
#include <cmath>
double b = fmod(17.5, 5.0);  // 2.5
```

Поведение с отрицательными числами:
```c++
-17 % 5 = -2 (знак остатка совпадает с делимым).
```

---

## 3. Напишите выражение, проверяющее, находится ли переменная x в диапазоне от 100 до 200 включительно.
```c++
if (x >= 100 && x <= 200) {
    // x в диапазоне
}
```

Для проверки на открытом диапазоне (x ∈ (100, 200)):
```c++
if (x > 100 && x < 200)
```

---

## 4. Чем логические операторы отличаются от побитовых?
Логические и побитовые операторы отличаются тем, что логические работают с логическими значениями, а побитовые — с битами.

- Логические операторы позволяют выполнять операции между отдельными значениями или выражениями, объединять или сравнивать их, и возвращать результат в виде логических значений true (истинно) и false (ложно).
- Логические операторы часто используются в условных выражениях и циклах для контроля потока выполнения программы. Например, их применяют для проверки, соответствует ли введённое пользователем значение определённым критериям, или для управления циклом, который должен выполняться до тех пор, пока выполняется определённое условие.


- Побитовые операторы позволяют выполнять операции над двоичными данными на уровне битов. Они работают с каждым битом числа по отдельности.
- Побитовые операторы часто используются в низкоуровневом программировании и манипуляции данными, например, для установки, очистки и проверки значений флагов в переменной. Также их применяют для оптимизации производительности, так как побитовые операции выполняются быстрее, чем арифметические.


- Приоритет логических операторов определяет порядок выполнения операций в выражении. Например, оператор NOT имеет наивысший приоритет, затем — AND, и наконец — OR. Это означает, что операции с более высоким приоритетом выполняются первыми.
- Приоритет побитовых операторов также определяет порядок выполнения операций. Например, побитовое И (&) имеет более высокий приоритет, чем побитовое ИЛИ (|).

```c++
bool a = true && false;  // false
int b = 5 & 3;           // 0b101 & 0b011 = 0b001 → 1
```
---

## 5. Как работают логические операторы && и || при коротком замыкании?
Короткое замыкание (short-circuit evaluation):

Для `&&`: если левый операнд false, правый не вычисляется.
```c++
false && someFunction();  // someFunction() не вызовется
```

Для `||`: если левый операнд true, правый не вычисляется.
```c++
true || someFunction();   // someFunction() не вызовется
```
Применение:
```c++
if (ptr != nullptr && ptr->isValid()) {  // Безопасная проверка
    // ...
}
```

---

## 6. Какое значение будет у переменной j после выполнения int i = 42; int j = ++i;?
`++i` — префиксный инкремент: сначала увеличивает i, затем возвращает новое значение.

```c++
int i = 42;
int j = ++i;  // i = 43, j = 43
```

Сравнение с постфиксным инкрементом:
```c++
int i = 42;
int j = i++;  // j = 42, i = 43
```

---

## 7. Напишите фрагмент кода, устанавливающий 4 и 7 биты в целочисленной переменной.
Используем побитовое ИЛИ (|) с маской:

```c++
int num = 0;
num |= (1 << 3);  // Установка 4-го бита (биты нумеруются с 0!)
num |= (1 << 6);  // Установка 7-го бита
// Теперь num = 0b01001000 (72 в десятичной)
```

---

## 8. Напишите фрагмент кода, сбрасывающий все биты кроме 3-го в целочисленной переменной.
Используем побитовое И (&) с маской:
```c++
int num = 0xFF;  // 0b11111111
num &= (1 << 2);  // Оставляем только 3-й бит
// Теперь num = 0b00000100 (4 в десятичной)
```

---

## 9. Напишите код, обменивающий местами 4 и 6 биты в целочисленной переменной.
- Проверяем, разные ли биты.
- Если разные, инвертируем их с помощью XOR (^):

```c++
int num = 0b01010000;  // Пример числа
int bit4 = (num >> 3) & 1;
int bit6 = (num >> 5) & 1;
if (bit4 != bit6) {
    num ^= (1 << 3 | 1 << 5);  // Инвертируем оба бита
}
// Результат: 0b00010010
```

---

## 10. Какой результат даст выражение 0b101101 ^ 0b110110?
Операция XOR (^) выполняет инверсию битов, где биты разные:

```c++
  0b101101 (45)
^ 0b110110 (54)
= 0b011011 (27)
```

Пошагово:
```c++
1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
```

## Дополнительные нюансы

Переполнение при сдвиге:
```c++
int x = 1 << 31;  // UB для знакового int (результат зависит от компилятора)
```

Без знаковые типы:
```c++
unsigned int y = 0b1111;
y >> 2;  // 0b0011 (логический сдвиг, заполнение нулями)
```

Побитовые операции с bool:
```c++
bool a = true, b = false;
int c = a & b;  // 0 (но лучше избегать, используйте логические операторы)
```

Быстрая проверка чётности:
```c++
if (x & 1) { /* нечётное */ }
```

## Побитовые операции 

### Побитовые операции в C++

Побитовые операции работают непосредственно с битами чисел. Они выполняются над целочисленными типами (`int`, `char`, `unsigned`, и т.д.) и применяются к каждому биту операндов независимо.

---

## **1. Основные побитовые операторы**

### **1.1. Побитовое И (`&`)**
**Логика**: `1 & 1 = 1`, иначе `0`.  
**Применение**:
- Проверка установки бита.
- Сброс битов с помощью маски (`x & ~mask`).

**Пример**:
```cpp
int a = 0b1100;  // 12
int b = 0b1010;  // 10
int res = a & b; // 0b1000 (8)
```

**Использование для проверки бита**:
```cpp
bool isBitSet = (x & (1 << n)) != 0; // Проверяет, установлен ли n-й бит
```

---

### **1.2. Побитовое ИЛИ (`|`)**
**Логика**: `0 | 0 = 0`, иначе `1`.  
**Применение**:
- Установка битов (`x | mask`).

**Пример**:
```cpp
int a = 0b1100;  // 12
int b = 0b1010;  // 10
int res = a | b; // 0b1110 (14)
```

**Установка бита**:
```cpp
x = x | (1 << n); // Устанавливает n-й бит в 1
```

---

### **1.3. Побитовое исключающее ИЛИ (`^`)**
**Логика**: `1 ^ 1 = 0`, `0 ^ 0 = 0`, иначе `1`.  
**Применение**:
- Инверсия битов (`x ^ mask`).
- Обмен значений без временной переменной.

**Пример**:
```cpp
int a = 0b1100;  // 12
int b = 0b1010;  // 10
int res = a ^ b; // 0b0110 (6)
```

**Инверсия бита**:
```cpp
x = x ^ (1 << n); // Переключает n-й бит (0→1, 1→0)
```

**Обмен значений**:
```cpp
a ^= b;
b ^= a;
a ^= b; // Теперь a и b поменялись значениями
```

---

### **1.4. Побитовое НЕ (`~`)**
**Логика**: Инвертирует все биты (`~0b1010 → 0b0101`).  
**Применение**:
- Создание маски для сброса битов.

**Пример**:
```cpp
int a = 0b00001111; // 15
int res = ~a;       // 0b11110000 (-16 в дополнении до двух)
```

**Сброс битов**:
```cpp
x = x & ~(1 << n); // Сбрасывает n-й бит в 0
```

---

### **1.5. Битовые сдвиги (`<<`, `>>`)**
**Логика**:
- `x << n` — сдвигает биты влево, заполняя нулями (`x * 2ⁿ`).
- `x >> n` — сдвигает вправо (для **беззнаковых** — заполняет нулями, для **знаковых** — зависит от компилятора).

**Пример**:
```cpp
int a = 0b0001;       // 1
int left = a << 2;     // 0b0100 (4)
int right = a >> 1;    // 0b0000 (0)
```

**Применение**:
```cpp
int powerOfTwo = 1 << n; // Быстрое вычисление 2ⁿ
```

---

### **2. Работа с масками**

Маска — это число, биты которого задают шаблон для операций.

#### **2.1. Установка битов**
```cpp
x |= (1 << 3) | (1 << 5); // Установка 4-го и 6-го битов
```

#### **2.2. Сброс битов**
```cpp
x &= ~(1 << 2); // Сброс 3-го бита
```

#### **2.3. Проверка битов**
```cpp
if (x & (1 << 4)) { /* 5-й бит установлен */ }
```

#### **2.4. Инверсия битов**
```cpp
x ^= (1 << 0) | (1 << 1); // Инвертирует 1-й и 2-й биты
```

#### **2.5. Извлечение группы битов**
```cpp
int extracted = (x >> 2) & 0b111; // Извлекает 3 бита, начиная со 2-го
```

---

### **3. Практические примеры**

#### **3.1. Подсчёт установленных битов**
```cpp
int countBits(int x) {
    int count = 0;
    while (x) {
        count += x & 1;
        x >>= 1;
    }
    return count;
}
```

#### **3.2. Быстрое умножение/деление на степень двойки**
```cpp
int multiplyByPowerOfTwo(int x, int n) {
    return x << n; // x * 2ⁿ
}

int divideByPowerOfTwo(int x, int n) {
    return x >> n; // x / 2ⁿ (для положительных x)
}
```

#### **3.3. Проверка чётности**
```cpp
bool isEven(int x) {
    return (x & 1) == 0;
}
```

---

## **4. Важные нюансы**
1. **Знаковые vs беззнаковые сдвиги**:
    - Для `unsigned` сдвиг вправо всегда заполняется нулями.
    - Для `int` поведение зависит от компилятора (обычно арифметический сдвиг).

2. **Переполнение при сдвиге**:
   ```cpp
   int x = 1 << 31; // UB для 32-битного int
   ```

3. **Порядок битов**:
    - Нумерация битов начинается с **0** (младший бит).

4. **Маскирование**:
   ```cpp
   int lowerNibble = x & 0xF; // Оставляет только 4 младших бита
   ```

---

### **Вывод**
Побитовые операции позволяют эффективно управлять отдельными битами данных. Они используются в:
- Низкоуровневом программировании (драйверы, embedded).
- Оптимизации вычислений (например, быстрые умножения).
- Криптографии и сжатии данных.

Их понимание важно для написания эффективного и компактного кода. 🚀









