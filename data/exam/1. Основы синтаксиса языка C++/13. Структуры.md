# Структуры


## 1. Что такое структура в C++ и в чём её преимущества по сравнению с отдельными переменными?
- Структура - это одна или несколько переменных (возможно, различных типов), которые для удобства работы с ними сгруппированы под одним именем.
- Структуры помогают в организации сложных данных, позволяя группу связанных между собой переменных трактовать не как множество отдельных элементов, а как единое целое

Структура (struct) — это пользовательский тип данных, который объединяет несколько переменных (полей) разных или одинаковых типов под одним именем.

Преимущества перед отдельными переменными:
- `Группировка данных`: Логически связанные данные хранятся вместе (например, Point {x, y}).
- `Удобство передачи`: Можно передать одну структуру в функцию вместо множества отдельных аргументов.
- `Читаемость кода`: Улучшает понимание программы.
- `Повторное использование`: Структуру можно использовать многократно в разных частях программы.

---

## 2. Как объявить структуру?
```c++
struct Person
{
    std::string name;
    std::string surname;
    int birthYear;
};
```

---

## 3. Какие типы данных могут использоваться в полях структуры?
Можно использовать:
- Базовые типы (int, double, char и т. д.).
- Пользовательские типы (другие struct, class).
- Указатели и ссылки.
- Массивы (в том числе std::array, std::vector).
- std::string и другие контейнеры STL.
- Перечисления (enum).

Нельзя использовать:
- Собственный тип внутри себя (рекурсивно), но можно указатель на него:
```c++
struct Node {
    Node* next;  // Допустимо
    Node child;  // Ошибка!
};
```

---

## 4. Что такое член структуры и как им можно управлять?
- Член структуры (member) — это переменная, которая является частью структуры (структуры (struct)). 
- Члены структуры также часто называют элементами или полями.

Управление полями:
- Доступ через оператор `.` (для объекта) или `->` (для указателя).
- Можно изменять, читать, передавать в функции.
- Уровень доступа по умолчанию — public (в отличие от class, где по умолчанию private).

---

## 5. Как инициализировать структуру при её объявлении?
- Aggregate initialization (агрегатная инициализация):
```c++
Person p = {"Alice", 25, 1.75};
```
- Uniform initialization (C++11 и выше):
```c++
Person p{"Alice", 25, 1.75};
```
- Конструктор (если определён в структуре).

---

## 6. Какой синтаксис используется для доступа к полям структуры?
Для объекта:
```c++
Person p;
p.name = "Bob";
```

Для указателя:
```c++
Person* ptr = &p;
ptr->age = 30;
// или (*ptr).age = 30;
```

---

## 7. Как инициализировать структуру с вложенными структурами?
```c++
struct Address {
    std::string city;
    int zip;
};

struct Employee {
    std::string name;
    Address addr;
};

Employee emp = {"John", {"New York", 10001}};
```

---

## 8. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
По значению (создаётся копия):
```c++
void printPerson(Person p) { ... }
```

По ссылке (изменения влияют на оригинал):
```c++
void updatePerson(Person& p) { ... }
```

void readPerson(const Person& p) { ... }
```c++
void readPerson(const Person& p) { ... }
```

По указателю:
```c++
void modifyPerson(Person* p) { ... }
```

---

## 9. В чём разница между передачей структуры по значению и по ссылке?
- По значению: Создаётся копия структуры. Изменения внутри функции не затрагивают оригинал. Может быть накладно для больших структур.
- По ссылке: Передаётся ссылка на оригинал. Изменения внутри функции влияют на оригинал. Эффективно по памяти.

---

## 10. Что происходит с полями глобальных структур при их объявлении?
При объявлении глобальной структуры (или класса) её поля инициализируются в зависимости от контекста:

- Если поля явно инициализированы – они получают указанные значения.
- Если поля не инициализированы:
  - Примитивные типы (int, float, bool и т. д.) – заполняются нулями (так как глобальные переменные хранятся в области BSS и обнуляются при старте программы).
  - Объекты классов – вызываются их конструкторы по умолчанию.
  - Указатели – становятся nullptr.

```c++
struct Data { int a; std::string s; };
Data globalData;  // a = 0, s = "" (пустая строка)
```

---

## 11. Что выведет программа, если поле std::string структуры не инициализировано?
Для локальной структуры:
```c++
struct Test { std::string s; };
Test t;  // t.s - пустая строка (""), так как std::string имеет конструктор по умолчанию.
```

Для динамического выделения:
```c++
Test* t = new Test;  // t->s также пустая строка.
```

---

## 12. Как можно сравнить две структуры на равенство?
По полям:
```c++
bool isEqual(const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
}
```

Через оператор == (если перегружен):
```c++
bool operator==(const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
}
```

---

## 13. Когда предпочтительнее использовать структуры вместо классов?
Структуры в C++ предпочтительнее использовать, когда нужно хранить набор связанных данных в одном месте. Классы, в свою очередь, подходят для более сложных объектов с методами и инкапсуляцией.

- Структуры используют для простых данных (POD — Plain Old Data), где все поля открыты (`public`).
- Классы — когда нужна инкапсуляция (приватные поля + методы).
  - В C++ разница между struct и class только в дефолтном уровне доступа (`public` vs `private`).

---

## 14. Как порядок полей в стуктуре влияет на её размер? С чем это связано?
Порядок полей влияет на выравнивание (alignment) в памяти. Компилятор добавляет padding (пустые байты), чтобы поля располагались по адресам, кратным их размеру.
```c++
struct A { char c; int i; };  // Размер может быть 8 байт (1 + 3 padding + 4).
struct B { int i; char c; };  // Размер может быть 5 байт (4 + 1).
```
Оптимизация: Располагайте поля в порядке убывания размера (double, int, char).

---

## 15. Указатель на структуру, как обратиться к полю структуры по указателю?
Через оператор ->:
```c++
Person* ptr = new Person{"Alice", 30};
ptr->name = "Bob";  // Доступ к полю.
delete ptr;
```

---

## 16. Массивы структур.
```c++
Person people[3] = {
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 35}
};
// Или динамически:
Person* dynArray = new Person[2];
dynArray[0].name = "John";
```

---

## 17. Размещение полей структур в памяти.
Поля структур в C++ размещаются в памяти с учётом выравнивания (alignment). Это означает, что компилятор может добавлять дополнительные байты между полями, чтобы обеспечить корректное выравнивание каждого поля в памяти.

По умолчанию компилятор выравнивает поля по границе, кратной их размеру. Например:
- 1-байтовые поля не выравниваются;
- 2-байтовые — на чётные позиции;
- 4-байтовые — на позиции, кратные 4.

- Поля располагаются последовательно в порядке объявления.
- Компилятор добавляет padding для выравнивания.
- Можно управлять выравниванием с помощью #pragma pack:
```c++
#pragma pack(1)  // Убирает padding.
struct Packed { char c; int i; };  // Размер 5 байт.
#pragma pack()
```

## Дополнительные нюансы
Bit fields (битовые поля):
```c++
struct Flags {
    unsigned int isReady : 1;  // 1 бит
    unsigned int mode : 3;     // 3 бита
};
```

Анонимные структуры (C++11):
```c++
struct { int x; int y; } point;  // Безымянная структура.
```