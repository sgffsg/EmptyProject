# Переменные

## 1. Объявление переменных
- Объявление переменной в C++ — это процесс создания переменной с указанием её типа и имени.
  - Переменная должна быть объявлена до её использования.
  - Можно объявить переменную без инициализации, но тогда она будет содержать мусор (если не глобальная или static).

Синтаксис:
```c++
тип имя_переменной;          // Объявление без инициализации
тип имя_переменной = значение; // Объявление с инициализацией
тип имя_переменной{значение};  // Uniform initialization (C++11)
```

Примеры:
```c++
int x;          // Объявлена переменная x типа int (значение не определено)
double y = 3.14; // Объявлена и инициализирована переменная y
std::string s{"Hello"}; // Инициализация с помощью списка (C++11)
```

- В C++ объявление ≠ определение, но для переменных (не extern) это обычно одно и то же.
- Можно объявить несколько переменных в одной строке:
```c++
int a, b = 5, c{}; // a — не инициализирована, b = 5, c = 0
```

- Имена переменных чувствительны к регистру (var ≠ Var).

---

## 2. Автоматическое определение типа переменной
С C++11 можно использовать ключевое слово auto, чтобы компилятор сам вывел тип переменной на основе инициализатора.

Синтаксис:
```c++
auto имя_переменной = выражение;  
auto имя_переменной{значение};  
```

Примеры:
```c++
auto x = 42;        // int
auto y = 3.14;      // double
auto s = "Hello";   // const char*
auto vec = std::vector<int>{1, 2, 3}; // std::vector<int>
```

- `auto` обязательно требует инициализации (иначе компилятор не поймёт тип).
- Если нужно ссылочное или константное поведение, используются модификаторы:
```c++
auto& ref = x;          // ссылка (int&)
const auto pi = 3.14;   // const double
auto* ptr = &x;         // указатель (int*)
```
- auto выводит тип без учёта ссылок и константности, если не указано иное:
```c++
const int a = 10;
auto b = a; // тип b — int (константность теряется)
auto& c = a; // тип c — const int& (константность сохраняется)
```

---

## 3. Объявление константной переменной.
Константная переменная — это переменная, значение которой нельзя изменить после инициализации.

Способы объявления:
- `const` (базовый способ, время компиляции или выполнения).
- `constexpr` (значение должно быть известно на этапе компиляции, C++11).

Синтаксис:
```c++
const тип имя = значение;  
constexpr тип имя = значение;  
```

Примеры:
```c++
const int MAX_SIZE = 100; // Обычная константа
const double PI = 3.14159;

constexpr int ARRAY_SIZE = 10; // Значение известно при компиляции
constexpr auto N = sizeof(int); // Вычисляется на этапе компиляции
```

`const` можно инициализировать во время выполнения:
```c++
int x;
std::cin >> x;
const int y = x; // Допустимо
```

`constexpr` требует константного выражения:
```c++
constexpr int z = 10 * 2; // OK
// constexpr int w = y; // Ошибка: y не constexpr
```

Указатели и ссылки тоже могут быть `const`:
```c++
const int* ptr = &x; // Указатель на константу
int* const p = &y;   // Константный указатель
```

---

## 4. Области видимости переменных.

Основные области видимости:

1. Локальные переменные (внутри блока {}).
```c++
void foo() {
    int x = 5; // Видна только внутри foo()
    if (true) {
        int y = 10; // Видна только внутри if
    }
    // y здесь недоступна
}
```

2. Глобальные переменные (вне всех функций).
```c++
int globalVar = 42; // Глобальная переменная
int main() {
    std::cout << globalVar; // Доступна
}
```

3. Пространства имён (namespace).
```c++
namespace MyNS {
    int var = 10; // Доступ через MyNS::var
}
```

4. Классы (class/struct).
```c++
class MyClass {
    static int classVar; // Статическая переменная класса
    int instanceVar;     // Переменная экземпляра
};
```

### Нюансы   
`Shadowing` (перекрытие) — если во вложенном блоке объявить переменную с тем же именем:
```c++
int x = 10;
{
    int x = 20; // Перекрывает внешнюю x
    std::cout << x; // 20
}
```

`static` локальные переменные сохраняют значение между вызовами функции:
```c++
void counter() {
    static int count = 0;
    count++;
    std::cout << count << "\n";
}
counter(); // 1
counter(); // 2
```

### Область видимости переменной
```c++
int main()
{
    // Область видимости переменной ограничена блоком, внутри которого она объявлена
    std::string username = "Ivan Petrov";
    int age = 10;
    
    {
        // Переменная из внутреннего блока может иметь имя, совпадающее с именем из внешнего блока
        // При этом внутри этого блока она замещает собой одноименную переменную из внешего блока
        std::string username = "Sergey Ivanov";
        assert(username == "Sergey Ivanov");
        
        // Тип переменной age может отличаться от типа одноименной переменной из внешнего блока
        double age = 7.7; 
    }
    
    // При возврате во внешний блок видимой снова становится внешняя переменная
    assert(username == "Ivan Petrov");
}
```

### Объявление глобальных переменных
```c++
// Глобальные переменные по умолчанию инициализируются нулями
int globalVar;
int anotherGlobalVar = 42; // Можно проинициализировать заранее заданным значением

std::cout << globalVar << std::endl; // 0
globalVar = 13;
std::cout << globalVar << std::endl; // 13
std::cout << anotherGlobalVar << std::endl; // 42
```

---

## 5. Доступ к переменной, объявленной в другое единице трансляции.
Единица трансляции — это .cpp-файл после обработки препроцессором.

Чтобы использовать переменную из другого файла:
- Объявить её с extern в заголовочном файле (.h).
- Определить в одном из .cpp-файлов.

Пример:

globals.h (объявление):
```c++
extern int globalVar; // Объявление без определения
```

globals.cpp (определение):
```c++
#include "globals.h"
int globalVar = 42; // Определение
```

main.cpp (использование):
```c++
#include "globals.h"
int main() {
    std::cout << globalVar; // 42
}
```

### Нюансы
- `extern` означает, что переменная определена в другом месте.
- Если не использовать extern, то в каждом .cpp будет своя отдельная переменная (нарушение ODR).
- Для констант (const) в C++ по умолчанию внутренняя компоновка, поэтому их можно определять в заголовочных файлах:
```c++
const int MAX_SIZE = 100; // Не требует extern
```
- Для constexpr переменных extern не нужен, так как они неявно inline (C++17).
