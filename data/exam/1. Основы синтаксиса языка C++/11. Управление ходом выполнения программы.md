# Управление ходом выполнения программы

## 1. Что делает точка с запятой в конце выражения в C++?
Точка с запятой `;` в C++ обозначает конец выражения (инструкции). Она сообщает компилятору, что текущая команда завершена.

```c++
int x = 5;  // точка с запятой завершает объявление переменной
std::cout << x;  // завершает вызов функции
```

- Отсутствие `;` приводит к синтаксической ошибке.
- В некоторых конструкциях (например, в циклах `for`) точка с запятой используется как разделитель.
- Выражение (например, x = 0) становится инструкцией, если в конце поставить точку с запятой

---

## 2. Как объединить несколько инструкций в одну составную инструкцию?
Фигурные скобки { и } используются для объединения объявлений и инструкций в составную инструкцию, или блок

С точки зрения синтаксиса языка блок воспринимается как одна инструкция

```c++
{
    int x = 5;
    std::cout << x;
    x++;
}
```

- Блок создаёт новую область видимости.
- Можно использовать в if, for, while и других конструкциях.

---

## 3. Что происходит с переменными, объявленными внутри блока при его завершении?
- Блок создаёт новую область видимости переменных, которые в нём объявлены
- При покидании блока видимости переменная уничтожается, а занимаемая ею область памяти – освобождается

```c++
int main(int argc, char * argv)
{
	int a = 0;
	if (argc > 1)
	{
		int b = argc - 1;
	}
	return 0;
}
```

```c++
{
    int x = 10;
    std::cout << x;  // OK
}
std::cout << x;  // Ошибка: x не существует
```

- Если переменная была объектом класса, вызывается её деструктор.
- Вложенные блоки могут переопределять переменные из внешних блоков.

---

## 4. Оператор if. Конструкция else if.
- Оператор if позволяет выполнить тот или иной участок кода в зависимости от значения некоторого выражения
```c++
if (<выражение>)
    <инстр.1>
else
    <инстр.2>
if (<выражение>)
    <инстр>
```

Пример:
```c++
int number;
if (std::cin >> number) // Удалось ли прочитать number из консоли?
{
    if (number % 2 == 0)
        std::cout << "Number is even";
    else
        std::cout << "Number is odd";
}
// Можно ли здесь использовать переменную number?
```

### В выражении if можно объявлять переменные
```c++
if (int number; std::cin >> number)
{ // Видимость переменной `number` ограничена блоком if
    if (number % 2 == 0)
        std::cout << "Number is even";
    else
        std::cout << "Number is odd";
}
else
{
    // Переменная number видна и здесь,
    // но тут number не инициализирована и использовать её нельзя
    number = 42;
}
// Здесь number не видна
```

### Значение объявленной переменной участвует в проверке условия
```c++
int x;
int y;
std::cin >> x >> y;
if (int sum = x + y)
{ // сюда попадём, если sum — не 0
    std::cout << sum << std::endl;
}
else
{
    // Переменная sum равна нулю
}
```

### Конструкция else-if
- Позволяет осуществлять многоступенчатое решение
```c++
if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else 
    инструкция 
```

---

## 5. Почему рекомендуется использовать фигурные скобки даже для однолинейных if/else?
- Читаемость — явно видно границы блока.
- Защита от ошибок — если добавить вторую строку без скобок, она не попадёт в условие.

```c++
if (x > 0)
    std::cout << "Positive";
    x++;  // выполнится всегда, а не только при x > 0
```

---

## 6. if constexpr. Для чего используется? Какие ограничения?
`if constexpr` — конструкция в языке C++, введённая в C++17, которая позволяет выполнять ветвление кода во время компиляции на основе постоянных выражений.

`if constexpr` используется для принятия решений во время компиляции на основе характеристик типа или других постоянных выражений. Некоторые области применения:
- `Метапрограммирование шаблонов` — создание общих шаблонов, которые адаптируют поведение в зависимости от условий времени компиляции.
- `Условная генерация кода` — включение или исключение разделов кода на основе определённых условий в процессе компиляции.
- `Утверждения во время компиляции` — проверка условий помогает выявлять ошибки на ранней стадии и гарантировать выполнение определённых условий во время компиляции.
- `Оптимизация алгоритма` — выбор оптимизированных алгоритмов во время компиляции, что улучшает производительность без затрат времени выполнения.

```c++
if constexpr (условие) {  
    // Код выполняется только если условие истинно во время компиляции  
}  
else {  
    // Код выполняется только если условие ложно во время компиляции  
}
```

```c++
template <typename T>
void print(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integer: " << value;
    } else {
        std::cout << "Not integer: " << value;
    }
}
```

Ограничения:
- Работает только в шаблонах и с константами времени компиляции.
- Нельзя использовать с runtime-условиями.

---

## 7. Как исправить ошибку в коде:
```c++
if (n > 0)
    if (a > b)
        z = a;
else
    z = b;
```

`Проблема`: else относится к ближайшему if, а не к внешнему.
```c++
if (n > 0) 
{
    if (a > b)
        z = a;
} 
else 
{
    z = b;
}
```

---

## Циклическое выполнение
- Цикл – последовательность из нескольких операторов, указываемая в программе один раз, которая выполняется несколько раз подряд
- Допускается существование бесконечного цикла
- Тело цикла - последовательность операторов, предназначенная для многократного выполнения в цикле

## 8. Оператор цикла for. Цикл for со счётчиком. Синтаксис.
Оператор for служит для организации циклов со счетчиком

Синтаксис:
```c++
for (инициализация; условие; инкремент) {
    // тело цикла
}
```

Пример:
```c++
for (int i = 0; i < 10; i++) {
    std::cout << i << " ";
}
```

- Любая часть может быть опущена (for(;;) — бесконечный цикл).
- Область видимости счётчика — внутри цикла (если объявлен внутри for).


- Оператор инициализации счетчика цикла выполняется один раз перед началом цикла <br>
- Выполнение инструкции (тела цикла) продолжается до тех пор, пока условие `истинно`, если выражение2 отсутствует, то выполнение цикла продолжается бесконечно
- После каждой итерации цикла выполняется инкриминирование (изменение счетчика)

---

## 9. Range-based for. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based for?
Версия цикла for, предназначенная для перебора элементов некоторого диапазона <br>
(Массивы, строки, контейнеры стандартной библиотеки, пользовательские типы данных)

Контейнер должен поддерживать:
- `begin()` и `end()` методы (или свободные функции).
- Итераторы должны поддерживать операции `++`, `*` и `!=`.

Синтаксис:
```c++
for (тип идентификатор : диапазон)
инструкция
```

Пример:
```c++
std::vector<int> v = {1, 2, 3};
for (int x : v) {
    std::cout << x << " ";
}
```

---

## 10. Что происходит, если условие в for отсутствует?
Цикл становится бесконечным (условие считается true).

```c++
for (int i = 0; ; i++) {
    std::cout << i << " ";
    if (i >= 10) break;
}
```

---

## 11. Оператор цикла while.
Оператор while служит для организации циклов с предусловием 

Цикл, который выполняется, пока истинно некоторое условие, указанное перед его началом

Синтаксис
```c++
while (выражение)
{
    инструкция
}
```

Пример:
```c++
while (x > 0) {
    std::cout << x-- << " ";
}
```

Инструкция (тело цикла) выполняется до тех пор, пока выражение принимает ненулевое значение

---

## 12. Оператор цикла do-while.
Оператор do-while служит для организации циклов с постусловием
1. цикл, в котором условие проверяется после выполнения тела цикла
2. тело всегда выполняется хотя бы один раз

3. Синтаксис
```c++
do
инструкция
while (выражение);
```

Пример:
```c++
do {
    std::cout << "Enter x: ";
    std::cin >> x;
} while (x != 0);
```

- Инструкция выполняется до тех пор, пока выражение принимает ненулевое значение

---

## 13. В чём разница между while и do-while? Приведите пример.
- while сначала проверяет условие, потом выполняет тело.
- do-while сначала выполняет тело, потом проверяет условие.

---

## 14. Досрочный выход из цикла и пропуск итерации цикла.
- Внутри циклов могут использоваться операторы управления работой цикла:
1. `break` для досрочного выхода из цикла
2. `continue` для пропуска текущей итерации и перехода к следующей итерации

```c++
for (int i = 0; i < 10; i++) {
    if (i == 5) break;  // выход при i = 5
    if (i % 2 == 0) continue;  // пропуск чётных
    std::cout << i << " ";
}
```

- Инструкция break осуществляет немедленный выход из тела цикла, внутри которого она находится <br>
  - Также инструкция break осуществляет выход из оператора switch
- Инструкция continue осуществляет пропуск оставшихся операторов тела цикла, внутри которого она находится, и переход на следующую итерацию цикла
  - В циклах while и do-while осуществляется переход к проверке условия
  - В цикле for осуществляется переход к приращению переменной цикла

---

## 15. Какой оператор лучше использовать для цикла, который должен выполниться как минимум один раз?
`do-while`, т.к. он гарантирует хотя бы одно выполнение.

---

## 16. Как, находясь во внутреннем цикле, выйти из внешнего?
Воспользоваться меткой (редко) или флагом.

Метка:
```c++
goto label;  
...  
label:  
// код для выполнения  
```

Флаг:
```c++
bool exitFlag = false;
for (int i = 0; i < 10 && !exitFlag; i++) {
    for (int j = 0; j < 10; j++) {
        if (i * j > 50) {
            exitFlag = true;
            break;
        }
    }
}
```

---

## 17. Что делает оператор break внутри цикла?
Немедленно завершает выполнение ближайшего цикла (for, while, do-while).

---

## 18. Что делает оператор continue внутри цикла?
Пропускает оставшуюся часть текущей итерации и переходит к следующей.

---

## 19. Для каких типов данных используется switch?
- Используется для выбора одного из нескольких путей <br>
  Если выражение равно одному из указанных целочисленных констант, выполняются соответствующие действия
- Инструкция break выполняет выход из блока switch

```c++
#include <string>
#include <iostream>
#include <cassert>
 
enum class WeekDay
{
  Sunday, Monday, Tuesday, Wednesday,
  Thursday, Friday, Saturday
};
 
std::string WeekDayToString(WeekDay weekDay)
{
  switch (weekDay)
  {
  case WeekDay::Sunday:    return "Sunday";
  case WeekDay::Monday:    return "Monday";
  case WeekDay::Tuesday:   return "Tuesday";
  case WeekDay::Wednesday: return "Wednesday";
  case WeekDay::Thursday:  return "Thursday";
  case WeekDay::Friday:    return "Friday";
  case WeekDay::Saturday:  return "Saturday";
  default:
    assert(!"This is not possible");
    return "";
  }
}
 
void main()
{
  std::cout << WeekDayToString(WeekDay::Sunday) << std::endl;
}
```

switch работает с:
- Целыми числами (int, char, enum).
- Перечислениями (enum class в C++11).
- constexpr-выражениями.

Нельзя использовать: `float, string, пользовательские классы`.

---

## 20. Что делает default в операторе switch?
Выполняется, если ни один case не совпал.

```c++
switch (x) {
    case 1: std::cout << "One"; break;
    default: std::cout << "Other";  // выполнится, если x ≠ 1
}
```

---

## 21. Что такое "сквозное" выполнение ветвей case?
Если case не заканчивается break, выполнение продолжается в следующем case.

```c++
switch (x) {
    case 1:
    case 2:  // выполнится и при x=1, и при x=2
        std::cout << "1 or 2";
        break;
}
```

---

## 22. Для чего применяется атрибут [[fallthrough]]?
Явно указывает, что "сквозное" выполнение (fallthrough) сделано намеренно.

```c++
switch (x) {
    case 1:
        std::cout << "1";
        [[fallthrough]];  // явное указание
    case 2:
        std::cout << "2";
        break;
}
```

---

## 23. Какие типы данных поддерживаются range-based for?
Версия цикла for, предназначенная для перебора элементов некоторого диапазона <br>
(Массивы, строки, контейнеры стандартной библиотеки, пользовательские типы данных)

Контейнер должен поддерживать:
- `begin()` и `end()` методы (или свободные функции).
- Итераторы должны поддерживать операции `++`, `*` и `!=`.

---

## 24. Почему использование goto считается плохой практикой?
- Инструкция goto позволяет осуществить переход на заданную метку внутри текущей функции
- Синтаксис:
  `goto метка;`
- Как правило, использование инструкции goto усложняет структуру программы и без крайней необходимости ею пользоваться не стоит <br>
  Если Вы все еще думаете об использовании этого оператора – использовать его все равно не стоит

Использование `goto`
- Ухудшает читаемость.
- Усложняет отладку.
- Может привести к "спагетти-коду".

```c++
start:
    x++;
    if (x < 10) goto start;  // лучше использовать while
```

```c++
/* поиск совпадающих элементов в массивах */
for (i = 0; i < n; ++i)
{
	for (j = 0; j < m; ++j)
	{
		if (a[i] == b[j])
			goto found;
	}
}
/* нет одинаковых элементов */

found:
/* обнаружено совпадение: a[i] == b[j] 	*/
```

---

## 25. Приведите пример ошибки, связанной с отсутствием фигурных скобок в `if
Пример:
```c++
if (x > 0)
    std::cout << "Positive";
    x = 0;  // выполнится всегда, а не только при x > 0
```

Исправление:
```c++
if (x > 0) {
    std::cout << "Positive";
    x = 0;
}
```
---
