# Функции

## 1. Для чего используются функции?
- Именованная последовательность инструкций
- Основа процедурного программирования
- Определив однажды функцию, можно вызывать её многократно
- Могут иметь возвращаемое значение <br>
  Оператор return служит для возврата значения с выходом из функции
- Функция может иметь тип возвращаемого значения void

```c++
// Функция без параметров и возвращаемого значения
void SayHello() {
    std::cout << "Hello" << std::endl;
}

// Функция с параметром
void Print(int value) {
    std::cout << value << std::endl;
}

// Функция с параметрами, которая возвращает значение типа int
int Add(int x, int y) {
    return x + y;
}
```

---

## 2. Какой оператор используется для возврата значения из функции?
- `return` – возвращает значение и завершает выполнение функции.
- Если функция `void`, `return` можно опустить или использовать без значения.

```c++
int square(int x) { return x * x; }  // возвращает квадрат числа
void log(const std::string& msg) { std::cout << msg; }  // ничего не возвращает
```

---

## 3. Может ли функция не возвращать значение? Если да, как это указывается?
Да, если функция ничего не возвращает, её тип указывается как void.

```c++
void printHello() { std::cout << "Hello!"; }
```

- Если void-функция завершается без return, компилятор добавит его неявно.
- В main() можно не писать return 0; (начиная с C++11).

---

## 4. Какой синтаксис используется для объявления функции?
Объявление (прототип) функции включает:
- Тип возвращаемого значения (или void).
- Имя функции.
- Список параметров (может быть пустым).

Пример:
```c++
int max(int a, int b);  // объявление
```

Определение функции:
```c++
int max(int a, int b) { return (a > b) ? a : b; }  // определение
```

---

## 5. В чём разница между объявлением и определением функции?
- Объявление функции (или прототип функции) сообщает компилятору о существовании функции, её имени, типе возвращаемого значения и параметрах. Оно предоставляет информацию об интерфейсе функции, не включая её реализацию.
  - Объявление позволяет другим частям программы вызывать функцию, не зная её внутренних деталей.
- Определение должно соответствовать объявлению, чтобы компилятор мог правильно связать вызовы функции с её реализацией. Несовпадение приводит к ошибке компиляции.Определение функции содержит её тело, которое описывает, как она выполняет задачу. Оно определяет, что делает функция, включая инструкции, которые должны выполняться при вызове.
  - Определение должно соответствовать объявлению, чтобы компилятор мог правильно связать вызовы функции с её реализацией. Несовпадение приводит к ошибке компиляции.

---

## 6. Почему объявление функции должно быть выполнено до её вызова?
C++ компилируется сверху вниз. Если функция вызывается до объявления, компилятор не знает:
- Существует ли она.
- Какие у неё параметры.
- Какой тип возвращаемого значения.

Решение:
- Либо определить функцию до вызова.
- Либо использовать предварительное объявление (прототип).

---

## 7. Какой способ передачи параметров используется по умолчанию в C++?
По умолчанию параметры передаются по значению (копируются).

```c++
void modify(int x) { x = 10; }  // x – копия, оригинал не изменится
int a = 5;
modify(a);  // a останется 5
```

---

## 8. Что происходит с параметром, переданным по значению, внутри функции?
- Создаётся локальная копия параметра.
- Изменения внутри функции не влияют на оригинал.

```c++
void increment(int x) { x++; }
int val = 5;
increment(val);  // num останется 5
```

---

## 9. В чём разница между передачей по значению и по ссылке?
- При передаче по значению функция получает копию значения аргумента. Любые изменения параметра внутри функции не влияют на исходное значение переменной в вызывающем объекте.
  - Этот метод подходит, когда функция не должна изменять аргумент, но может быть неэффективным для больших объектов, так как предполагает копирование значения.
- При передаче по ссылке функция получает ссылку на аргумент. Это позволяет функции изменять значение исходного аргумента.
  - Передача по ссылке более эффективна, так как не происходит копирования данных, а функция работает напрямую с объектом. Однако если параметр не должен модифицироваться внутри функции, его можно объявить как ссылку на константу.

Передача по значению	
- Создаётся копия.	
- Изменения не сохраняются.	
- Медленнее для больших объектов.	

Передача по ссылке
- Работает с оригиналом.
- Изменения сохраняются.
- Быстрее (нет копирования).

---

## 10. Как указать значения по умолчанию для аргументов функции?
Значения по умолчанию задаются в объявлении функции.

```c++
void greet(std::string name = "User") {
    std::cout << "Hello, " << name << "!";
}
greet();       // "Hello, User!"
greet("Alice"); // "Hello, Alice!"
```

- Параметры по умолчанию должны идти после обычных параметров.
- Лучше указывать их в объявлении (например, в .hpp), а не в определении.

---

## 11. Когда рекомендуется использовать константную ссылку в качестве параметра?
- Если функция не должна изменять значение аргумента. 
- Когда нужно передать в функцию большие объекты, которые не должны меняться.

Преимущества
- Гарантия, что аргумент доступен только для чтения. Константная ссылка не позволяет изменять переменную, на которую она ссылается.
- Избегание копирования аргумента. При передаче по значению аргументы копируются в параметры функции, что может быть затратным, если данные большие. Константная ссылка создаёт ссылку на фактический аргумент, копирование не происходит. 
- Универсальность. Константная ссылка позволяет передавать как неконстантные, так и константные аргументы, а также литералы или результаты выражений.

```c++
void print(const std::vector<int>& vec) {
    for (int x : vec) std::cout << x << " ";
}
```

---

## 12. Может ли функция возвращать несколько значений? Если да, как это реализуется?
Для возврата нескольких значений из функции в C++ можно использовать следующие подходы:
- Возвращать сложный тип. Например, структуру или класс, который инкапсулирует несколько переменных.
- Использовать стандартные контейнеры. В C++11 и более поздних версиях доступны `std::tuple` и `std::pair`, которые позволяют связать несколько значений в один возвращаемый объект.
- Передавать значения через параметры. Если объявить параметры ссылочного типа, то возврат будет осуществляться через них. 

Пример с `std::tuple`:
```c++
std::tuple<int, double> getData() {
    return {42, 3.14};
}
auto [num, pi] = getData();  // C++17 (structured binding)
```

---

## 13. Какой тип параметра следует использовать для простых типов (например, int): по значению или по ссылке?
- Для простых типов (int, char, float и т. д.) лучше передавать по значению, так как копирование дешёвое.
- Это связано с тем, что при передаче по значению функция получает копию значения переменных и констант, а при передаче по ссылке функция использует сам объект, а не его значение, и не происходит копирования.

---

## 14. Какой тип параметра следует использовать, если функция не изменяет объект, но он тяжёлый (например, std::vector)?
`const &` (константная ссылка) – чтобы избежать копирования, но запретить изменение.

```c++
void print(const std::vector<int>& vec) {
    for (int x : vec) std::cout << x << " ";
}
```

---

## 15. Что такое "выходной аргумент" и как он используется?
Это параметр, который функция изменяет для возврата результата (обычно передаётся по ссылке).

```c++
void divide(int a, int b, int& quotient, int& remainder) {
    quotient = a / b;
    remainder = a % b;
}
int q, r;
divide(10, 3, q, r);  // q = 3, r = 1
```

---

## 16. В каких случаях передача по ссылке предпочтительнее?
- Если нужно изменить значение аргумента. Передача по ссылке позволяет функции работать с самим объектом, а не с его копией. 
- При передаче больших объектов. Передача по ссылке не создаёт копию данных, что повышает производительность.
- В конструкторе копирования или перемещения. По определению, такой конструктор должен принимать ссылку, поэтому передача по ссылке предпочтительна.
- При работе с полиморфным классом. Передача по ссылке позволяет избежать «нарезки» (копирования данных) при работе с разными подтипами класса.

Примеры использования:
- Функция, которая меняет местами значения двух переменных. Передача по ссылке позволяет менять значения аргументов напрямую, без создания копии.
- Функция, которая принимает ссылку на объект. Через эту ссылку можно манипулировать самим объектом, а не его значением.

---

## 17. Лямбда функции.
- Анонимная функция, которая может быть определена прямо в месте использования
- Позволяет передавать функцию как аргумент
- Может захватывать переменные из окружающего контекста

```c++
auto print = [](int num) {
    std::cout << num << std::endl;
};

print(1);
print(42);
```
```c++
int x = 42;
auto fn = [x] {
    // x захватывается по значению
    cout << " x = " << x << endl;
};
fn(); // 42
x = 55;
fn(); // 42
```

## Что у лямбда-функции под капотом?
- Компилятор создаёт внутри функции класс с перегруженным оператором вызова функции
- Захваченные переменные хранятся в виде полей класса

```c++
int main()
{
  int x = 42;

  auto fn = [=] {
    // x захватывается по значению
    std::cout << " x = " << x << std::endl;
  };

  fn();
  x = 55;
  fn();
}
```

```c++
int main() {
  int x = 42;
    
  class __lambda_7_12 {
  public: 
    __lambda_7_12(int & _x)
    : x{_x}
    {}

    void operator()() const {
      std::cout << " x = “ << x << std::endl;
    }
    
  private: 
    int x;
  };
  
  __lambda_7_12 fn = __lambda_7_12{x};
  fn();
  x = 55;
  fn ();
}
```

### Захват переменной по ссылке
```c++
int x = 42;
auto fn = [&x] {
    // x захватывается по ссылке
    cout << " x = " << x << endl;
};
fn(); // 42
x = 55;
fn(); // 55
```

### Изменение захваченного значения
```c++
int x = 42;
auto fn = [x]() mutable {
    // x захватывается по значению (которое можно менять внутри лямбды)
    x += 5;
    cout << " x = " << x << endl;
};
fn(); // 47
x = 55; // внутри лямбды значение не изменится
fn(); // 52
```

### Не вызывайте лямбда-функцию, если захваченная по ссылке переменная разрушена
```c++
function<void()> fn;

{
    string msg = "A long string that should not be optimized";
    auto lambda = [&] {
        msg += msg + "\n!";
        cout << " msg = " << msg << endl;
    };
    fn = lambda;
    fn(); // еще нормально
    msg += "\n:)\n";
    lambda();
}
// если раскомментировать следующую строчку, то будет неопр. поведение
// fn();
```

## Обрабатываем результаты в лямбда-функции
```c++
int main() {
    return FindStringInStream(std::cin, "needle",
        [](int lineIndex, const std::string& line, size_t foundPos) {
            std::cout << lineIndex << std::endl;
        });
}
```

### Обрабатываем результаты в лямбда-функции, захватывающей переменные
```c++
int main() {
    std::vector<int> lines;

    FindStringInStream(std::cin, "needle",
        [&lines](int lineIndex, const std::string& line, size_t foundPos) {
            lines.push_back(lineIndex);
        });

    // Можно использовать lines
}
```

---

## 18. Захват параметров лямбда функции по значению и по ссылке. Чем отличаются?
- `[=]` – захват по значению (копия).
- `[&]` – захват по ссылке (оригинал).

```c++
int x = 10;
auto byVal = [=]() { return x + 1; };  // x скопирован
auto byRef = [&]() { x++; };           // изменяет оригинал
```

---

## 19. Можно ли изменить значение переменной, захваченной в лямбде по значению?
Да, если указать mutable (но это изменит копию, не оригинал).

```c++
int x = 5;
auto lambda = [x]() mutable { x++; };
lambda();  // x останется 5, но внутри лямбды будет 6
```

```c++
int x = 42;
auto fn = [x]() mutable {
    // x захватывается по значению (которое можно менять внутри лямбды)
    x += 5;
    cout << " x = " << x << endl;
};
fn(); // 47
x = 55; // внутри лямбды значение не изменится
fn(); // 52
```

---

## 20. Какой код компилятор сгенерирует на основе лямбда-функции с пустым списком захвата? А если список параметров будет непустым?
- Если нет захвата ([]), лямбда превращается в обычную функцию.
- Если есть захват ([x] или [&x]), создаётся функтор (объект с перегруженным operator()).

```c++
auto lambda = [](int x) { return x * 2; };
// Превращается во что-то вроде:
struct __lambda_1 {
    int operator()(int x) const { return x * 2; }
};
```