# Статическое, автоматическое и динамическое размещение объектов в памяти

## Способы выделения памяти под объекты
- Статическое: память под объекты выделяется в момент компиляции программы
  - Объекты создаются при запуске программы, разрушаются при её завершении
- Автоматическое: память под объект выделяется при входе в блок, где объявлена переменная, и удаляется при выходе из блока
  - Обычно используется стек и регистры
  - Подходит для хранения относительно небольших объектов фиксированного размера
- Динамическое: программа выделяет память в области памяти, называемой кучей. Закончив работу с памятью, программа вызывает функцию освобождения памяти
  - Подходит для хранения данных динамического размера
  - Работа с кучей имеет накладные расходы на выделение и освобождение


## 1. Как разместить объект в статической области памяти? Когда удаляется объект в статической области памяти?
Статическая память (Static Storage) в C++ — это область памяти, которая выделяется на этапе компиляции программы и существует до завершения её работы.
- В этой памяти хранятся переменные, объявленные с ключевым словом `static`.

Как разместить объект в статической памяти?
- Объект размещается в статической памяти, если он:
  - Объявлен глобально (вне функций и классов).
  - Объявлен с ключевым словом static (внутри функции или класса).
  - Является статическим членом класса.

```c++
// Глобальная переменная (статическая память)
int globalVar = 10;

void foo() {
    // Локальная static-переменная (также в статической памяти)
    static int localStatic = 20;
}

class MyClass {
public:
    // Статическое поле класса
    static int classStatic;
};
int MyClass::classStatic = 30;  // Определение
```

Когда удаляется объект в статической памяти?
- Глобальные переменные – уничтожаются при завершении программы (после main()).
- Локальные static-переменные – уничтожаются при завершении программы, но их видимость ограничена областью объявления.
- Статические члены класса – уничтожаются при завершении программы.

Особенности:
- Инициализируются один раз (при первом использовании для static внутри функции).
- Потокобезопасность в C++11+: инициализация static-переменных внутри функций гарантированно thread-safe.

---

## 2. Как разместить объект в автоматической области памяти? Когда удаляется объект в автоматической области памяти?
Автоматическая память в C++ (также известна как стек) — это специальный регион памяти, который резервируется при запуске программы из свободной оперативной памяти и используется для размещения локальных объектов.

Ключевое слово `auto` указывает на то, что переменная принадлежит автоматическому классу памяти.

Как разместить объект в автоматической памяти?
- Объект размещается в стеке, если он:
  - Объявлен локально внутри функции или блока {}.
  - Не является static, thread_local и не выделен через new.

```c++
void foo() {
    int x = 10;          // Автоматическая память
    std::string s = "Hi"; // Также в стеке
    if (true) {
        int y = 20;      // Вложенный блок – тоже автоматическая память
    }
}
```

Когда удаляется объект в автоматической памяти?
- При выходе из области видимости (блока {} или функции).
- Деструкторы вызываются автоматически.

Особенности:
- Быстрое выделение/освобождение (просто двигается указатель стека).
- Ограниченный размер стека (обычно 1-8 МБ, зависит от ОС и компилятора).
- Stack Overflow – если рекурсия слишком глубокая или большой объект.

---

## 3. Как разместить объект в динамической области памяти? Когда удаляется объект в динамической области памяти?
Динамическая память (Dynamic Storage / Heap) в C++ — это область памяти, которая выделяется и освобождается вручную во время выполнения программы. Используется для объектов, время жизни которых должно контролироваться программистом.

Программа запрашивает память у операционной системы из специально отведённой области — кучи (heap). Если система может выделить участок, адрес памяти возвращается в программу. После использования память нужно вернуть обратно в операционную систему для распределения между другими запросами.

Как разместить объект в динамической памяти?
- Объект размещается в куче с помощью оператора `new`.
```c++
int* pInt = new int(42);          // Динамический int
std::string* pStr = new std::string("Hello"); // Динамическая строка
int* arr = new int[100];          // Динамический массив
```

Когда удаляется объект в динамической памяти?
- Только при явном вызове delete (для одиночных объектов) или delete[] (для массивов).
- Если не удалить – утечка памяти (memory leak).

```c++
delete pInt;     // Освобождает int
delete pStr;     // Освобождает string
delete[] arr;    // Освобождает массив
```

Особенности:
- Размер кучи ограничен объёмом ОЗУ.
- Медленнее, чем стек (требуется поиск свободного блока).
- Необходимо ручное управление памятью.

---

## 4. Операторы new и delete. Для чего применяются?
`new` - Оператор new выделяет место в динамической памяти для объекта и возвращает указатель на него. Если объект является массивом, возвращается указатель на начальный элемент массива.
- Выделяет память в куче.
- Вызывает конструктор объекта (если это не POD-тип).
- Возвращает указатель на созданный объект.

`delete` - Оператор delete получает указатель на динамический объект и удаляет его из памяти. Перед освобождением памяти вызывается деструктор объекта (если он есть).
- Вызывает деструктор объекта.
- Освобождает память.

Важно:
- Для массивов обязательно использовать delete[].
- Двойное удаление (delete дважды) – UB (неопределённое поведение).
---

## 5. Какие ошибки могут возникнуть при работе с объектами в динамической области памяти?
1. Утечка памяти (Memory Leak)
```c++
int* p = new int(10);
// Забыли delete p;
```
Последствия: Программа съедает всё больше памяти.

2. Висячий указатель (Dangling Pointer)
```c++
int* p = new int(10);
delete p;
*p = 20; // UB: обращение к освобождённой памяти
```
Решение: После delete обнулять указатель (p = nullptr;).

3. Двойное удаление (Double Free)
```c++
int* p = new int(10);
delete p;
delete p; // UB: повторное удаление
```

4. Несоответствие new и delete
```c++
int* arr = new int[10];
delete arr;     // Ошибка: нужно delete[] arr;
```

Последствия: UB (может не вызвать деструкторы для всех элементов).

5. Нехватка памяти (Out of Memory)
```c++
try {
    int* p = new int[1000000000000]; // std::bad_alloc
} catch (const std::bad_alloc& e) {
    std::cerr << "Memory allocation failed!";
}
```
Решение: Использовать new(std::nothrow) или ловить исключения.

6. Фрагментация кучи
- Многократные new/delete могут привести к фрагментации, когда свободной памяти много, но нет непрерывного блока.






