# Перечислимый тип данных

## 1. Что такое перечислимый тип данных в языке C++ и для чего он используется?

Задает набор именованных целочисленных констант (значений)
- День недели или название месяца
- Состояние конечного автомата
- Модель компьютера


- Основные цели использования:
  - Улучшение читаемости кода (вместо магических чисел используются осмысленные имена).
  - Ограничение допустимых значений (переменная может принимать только предопределённые варианты).
  - Безопасность типов (особенно с enum class, который предотвращает неявные преобразования).

Пример:
```c++
enum Color { Red, Green, Blue }; // Red = 0, Green = 1, Blue = 2
Color c = Red; // OK
// c = 5; // Ошибка (если не приводить явно)
```

---

## 2. Как объявляется перечислимый тип данных в языке C++?
```c++
enum ИмяТипа { Значение1, Значение2, ... };
```

Enum:
```c++
enum TrafficLight
{
    Red,
    Green,
    Blue,
};

TrafficLight tl = Blue;
std::cout << tl << std::endl; // Выведет 2
```

ScopedEnum:
```c++
enum class TraficLightColor
{
    Yellow, Red, Green
};

enum class CarColor { Red, Black, White };
```

---

## 3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?



---

## 4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?



---

## 5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?



---

## 6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
Проблема enum
```c++
enum TrafficLight
{
    Red, Green, Blue,
};

// Не скомпилируется т.к. значение Red уже используется TrafficColor
enum CarColor
{
    Red, Green, Blue,
};
```

### Scoped enum (появились в С++11)

- Ограничивают область видимости значений перечислимого типа именем перечисления
- Позволяют преодолеть ограничение традиционного enum на уникальность значений
- Не имеют неявного преобразования к целым числам


```c++
enum class TraficLightColor
{
    Yellow, Red, Green
};

enum class CarColor { Red, Black, White };
```

### Scoped enum (перечисление с областью видимости) — это улучшенная версия enum, введённая в C++11.

- Отличия от обычного enum:
  - Значения не "протекают" в окружающую область видимости (требуется EnumName::Value).
  - Нет неявного преобразования к целым числам (требуется static_cast).
  - Можно указать базовый тип (enum class : short { ... }).

---

## 7. Как объявляется scoped enum в языке C++?
Синтаксис:
```c++
enum class ИмяТипа [: базовый_тип] { Значение1, Значение2, ... };
```

Примеры:
```c++
enum class Status { Ok, Error, Pending }; // Базовый тип — int  
enum class Code : uint8_t { Success = 0, Fail = 1 }; // Базовый тип — uint8_t  
```

```c++
enum class TraficLightColor
{
    Yellow, Red, Green
};

enum class CarColor { Red, Black, White };
```


---

## 8. Как можно обратиться к элементу scoped enum в языке C++?
Через оператор области видимости `::`:
```c++
enum class Direction { Up, Down, Left, Right };
Direction dir = Direction::Up;
```

Нельзя использовать без квалификатора:
```c++
Direction d = Up; // Ошибка! Только Direction::Up  
```

---

## 9. Что такое underlying type у scoped enum в языке C++ и как он используется?
`Underlying type` — это базовый целочисленный тип, используемый для хранения значений перечисления.

Как используется?
- По умолчанию — `int`.
- Можно изменить для экономии памяти:
```c++
enum class Small : char { A, B, C }; // Базовый тип — char (1 байт)  
```
- Можно узнать через `std::underlying_type_t`:
```c++
using T = std::underlying_type_t<Small>; // T = char  
```

---

## 10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?
1. Избегание конфликтов имён
2. Отсутствует неявное преобразование в int
3. Явный базовый тип: `enum class : char`
4. Полноценная поддержка шаблонов

```c++
enum class FileMode { Read, Write };
FileMode m = FileMode::Read;
int x = m; // Ошибка (нужен static_cast<int>(m))
```