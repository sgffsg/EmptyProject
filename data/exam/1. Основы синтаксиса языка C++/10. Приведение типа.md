# Приведение типа


### Оператор static_cast


### Оператор const_cast



### Оператор reinterpret_cast


### Оператор dynamic_cast



# Управление выполнением программы

## Инструкции и блоки
- Выражение (например, x = 0) становится инструкцией, если в конце поставить точку с запятой
1. `x = a + b;`
2. `std::cout << "Hello";`
3. `DrawCat(cat);`
- Фигурные скобки { и } используются для объединения объявлений и инструкций в составную инструкцию, или блок <br>
  с т.з. синтаксиса языка блок воспринимается как одна инструкция



## 1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
Приведение типа (typecasting) — это процесс преобразования значения одного типа данных в другой. Оно используется, когда нужно:
- `Совместимость типов`: Например, передача int в функцию, ожидающую double.
- `Контроль над поведением программы`: Явное указание, как интерпретировать данные.
- `Работа с наследованием`: Преобразование между указателями на базовые и производные классы.
- `Обработка сырых данных`: Например, интерпретация void* как конкретного типа.

---

## 2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
В языке C++ введены 4 оператора приведения типов
1. `static_cast<Type>(arg)`
2. `dynamic_cast<Type>(arg)`
3. `const_cast<Type>(arg)`
4. `reinterpret_cast<Type>(arg)`

- Каждый из них предназначен для конкретной задачи <br>
  Сложнее ошибиться
- Их легче найти в коде
- В программах на C++ следует использовать эти операторы

```c++
double d = 3.14;
int i = static_cast<int>(d);  // Явное преобразование double → int
```

---

## 3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
Неявное приведение выполняется компилятором автоматически, без указания программиста. Оно происходит в случаях:

Арифметических преобразований:
```c++
int i = 5;
double d = i;  // int → double
```

Присваивания:
```c++
long l = 10;  // int → long
```

Передачи аргументов в функцию:
```c++
void func(double x);
func(42);  // int → double
```

Логических выражений:
```c++
if (5.7)  // double → bool (true)
```

---

## 4. Приведите пример неявного приведение типа в языке C++?
```c++
float f = 10;  // int → float (неявное)
char c = 1000; // int → char (с потерей данных, если char 8-битный)
bool b = nullptr; // nullptr_t → bool (false)
```

---

## 5. Приведение типа в стиле языка C.
Используется синтаксис (тип)выражение:
```c++
double d = 3.14;
int i = (int)d;  // C-style cast
```

---

## 6. Почему использование явного преобразования в стиле C может быть опасным?
- `Нет проверок безопасности:` Может выполнять reinterpret_cast без предупреждений.
- `Неочевидное поведение:` В C++ он пытается применить разные варианты (static_cast, const_cast, reinterpret_cast), что усложняет отладку.
- `Проблемы с const-корректностью:` Может случайно снять const.

Пример опасного преобразования:
```c++
const int x = 10;
int* p = (int*)&x;  // Убирает const без явного указания
*p = 20;  // Неопределённое поведение!
```

---

## 7. Для чего предназначен static_cast и какие типы преобразований он поддерживает?

- Выполняет статическое преобразование одного типа к другому на этапе компиляции:
  - Например, double в int
  - Указатель void* в указатель на конкретный тип
- Также выполняет статическое преобразование указателей и ссылок в пределах иерархии классов <br>
  Например, если Cat унаследован от Animal, то можно выполнять преобразования: <br>
1. Cat* в Animal*
2. Animal* в Cat*

```c++
void Test(double doubleValue)
{
	// Ошибка компиляции
	int intValue = static_cast<int>(&doubleValue);
}

struct Point
{
	double x;
	double y;
};

void Test1(const Point * p)
{
	int x = static_cast<int>(p->x);	// ok
	int y = static_cast<int>(p);		// ошибка компиляции
}
```

```c++
int i = 10;
double d = static_cast<double>(i);

Base* b = new Derived();
Derived* d = static_cast<Derived*>(b);  // Опасность, если b не Derived!
```

---

## 8. Какой тип будет у результата выражения 1U - 1L при разных размерах типов?
Правила арифметических преобразований:
- 1U — unsigned int.
- 1L — long.
- Если sizeof(long) > sizeof(unsigned int), то 1U преобразуется в long.
- Результат: long.

```c++
auto result = 1U - 1L;  // Тип: long
```

---

## 9. Для чего используется const_cast и какие риски связаны с его применением?
- Снимает константность с ссылки или указателя
- Если оригинальный объект был константным, попытка снять с него константность и изменить значение вызовет неопределённое поведение

```c++
// Оригинальный объект не является константным
double PI = 3.14159265;

const double& CONST_PI = PI;
// Изменить константную ссылку CONST_PI нельзя:
// CONST_PI = 4;

// Но можно снять константность со ссылки и модифицировать объект.
const_cast<double&>(CONST_PI) = 4;

std::cout << "Now pi is " << PI << std::endl;
```

### Снятие константности с константного объекта вызывает UB
```c++
// PI - константный объект.
const double PI = 3.1415927;

int main()
{
    // Здесь мы обманываем компилятор,
    // снимая константность к константной переменной.
    double& nonConstPI = const_cast<double&>(PI);

    // Попытка изменить константный объект, сняв константность со ссылки на него,
    // приводит к неопределённому поведению
    nonConstPI = 4;

    std::cout << "PI:" << PI << ", nonConstPI: " << nonConstPI << std::endl;
}
```

- Изменение const-объекта ведёт к неопределённому поведению.
- Потенциальное нарушение инвариантов программы.

---

## 10. В каких сценариях используется reinterpret_cast?
- Может применяться для преобразования между целочисленными типами и указателями, а также между указателями на несвязанные друг с другом типы данных
- Пригодится при прямой работе с памятью

reinterpret_cast выполняет опасные низкоуровневые преобразования:
- Указатель → указатель другого типа.
- Указатель → целое число (и наоборот).
- Интерпретация битового представления.

```c++
int* p = new int(42);
uintptr_t addr = reinterpret_cast<uintptr_t>(p);  // Указатель → число
```

```c++
#include <iostream>
#include <cstdint>
#include <string>

void ChangeString(std::uintptr_t p)
{
    std::string* pstr = reinterpret_cast<std::string*>(p);
    *pstr = "Goodbye";
}

int main()
{
    std::string name = "Hello";
    // Так нельзя, так как uintptr_t и std::string* - разные типы
    // ChangeString(&name);
    
    // Так можно
    ChangeString(reinterpret_cast<uintptr_t>(&name));

    std::cout << name << std::endl; // Выведет Goodbye
}
```

---

## 11. Почему reinterpret_cast считается менее безопасным по сравнению с другими операторами?
- Нет проверок: Компилятор слепо доверяет программисту.
- Зависит от платформы: Поведение может различаться.
- Ломает strict aliasing: Доступ к объекту через несовместимый тип — UB.

---

## 12. Приведите пример корректного использования reinterpret_cast для работы с памятью.
```c++
// Сериализация данных
struct Data { int x; float y; };
char buffer[sizeof(Data)];
Data* data = reinterpret_cast<Data*>(buffer);  // Интерпретация памяти
```

---

## 13. Какой оператор преобразования можно использовать для преобразования указателя void* в указатель на конкретный тип?
Используется static_cast:
```c++
void* ptr = malloc(sizeof(int));
int* iptr = static_cast<int*>(ptr);
```

---

## 14. Какие гарантии безопасности исключений предоставляют операторы static_cast, const_cast и reinterpret_cast?
- `static_cast` и `const_cast` не выбрасывают исключений.
- `reinterpret_cast` тоже не генерирует исключений, но может привести к UB.
- `dynamic_cast` (не упомянут в вопросе) может выбросить std::bad_cast при неудаче (если используется с ссылками).

---

## 15. Какие типы преобразований поддерживает dynamic_cast и в каких сценариях он используется?
- Применяется для динамического преобразования типов в пределах иерархии классов

dynamic_cast работает с полиморфными типами (есть виртуальные функции):
- Преобразование вниз по иерархии (проверяет корректность в runtime).
- Кросс-касты (между несвязанными ветвями иерархии).

```c++
class Base { virtual void foo() {} };
class Derived : public Base {};

Base* b = new Derived;
Derived* d = dynamic_cast<Derived*>(b);  // OK, если b действительно Derived
```

Возвращает:
- `nullptr` для указателей при неудаче.
- Бросает `std::bad_cast` для ссылок.