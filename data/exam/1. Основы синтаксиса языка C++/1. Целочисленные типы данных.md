# Целочисленные типы данных

## 1. Каковы основные типы целых чисел в C++?

В C++ существует несколько типов целых чисел, которые различаются по размеру, диапазону значений и наличию знака. Они делятся на **знаковые** (`signed`) и **беззнаковые** (`unsigned`).

### Целые числа различного размера:
- char
- short, short int
- int
- long, long int

### Целые числа со знаком и без знака:
- signed
- unsigned

### Гарантируется следующее соотношение размеров целочисленных типов:
- sizeof(char) <= sizeof(short)
- sizeof(short) <= sizeof(int)
- sizeof(int) <= sizeof(long)

### Типы int и short - знаковые
- int == signed int
- short == signed short

### Тип char обычно тоже знаковый:
- Поведение может меняться в зависимости от компилятора
- `signed char, unsigned char`

### Прочие целые числа:
- `size_t` - Беззнаковый тип, способный храмить размер объекта в памяти или количество типов.
  Используем этот тип т.к. на различных платформах используются разные разрядности. на 64bit платформе будет 64 разрядный, на 32bit - 32 разрядный.
- `int8_t, int16_t, int32_t, int64_t` - Числа с фиксированной разрядностью
- `uint8_t, uint16_t, uint32_t, uint64_t` - Числа без знака фксированной разрядности
- `int_fast8_t, int_fast16_t, int_fast32_t, int_fast64_t` - Самый быстрый знаковый целочисленный тип не меньшей разрядности.
  Если надо работать с числами не меньше 16битной разрядности максимально быстро. Он использует инструкции процессора, позволяющие
  максимально быстро работать с этими данными.
- `uint_fast8_t, uint_fast16_t, uint_fast32_t, uint_fast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.
- `intmax_t, uintmax_t` - Целое число, имеющее максимальную разрядность, с которой процессор может эффективно работать.
- `intptr_t, uintptr_t` -
  Указатели используются при работе с объектами в памяти. Они хранят указатели. Разница
- `intleast8_t, intleast16_t, intleast32_t, intleast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.
---


## 2. Как объявить переменную целого типа в C++?
```c++
int main()
{
    // Объявление переменной
    double carSpeed;
    carSpeed = 45.8;
    
    // Объявление переменной можно совместить с её инициализацией
    int userAge = 20;
    float x = 12.6f;
    
    // Константа при объявлении всегда должна быть проинициализирована
    const double SPEED_OF_LIGHT = 299792458.0;
    const int SECONDS_IN_HOUR = 3600;
    const int HOURS_IN_DAY = 3600;
    
    // Гарантировано вычисляется вовремя компиляции
    constexpr int CONSTED = 300;
    
    // Инициализация константы в результате выражения
    const int SECONDS_IN_DAT = SECONDS_IN_HOUR * HOURS_IN_DAY;
}
```

1. Если прочитать неинициализированную переменную, то будет неопределенное поведение
2. `const` можно писать и слева и справа от переменной
3. Попытка изменить значение константы после объявления выдаст ошибку компиляции
4. Функция д.б. ~15-20 строк

```c++
int main()
{
    // double
    auto PI = 3.14159265;
    
    // const float
    const auto E = 2.71828f;
    
    // float (float * int)
    auto e2 = E * 2;
    
    // const double (double / int)
    const auto halfPI = PI / 2;
    
    // long double (функция sqrt возвращает значение long double)
    auto sqrtPI = sqrt(PI);
}
```

### Область видимости переменной
```c++
int main()
{
    // Область видимости переменной ограничена блоком, внутри которого она объявлена
    std::string username = "Ivan Petrov";
    int age = 10;
    
    {
        // Переменная из внутреннего блока может иметь имя, совпадающее с именем из внешнего блока
        // При этом внутри этого блока она замещает собой одноименную переменную из внешего блока
        std::string username = "Sergey Ivanov";
        assert(username == "Sergey Ivanov");
        
        // Тип переменной age может отличаться от типа одноименной переменной из внешнего блока
        double age = 7.7; 
    }
    
    // При возврате во внешний блок видимой снова становится внешняя переменная
    assert(username == "Ivan Petrov");
}
```

### Объявление глобальных переменных
```c++
// Глобальные переменные по умолчанию инициализируются нулями
int globalVar;
int anotherGlobalVar = 42; // Можно проинициализировать заранее заданным значением

std::cout << globalVar << std::endl; // 0
globalVar = 13;
std::cout << globalVar << std::endl; // 13
std::cout << anotherGlobalVar << std::endl; // 42
```


## 3. Каковы диапазоны значений для различных типов целых чисел в C++?

### **1.1. `int` (знаковый целочисленный тип)**
- **Размер:** Зависит от архитектуры (обычно 4 байта в 32/64-битных системах).
- **Диапазон:**
  - `-2 147 483 648` до `2 147 483 647` (если `sizeof(int) == 4`).
- **Особенности:**
  - Наиболее часто используемый тип для целых чисел.
  - По умолчанию считается `signed`.


### **1.2. `unsigned int` (беззнаковый целочисленный тип)**
- **Размер:** Аналогичен `int` (обычно 4 байта).
- **Диапазон:**
    - `0` до `4 294 967 295` (если `sizeof(unsigned int) == 4`).
- **Особенности:**
    - Не может хранить отрицательные числа.
    - Полезен для работы с битами, индексами массивов и значениями, которые не могут быть отрицательными.

### **1.3. `short` (`short int`) (знаковый короткий целый тип)**
- **Размер:** Обычно 2 байта.
- **Диапазон:**
    - `-32 768` до `32 767`.
- **Особенности:**
    - Используется для экономии памяти, если не требуется большой диапазон.

### **1.4. `unsigned short` (`unsigned short int`)**
- **Размер:** Обычно 2 байта.
- **Диапазон:**
    - `0` до `65 535`.
- **Особенности:**
    - Аналог `short`, но без знака.

### **1.5. `long` (`long int`) (знаковый длинный целый тип)**
- **Размер:** Зависит от системы (4 или 8 байт).
    - В Windows (32/64-bit) и Linux x86_64: 4 байта (как `int`).
    - В некоторых системах (например, 64-bit Unix-like): 8 байт.
- **Диапазон:**
    - Если 4 байта: `-2 147 483 648` до `2 147 483 647`.
    - Если 8 байт: `-9 223 372 036 854 775 808` до `9 223 372 036 854 775 807`.
- **Особенности:**
    - В C++11 и новее рекомендуется использовать `long long` для гарантированного 8-байтного типа.

### **1.6. `unsigned long` (`unsigned long int`)**
- **Размер:** Аналогичен `long`.
- **Диапазон:**
    - Если 4 байта: `0` до `4 294 967 295`.
    - Если 8 байт: `0` до `18 446 744 073 709 551 615`.

### **1.7. `long long` (`long long int`) (знаковый очень длинный целый тип, C++11)**
- **Размер:** Гарантированно 8 байт.
- **Диапазон:**
    - `-9 223 372 036 854 775 808` до `9 223 372 036 854 775 807`.
- **Особенности:**
    - Введён в C++11 для работы с 64-битными числами.

### **1.8. `unsigned long long` (`unsigned long long int`)**
- **Размер:** Гарантированно 8 байт.
- **Диапазон:**
    - `0` до `18 446 744 073 709 551 615`.

### **1.6. `char` (символьный тип, но может быть целым)**
- **Размер:** 1 байт.
- **Диапазон:**
  - `signed char`: от `-128` до `127`.
  - `unsigned char`: от `0` до `255`.
- **Особенности:**
  - Может использоваться для хранения ASCII-символов или маленьких чисел.
  - В C++ `char` может быть знаковым или беззнаковым (зависит от компилятора).

### **2. Дополнительные типы (C++11 и новее)**
#### **2.1. `int8_t`, `int16_t`, `int32_t`, `int64_t` (из `<cstdint>`)**
- **Фиксированный размер:**
    - `int8_t` — 1 байт (`-128` до `127`).
    - `int16_t` — 2 байта (`-32 768` до `32 767`).
    - `int32_t` — 4 байта (`-2 147 483 648` до `2 147 483 647`).
    - `int64_t` — 8 байт (`-9 223 372 036 854 775 808` до `9 223 372 036 854 775 807`).
- **Особенности:**
    - Гарантируют точный размер, но могут отсутствовать на некоторых платформах (например, `int8_t` не существует, если байт не 8-битный).

#### **2.2. `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t` (беззнаковые аналоги)**
- Аналогичны `intN_t`, но без знака (`0` до `2^N - 1`).

#### **2.3. `size_t` (беззнаковый тип для размеров)**
- **Размер:** Зависит от системы (обычно 4 или 8 байт).
- **Использование:**
    - Для хранения размеров массивов, индексов (например, в `std::vector::size()`).
    - Эквивалентен `unsigned long` или `unsigned long long`.

### **3. Особенности**
- **Переполнение:**
    - Для знаковых типов (`signed`) переполнение — **неопределённое поведение (UB)**.
    - Для беззнаковых (`unsigned`) — арифметика по модулю (например, `255 + 1 == 0` для `uint8_t`).
- **Зависимость от платформы:**
    - Точный размер `int`, `long` зависит от компилятора и ОС.
    - Для переносимости лучше использовать `<cstdint>`.
- **Литералы:**
    - `42` — `int`.
    - `42U` — `unsigned int`.
    - `42L` — `long`.
    - `42LL` — `long long`.

В C++ существует несколько основных типов целых чисел, которые различаются по размеру, диапазону значений и наличию знака.

---

### **4. Примеры**
```c++
#include <iostream>
#include <climits>

int main() {
    std::cout << "int: " << sizeof(int) << " bytes (" << INT_MIN << " to " << INT_MAX << ")\n";
    std::cout << "unsigned int: 0 to " << UINT_MAX << "\n";
    std::cout << "long long: " << sizeof(long long) << " bytes (" << LLONG_MIN << " to " << LLONG_MAX << ")\n";
    return 0;
}
```

Вывод (зависит от системы):
```c++
int: 4 bytes (-2147483648 to 2147483647)
unsigned int: 0 to 4294967295
long long: 8 bytes (-9223372036854775808 to 9223372036854775807)
```
---


## 4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
- Арифметические: `+, -, *, /, %` (остаток от деления)
- Инкремент/декремент: `++x, x++, --x, x--`
- Битовые: `&, |, ^ (XOR), ~ (NOT), <<, >>`
- Сравнение: `==, !=, <, >, <=, >=`
- Присваивание: `=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=`

## 5. Чем отличаются signed и unsigned типы?
- signed хранит отрицательные, нуль и положительные числа.
- unsigned хранит только неотрицательные числа (включая нуль).

Пример:
```c++
signed int a = -10;  // допустимо
unsigned int b = 10; // допустимо
unsigned int c = -10; // неопределённое поведение
```
---


## 6. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
Неявные преобразования
- Компилятор автоматически преобразует один тип данных в другой в определённых ситуациях:
  - при выполнении арифметических операций с операндами разных типов (меньший тип преобразуется в больший);
  - при присваивании значения одного типа переменной другого типа;
  - при передаче аргумента функции, которая ожидает другой тип данных.

Некоторые особенности неявных преобразований в C++:
- Приоритет типов. Компилятор выбирает операнд с типом, который имеет меньший диапазон значений, и пытается преобразовать его в тип второго операнда с большим диапазоном.
- Преобразование типов, меньших, чем int (char, signed char, unsigned char, short и unsigned short), в int (если это возможно).

---

## 7. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры


### **1. Побитовое И (`&`)**
```c++
int a = 5;    // 0101 (в двоичной)
int b = 3;    // 0011 (в двоичной)
int c = a & b; // 0001 (результат 1)
```
- Операция `&` сравнивает каждый бит двух чисел и возвращает `1` только если оба бита равны `1`.
- Пошагово:
  - Бит 0: `1 & 1 = 1`
  - Бит 1: `0 & 1 = 0`
  - Бит 2: `1 & 0 = 0`
  - Бит 3: `0 & 0 = 0`
- Итог: `0001` (десятичное `1`).

---

### **2. Побитовое ИЛИ (`|`)**
```c++
int d = a | b; // 0111 (результат 7)
```
- Операция `|` возвращает `1` если хотя бы один из битов равен `1`.
- Пошагово:
  - Бит 0: `1 | 1 = 1`
  - Бит 1: `0 | 1 = 1`
  - Бит 2: `1 | 0 = 1`
  - Бит 3: `0 | 0 = 0`
- Итог: `0111` (десятичное `7`).

---

### **3. Побитовое исключающее ИЛИ (`^`)**
```c++
int e = a ^ b; // 0110 (результат 6)
```
- Операция `^` возвращает `1` если биты **различаются**.
- Пошагово:
  - Бит 0: `1 ^ 1 = 0`
  - Бит 1: `0 ^ 1 = 1`
  - Бит 2: `1 ^ 0 = 1`
  - Бит 3: `0 ^ 0 = 0`
- Итог: `0110` (десятичное `6`).

---

### **4. Побитовое НЕ (`~`)**
```c++
int f = ~a;    // 1010 (результат -6, зависит от представления)
```
- Операция `~` инвертирует все биты числа.
- Для `a = 5` (`0101` в 4-битном представлении):
  - После инверсии: `1010`.
- **Важно**: В реальности `int` обычно 32 бита, поэтому:
  - `5` = `0000...0101` (29 нулей перед `101`).
  - `~5` = `1111...1010` (битовая инверсия, что равно `-6` в дополнительном коде).
- Результат зависит от архитектуры, но обычно это `-6`.

---

### **5. Сдвиг влево (`<<`)**
```c++
int g = a << 1; // 1010 (результат 10)
```
- Операция `<<` сдвигает биты числа влево на указанное количество позиций, заполняя освободившиеся биты нулями.
- Для `a = 5` (`0101`):
  - Сдвиг влево на 1: `1010` (десятичное `10`).
- Эквивалентно умножению на `2^n` (в данном случае `5 * 2 = 10`).

---

### **6. Сдвиг вправо (`>>`)**
```c++
int h = a >> 1; // 0010 (результат 2)
```
- Операция `>>` сдвигает биты числа вправо на указанное количество позиций.
  - Для **беззнаковых** чисел (`unsigned`) освободившиеся биты заполняются нулями.
  - Для **знаковых** чисел (`signed`) поведение зависит от компилятора (обычно заполняется знаковым битом).
- Для `a = 5` (`0101`):
  - Сдвиг вправо на 1: `0010` (десятичное `2`).
- Эквивалентно целочисленному делению на `2^n` (в данном случае `5 / 2 = 2`).

---

### **Дополнительные замечания**
1. **Размер типа `int`**: В примере используются 4-битные числа для наглядности, но в реальности `int` обычно 32-битный.
2. **Отрицательные числа**: Результат `~` и `>>` зависит от представления отрицательных чисел (обычно это [дополнительный код](https://ru.wikipedia.org/wiki/Дополнительный_код)).
3. **Переполнение**: Сдвиг влево может привести к переполнению, если старшие биты теряются.

---

### **Примеры для 32-битных чисел**
Если `a = 5` (`0000...0101`):
- `~a` = `1111...1010` = `-6` (в дополнительном коде).
- `a << 2` = `0000...10100` = `20`.
- `a >> 2` = `0000...0001` = `1`.

---

## 8. Как проверить, является ли целое число четным или нечетным в C++?

Остаток от деления
```c++
int num = 10;
if (num % 2 == 0) {
  cout << "Чётное";
} 
else {
    cout << "Нечётное";
}
```


Побитовое И
```c++
if ((num & 1) == 0) { // младший бит 0?
cout << "Чётное";
}
```
---

## 9. Как вычислить остаток от деления двух целых чисел в C++?
```c++
int a = 10, b = 3;
int remainder = a % b; // остаток = 1
```
--- 

## 10. Чему равно частное и остаток при делении, когда один или оба аргумента — отрицательные?
- Правила в C++:
  - Знак остатка совпадает с делимым (a в a % b).
  - Частное округляется в сторону нуля.

```c++
-10 / 3  = -3, остаток -1
10 / -3  = -3, остаток 1
-10 / -3 = 3, остаток -1
```
---

## 11. Как проверить, является ли целое число положительным или отрицательным в C++?
```c++
int num = -5;
if (num > 0) {
    cout << "Положительное";
} 
else if (num < 0) {
    cout << "Отрицательное";
} 
else {
    cout << "Ноль";
}
```
---


## 12. Как использовать условные операторы и циклы для работы с целыми числами в C++?
```c++
// Условный оператор
if (x > 0) { ... }

// Цикл for
for (int i = 0; i < 10; ++i) { ... }

// Цикл while
while (x != 0) { ... }
```
---

## 13. Как проверить, что при умножении двух целых чисел не будет переполнения?
Перед умножением можно проверить:
```c++
int a = 1000000, b = 1000000;
if (b != 0 && a > INT_MAX / b) {
    cout << "Будет переполнение!";
}
```
---


## 14. Что означает литерал 12345UL?
```c++
12345 — число.
U — беззнаковый (unsigned).
L — длинный (long).
Таким образом, 12345UL — это unsigned long со значением 12345.
```
---

## 15. Запишите число 123 в двоичной форме в виде C++ литерала.
```c++
int x = 0b01111011; // C++14 и выше
// или
int x = 0x7B;       // шестнадцатеричный формат
```
---

## 16. Для чего используется символ ' внутри числового литерала?
Используется для удобочитаемости (C++14 и выше):
```c++
int million = 1'000'000;
int binary = 0b1001'1101;
```
---

## 17. Как записываются шестнадцатеричные литералы в C++?
Записываются с префиксом 0x:
```c++
int hex = 0xFF; // 255 в десятичной
```
---

## 18. Переведите 0321 в десятичную систему.
Это восьмеричный литерал (начинается с 0):
```c++
0321₈ = 3×8² + 2×8¹ + 1×8⁰
0321₈ = 3×64 + 2×8 + 1×1
0321₈ = 192 + 16 + 1 = 209₁₀
0321₈ = 209₁₀
```

Обратно:
```c++
209 ÷ 8 = 26, остаток 1
26 ÷ 8 = 3, остаток 2
3 ÷ 8 = 0, остаток 3
209₁₀ = 0321
```
---

## 19. Переведите 0b11101 в десятичную систему.
```c++
0b11101₂ = 1×2⁴ + 1×2³ + 1×2² + 0×2¹ + 1×2⁰
0b11101₂ = 1×16 + 1×8 + 1×4 + 0×2 + 1×1
0b11101₂ = 16 + 8 + 4 + 0 + 1 = 29₁₀
0b11101₂ = 29₁₀
```

Обратно:
```c++
29 ÷ 2 = 14, остаток 1  
14 ÷ 2 = 7,  остаток 0  
7 ÷ 2 = 3,   остаток 1  
3 ÷ 2 = 1,   остаток 1  
1 ÷ 2 = 0,   остаток 1  
29₁₀ = 0b11101₂
```

## 20. Переведите 8FF в десятичную систему.
- Шестнадцатеричная система (hex) использует 16 символов:
  - Цифры 0-9 (значения 0–9)
  - Буквы A-F (значения 10–15)


- Число 8FF состоит из:
  - 8 (8)
  - F (15)
  - F (15)

```c++
8FF₁₆ = 8×16² + F×16¹ + F×16⁰
8FF₁₆ = 8×256 + 15×16 + 15×1
8FF₁₆ = 2048 + 240 + 15 = 2303₁₀
8FF₁₆ = 2303₁₀
```

Обратно:
```c++
2303 ÷ 16 = 143, остаток 15 (F)  
143 ÷ 16 = 8,   остаток 15 (F)  
8 ÷ 16 = 0,     остаток 8 (8)  
2303₁₀ = 0x8FF₁₆
```

## Дополнительная инфа

В префиксной форме значение переменной увеличивается или уменьшается до выполнения других операций. Оператор инкремента или декремента ставится перед именем переменной.
```
int a = 5;
int b = ++a; // a увеличится до 6, b станет равным 6
```

В постфиксной форме значение переменной изменяется после выполнения других операций. Оператор инкремента или декремента ставится после имени переменной.

### **Способы перевода между системами счисления в C++**

В C++ можно выполнять преобразования между системами счисления несколькими способами:
1) **Стандартные функции и методы** (для ввода/вывода),
2) **Ручные алгоритмы** (для понимания математики перевода),
3) **Библиотеки** (`<bitset>`, `<sstream>` и др.).

---

#### **1. Перевод из десятичной системы в другие**

#### **1.1. Использование `std::cout` (вывод в нужном формате)**
```c++
#include <iostream>
#include <bitset>

int main() {
    int num = 42;

    // В восьмеричную (oct)
    std::cout << "Octal: " << std::oct << num << '\n';      // 52

    // В шестнадцатеричную (hex)
    std::cout << "Hexadecimal: " << std::hex << num << '\n'; // 2a

    // В двоичную (через bitset)
    std::cout << "Binary: " << std::bitset<8>(num) << '\n';  // 00101010

    // Возврат к десятичной (dec)
    std::cout << std::dec << num << '\n'; // 42
}
```
**Примечание:**
- `std::oct`, `std::hex`, `std::dec` меняют формат вывода до следующего изменения.
- `std::bitset<N>(num)` выводит двоичное представление с фиксированным числом бит (`N`).

#### **1.2. Ручной перевод (алгоритмы)**
#### **→ В двоичную (рекурсивный метод)**
```c++
void printBinary(int n) {
    if (n == 0) return;
    printBinary(n >> 1);
    std::cout << (n & 1);
}
```
**Пример:**  
`printBinary(42);` → `101010`

#### **→ В шестнадцатеричную (с использованием массива символов)**
```c++
std::string toHex(int num) {
    if (num == 0) return "0";
    const char hexDigits[] = "0123456789ABCDEF";
    std::string res;
    while (num > 0) {
        res = hexDigits[num % 16] + res;
        num /= 16;
    }
    return res;
}
```
**Пример:**  
`toHex(255);` → `"FF"`

---

#### **2. Перевод из других систем в десятичную**

#### **2.1. Использование `std::stoi` (string to int)**
```c++
#include <string>

int main() {
    std::string binaryStr = "101010";
    std::string hexStr = "2A";
    std::string octStr = "52";

    int decFromBin = std::stoi(binaryStr, nullptr, 2); // 42 (из двоичной)
    int decFromHex = std::stoi(hexStr, nullptr, 16);   // 42 (из hex)
    int decFromOct = std::stoi(octStr, nullptr, 8);    // 42 (из восьмеричной)
}
```
**Синтаксис:**  
`std::stoi(строка, nullptr, основание)`

#### **2.2. Ручной перевод (алгоритмы)**
#### **→ Из двоичной строки**
```c++
int binaryToDecimal(const std::string& binaryStr) {
    int res = 0;
    for (char c : binaryStr) {
        res = res * 2 + (c - '0');
    }
    return res;
}
```
**Пример:**  
`binaryToDecimal("101010")` → `42`

#### **→ Из шестнадцатеричной строки**
```c++
int hexToDecimal(const std::string& hexStr) {
    int res = 0;
    for (char c : hexStr) {
        res = res * 16;
        if (c >= '0' && c <= '9') res += c - '0';
        else if (c >= 'A' && c <= 'F') res += 10 + (c - 'A');
        else if (c >= 'a' && c <= 'f') res += 10 + (c - 'a');
    }
    return res;
}
```
**Пример:**  
`hexToDecimal("2A")` → `42`

---

#### **3. Перевод между произвольными системами**
#### **3.1. Через десятичную систему (универсальный способ)**
1. Перевести исходное число в десятичное (`std::stoi` или ручной метод).
2. Перевести десятичное число в целевую систему (`std::bitset`, `std::oct`, `std::hex` или ручной метод).

**Пример:**
```c++
std::string binaryStr = "101010";
int decimal = std::stoi(binaryStr, nullptr, 2); // 42
std::cout << std::hex << decimal; // 2a (шестнадцатеричное)
```

#### **3.2. Прямой перевод (например, двоичная ↔ шестнадцатеричная)**
Можно использовать битовые операции:
```c++
std::string binaryToHex(const std::string& binaryStr) {
    int decimal = std::stoi(binaryStr, nullptr, 2);
    std::stringstream ss;
    ss << std::hex << decimal;
    return ss.str();
}
```
**Пример:**  
`binaryToHex("101010")` → `"2a"`

---

### **4. Библиотеки для работы с системами счисления**
#### **`<bitset>` — работа с двоичными числами**
```c++
#include <bitset>
#include <iostream>

int main() {
    std::bitset<8> bits(42); // 00101010
    std::cout << bits.to_string() << '\n'; // "00101010"
    std::cout << bits.to_ulong() << '\n';  // 42 (в десятичной)
}
```

### **`<sstream>` — гибкий ввод/вывод**
```c++
#include <sstream>
#include <iostream>

int main() {
    std::stringstream ss;
    ss << std::hex << 42; // Записываем 42 в hex
    std::string hexStr;
    ss >> hexStr; // "2a"
}
```

---

### **Вывод**
| **Действие**               | **Стандартный способ**       | **Ручной способ**           |
|----------------------------|-----------------------------|-----------------------------|
| **10 → 2 (двоичная)**      | `std::bitset<8>(num)`       | Рекурсивный вывод битов     |
| **10 → 8 (восьмеричная)**  | `std::cout << std::oct`     | Деление на 8 с остатком     |
| **10 → 16 (hex)**          | `std::cout << std::hex`     | Деление на 16 с остатком    |
| **2 → 10**                 | `std::stoi(str, nullptr, 2)`| Суммирование степеней двойки|
| **8 → 10**                 | `std::stoi(str, nullptr, 8)`| Аналогично двоичному        |
| **16 → 10**                | `std::stoi(str, nullptr, 16)`| Суммирование степеней 16    |

**Совет:**
- Для **вывода** используйте `std::oct`, `std::hex`, `std::bitset`.
- Для **ввода** используйте `std::stoi` с указанием основания.
- Для **алгоритмических задач** полезно знать ручные методы перевода.

Если нужно что-то уточнить — спрашивайте! 🚀





























