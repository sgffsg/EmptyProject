# Массивы


## 1. Что такое массив в C++ и каковы его основные характеристики?
- Массивы позволяют объявить несколько (один и более) последовательных объектов, объединенных под одним именем, и осуществлять к ним индексированный доступ
- В качестве индексов используются целые числа, или типы, приводимые к целым
- Размер массива задается статически на этапе компиляции и не может быть изменен в ходе работы программы
- Индекс начального элемента массива равен нулю
- Есть возможность объявления многомерных массивов

`Массив` — это структура данных, содержащая фиксированное количество элементов одного типа, расположенных в памяти последовательно.

Основные характеристики:
- `Фиксированный размер` – размер массива задаётся при создании и не может быть изменён.
- `Однородность` – все элементы имеют один тип (int, double, char и т. д.).
- `Индексация` – доступ к элементам осуществляется по индексу (начинается с 0).
- `Непрерывность в памяти` – элементы хранятся в соседних ячейках памяти.
- `Статический или динамический` – может быть создан на стеке (статический) или в куче (динамический).

---

## 2. Как объявить массив в C++?
Синтаксис:
```c++
тип имя_массива[размер];
```

Примеры:
```c++
int numbers[5];          // Массив из 5 целых чисел (неинициализированных)
double values[10];       // Массив из 10 чисел с плавающей точкой
char letters[26];        // Массив из 26 символов
```

---

## 3. Что такое индекс массива? Каковы требования к типу индекса для массива?
Индекс массива – это целочисленное значение, указывающее на позицию элемента в массиве.

Требования к типу индекса:
- Должен быть целочисленным (int, size_t, unsigned int и т. д.).
- Индексация начинается с 0 (первый элемент – arr[0]).
- Отрицательные индексы недопустимы (приводят к неопределённому поведению).

---

## 4. Как получить доступ к элементу массива по индексу?
Доступ осуществляется через оператор индексирования `[]`:
```c++
int arr[3] = {10, 20, 30};
int x = arr[0];  // x = 10
arr[1] = 42;     // Теперь arr = {10, 42, 30}
```

Выход за границы массива (arr[5]) приводит к неопределённому поведению (UB).

---

## 5. Как инициализировать массив при его объявлении? Приведите пример.
Полная инициализация:
```c++
int arr1[3] = {1, 2, 3};
```

Частичная инициализация (остальные элементы = 0):
```c++
int arr2[5] = {1, 2};  // {1, 2, 0, 0, 0}
```

Автоматический размер:
```c++
int arr3[] = {1, 2, 3};  // Размер = 3
```

Uniform initialization (C++11):
```c++
int arr4[]{1, 2, 3};
```

---

## 6. Что происходит с элементами массива, не указанными при инициализации?
- Глобальные/статические массивы – заполняются нулями.
- Локальные массивы – содержат мусор (неинициализированные значения).

```c++
#include <cassert>
#include <string>
 
int g_globalArray[3];
int main()
{
  // Глобальные переменные-массивы по умолчанию инициализируются нуляем
  assert(g_globalArray[0] == 0 && g_globalArray[1] == 0 && g_globalArray[2] == 0);
 
  // Массив из 3-х элементов. Элементы не проинициализированы
  float floatNumbers[3];
  floatNumbers[0] = 1.0; floatNumbers[1] = 3.5; floatNumbers[2] = -4.5;
 
  // Массив при объявлении может быть проинициализирован
  [[maybe_unused]] double doubleNumbers[3] = { 3.8, 2.1, 3.53 };
 
  // Элементы массива, не указанные при инициализации, равны нулю
  double zeroFilledArray[3] = { 3.5, 7.2 };
  assert(zeroFilledArray[2] == 0.0);
 
  // Элементы проинициализированы нулями
  [[maybe_unused]] double zeroInitializedArray[3] = { };
 
  // Если не указать размер массива при инициализации, 
  // он будет определен автоматически
  [[maybe_unused]] double arrayOf5Items[] = { 3.5, 8.7, 2.3, -1.25, 0.0 };

  std::string name = "John", surname = "Doe";
  // При инициализации элементов массив могут также использоваться выражения
  std::string userNames[] = { "Ivan", "Sergey", name + " " + surname };
  // Так можно определить количество элементов в массиве
  assert(std::size(userNames) == 3);
  assert(userNames[2] == "John Doe");
}
```

---

## 7. Какой синтаксис используется для автоматического определения размера массива?
Если размер не указан, компилятор вычисляет его сам:
```c++
int arr[] = {1, 2, 3};  // Размер = 3
```

```c++
int arr[];  // Ошибка: размер не указан и не выводится
```

---

## 8. Как узнать размер массива?
Используется sizeof:
```c++
int arr[] = {1, 2, 3, 4, 5};
size_t size = sizeof(arr) / sizeof(arr[0]);  // size = 5
```

В C++17 можно использовать std::size:
```c++
#include <cassert>
#include <string>
  
void main() {
  std::string userNames[] = { "Ivan", "Sergey",  "Stepan" };
  assert(std::size(userNames) == 3);
 
  const char arr1[] = { 'J', 'o', 'h', 'n', '\0' };
  assert(std::size(arr1) == 5);
 
  char arr2[] = "Doe";
  assert(std::size(arr2) == 4);
}
```

---

## 9. Можно ли изменить размер массива после его создания?
- В C++ обычные массивы имеют фиксированный размер после объявления. Для этих типов массивов размер памяти определяется во время компиляции.
- Однако динамические массивы могут изменять свой размер во время выполнения. Для этого можно использовать метод resize класса std::vector. 
- Также можно динамически выделить новый массив, скопировать элементы из старого и удалить старый массив.

---

## 10. Что происходит с массивом, переданным как параметр, в функции?
Массив передаётся как указатель на первый элемент (размер теряется):

```c++
void foo(int arr[]) {  // Эквивалентно int* arr
    // sizeof(arr) даст размер указателя, а не массива!
}
```

Решение
```c++
void foo(int arr[], size_t size);
```

---

## 11. В чём разница между передачей массива в функцию напрямую и как элементом структуры?
- При передаче массива напрямую в функцию язык передаёт указатель на первый элемент массива. При передаче массива как элемента структуры передаётся экземпляр структуры, внутри которой находится массив.

Прямая передача:
- параметр функции рассматривается как указатель на первый элемент массива. Внутри функции можно работать с элементами массива через этот указатель, но изменения, внесённые в параметр, влияют на исходный массив.
```c++
void foo(int arr[]);  // Фактически передаётся указатель
```

Передача массива как элемента структуры
- создаётся копия массива, и изменения, внесённые в параметр, не влияют на исходный массив. Это происходит, потому что при передаче по значению создаётся копия аргумента.
```c++
struct Wrapper { int arr[10]; };
void bar(Wrapper w);  // Массив копируется целиком!
```

---

## 12. Как заполнить массив значениями по умолчанию?
Инициализация нулями:
```c++
int arr[5] = {};  // {0, 0, 0, 0, 0}
```

`std::fill`:
```c++
std::fill(arr, arr + 5, 42);  // {42, 42, 42, 42, 42}
```

Цикл:
```c++
for (int i = 0; i < 5; ++i) 
    arr[i] = 0;
```

---

## 13. Как отсортировать элементы массива в порядке убывания?
Использование функции sort()
```c++
std::sort(arr, arr + n, std::greater<тип данных>())
```

Здесь:
- arr — указатель на первый элемент массива;
- n — размер массива;
- std::greater<тип данных> — необязательный параметр, который указывает порядок сортировки (по убыванию). Если его не указать, по умолчанию массив будет отсортирован в порядке возрастания.

```c++
#include <algorithm>
#include <functional>

int arr[] = {3, 1, 4, 1, 5};
std::sort(std::begin(arr), std::end(arr), std::greater<int>());
// arr = {5, 4, 3, 1, 1}
```

---

## 14. Как связаны строковые литералы и массивы символов?
Строковый литерал ("Hello") – это константный массив char с нуль-терминатором (\0):
```c++
const char str[] = "Hello";  // {'H', 'e', 'l', 'l', 'o', '\0'}
```

- Литералы хранятся в read-only памяти.
- `char* p = "Hello";` – устаревший (в C++ лучше const char*).

---

## 15. Что такое std::array и как он отличается от обычного массива?
`std::array` — это контейнер из стандартной библиотеки C++, который представляет массивы фиксированного размера. Он отличается от обычного массива тем, что предоставляет более безопасный и функциональный интерфейс.

Характеристики std::array
- Фиксированный размер. Размер std::array должен быть задан в момент компиляции и не может изменяться во время работы программы.
- Обёртка над низкоуровневым массивом. Внутри std::array — это обёртка над массивом в стиле C, но с интерфейсом стандартного контейнера: знает свой размер, умеет присваиваться, предоставляет итераторы и т. д.
- Проверка границ. Функция at() выполняет проверку границ, выбрасывая исключение при доступе за пределы массива.
- Поддержка стандартных алгоритмов и итераторов. Позволяет использовать алгоритмы из STL, например, `std::sort()`.

Отличия:

Обычный массив
- Не знает свой размер
- Нельзя копировать
- Небезопасный доступ
- Нет итераторов

`std::array`:
- Имеет метод size()
- Можно копировать и присваивать
- Есть `.at()` (с проверкой границ)
- Есть итераторы (`begin()`, end())

```c++
#include <array>
std::array<int, 3> arr = {1, 2, 3};
```

---

## 16. Объявление многомерных массивов. Объявление многомерного массива с помощью std::array.
```c++
#include <cassert>
 
using Matrix2x2 = double[2][2];

void main()
{
  Matrix2x2 mat = {
    {1.0, 2.5},
    {4.5, 3.2}
  };
  assert(mat[0][0] == 1.0);
  assert(mat[0][1] == 2.5);
  assert(mat[1][0] == 4.5);
  assert(mat[1][1] == 3.2);
}
```

Обычный массив:
```c++
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

std::array:
```c++
std::array<std::array<int, 3>, 2> matrix = {{
    {1, 2, 3},
    {4, 5, 6}
}};
```

---

## 17. Как получить доступ к элементу многомерного массива? Приведите пример.
Пример:
```c++
int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
int x = matrix[1][2];  // x = 6
```

Через `std::array`:
```c++
std::array<std::array<int, 3>, 2> mat;
mat[0][1] = 42;
```