# std::deque

### **1. `std::deque` vs `std::vector`: отличия и когда использовать?**
**`std::deque` (double-ended queue)** – это двусторонняя очередь, которая:
- **Позволяет эффективно вставлять/удалять элементы в начало и конец** (`O(1)`).
- **Хранит данные блоками** (не требует переаллокации при росте, как `vector`).
- **Поддерживает доступ по индексу** (`O(1)`), но медленнее, чем `vector`.

**`std::vector`** – динамический массив:
- **Быстрый доступ по индексу** (`O(1)`), но **медленные вставки в начало** (`O(n)`).
- **Переаллокация при расширении** (может инвалидировать итераторы).

**Когда использовать:**  
| `std::vector` | `std::deque` |
|--------------|-------------|
| Частый доступ по индексу | Частые вставки в начало/конец |
| Нужен непрерывный блок памяти | Не нужна гарантия непрерывности |
| Экономия памяти (меньше накладных расходов) | Гибкость вставки/удаления с двух сторон |

---

### **2. Заголовочный файл для `std::deque`**
```cpp
#include <deque>
```

---

### **3. Внутреннее устройство `std::deque`**
**Структура:**
- **Состоит из блоков (чанков) фиксированного размера** (обычно `512` или `1024` байт).
- **Управляется через массив указателей** (`map` или `control block`).

**Схема:**
```
[Указатель на блок 0] → [элементы 0..N]
[Указатель на блок 1] → [элементы N+1..2N]
...
[Указатель на блок M] → [элементы M*N..K]
```
- **"Закольцованность"** (циклическая структура) позволяет эффективно добавлять элементы с обеих сторон.

**Почему блоки — степени двойки?**
- Быстрое вычисление индекса (`i / block_size` и `i % block_size` через битовые операции).
- Оптимизация выделения памяти.

---

### **4. Инвалидация итераторов в `std::deque`**
| Операция               | Инвалидирует итераторы? | Причина |
|------------------------|------------------------|---------|
| `push_back`, `push_front` | **Нет** (кроме случаев переаллокации `map`) | Блоки могут перевыделяться, но элементы не перемещаются |
| `insert` в середину     | **Да** (все итераторы) | Сдвигает элементы |
| `pop_back`, `pop_front` | **Только на удаляемый элемент** | Остальные итераторы остаются валидными |
| `resize`               | **Зависит от роста** | Если `map` переаллоцируется — инвалидирует все |

---

### **5. Основные операции `std::deque` и их сложность**
| Операция               | Сложность |
|------------------------|----------|
| `push_back`, `push_front` | `O(1)` |
| `pop_back`, `pop_front` | `O(1)` |
| `operator[]`, `at`      | `O(1)` |
| `insert`, `erase` в середину | `O(n)` (сдвиг элементов) |
| `size()`, `empty()`     | `O(1)` |
| `clear()`              | `O(n)` |

---

### **6. `emplace` vs `push/insert`**
| `push_back(val)` | `emplace_back(args...)` |
|------------------|------------------------|
| Создает копию/перемещение | Конструирует элемент на месте (без лишних копий) |
| Медленнее для сложных типов | Эффективнее (особенно для `std::pair`, `std::tuple`) |

**Пример:**
```cpp
std::deque<std::pair<int, std::string>> dq;
dq.push_back({1, "abc"}); // Создает временный объект
dq.emplace_back(1, "abc"); // Прямая передача аргументов в конструктор
```

---

### **7. `std::deque` vs `std::list`**
| `std::deque` | `std::list` |
|--------------|------------|
| Доступ по индексу (`O(1)`) | Доступ по индексу (`O(n)`) |
| Вставка в начало/конец (`O(1)`) | Вставка в начало/конец (`O(1)`) |
| Вставка в середину (`O(n)`) | Вставка в середину (`O(1)` с итератором) |
| Экономичнее по памяти (меньше накладных расходов) | Больше накладных расходов (2 указателя на элемент) |

**Когда использовать `deque`:**
- Нужен **быстрый доступ по индексу** + **вставки с двух сторон**.
- **Не нужны частые вставки в середину**.

**Когда использовать `list`:**
- **Частые вставки/удаления в произвольных местах**.
- **Важна стабильность итераторов**.

---

### **8. Инвалидация ссылок в `std::deque`**
- **Ссылки инвалидируются только при удалении элемента** или при `insert`/`erase` (если происходит сдвиг).
- `push_back`/`push_front` **не инвалидируют** ссылки на существующие элементы.

---

### **9. Разворот `std::deque`**
```cpp
std::deque<int> dq = {1, 2, 3};
std::reverse(dq.begin(), dq.end()); // Алгоритм из <algorithm>
// dq = {3, 2, 1}
```
**Сложность:** `O(n)` (линейный проход).

---

### **10. Доступ по индексу за `O(1)`**
- **Вычисление блока:** `block = index / block_size`.
- **Вычисление позиции в блоке:** `pos = index % block_size`.
- **Доступ через `map[block][pos]`.**

---

### **11. Вставка элементов из другого контейнера**
```cpp
std::deque<int> dq = {1, 2, 3};
std::vector<int> vec = {4, 5};

// В начало
dq.insert(dq.begin(), vec.begin(), vec.end()); // dq = {4, 5, 1, 2, 3}

// В конец
dq.insert(dq.end(), vec.begin(), vec.end()); // dq = {1, 2, 3, 4, 5}

// В середину
dq.insert(dq.begin() + 1, vec.begin(), vec.end()); // dq = {1, 4, 5, 2, 3}
```

---

### **12. Безопасный доступ по индексу (`at` vs `operator[]`)**
```cpp
std::deque<int> dq = {1, 2, 3};
dq.at(1); // 2 (проверка границ, бросает std::out_of_range)
dq[1];    // 2 (без проверки, UB при выходе за границы)
```

---

### **13. Почему нет `data()` в `std::deque`?**
- `std::vector` хранит элементы **в непрерывной памяти**, поэтому `data()` возвращает указатель на массив.
- `std::deque` **не гарантирует непрерывность**, поэтому `data()` невозможен.

---

### **14. Ссылка на последний элемент**
```cpp
std::deque<int> dq = {1, 2, 3};
int& last = dq.back(); // 3
```

---

### **15. Компактность хранения: `deque` vs `list`**
- **`std::deque` компактнее**, так как хранит элементы в блоках (меньше накладных расходов).
- **`std::list` менее компактен**, так как каждый элемент содержит 2 указателя (`prev`, `next`).

---

### **16. Скорость последовательной итерации**
**Быстрее всего:** `std::vector` > `std::deque` > `std::list`.
- **`vector`** – непрерывная память (кэш-френдли).
- **`deque`** – блоки могут быть разбросаны.
- **`list`** – указатели приводят к промахам кэша.

---

### **17. Обработка заполненных блоков**
- Если блок заполнен, **создается новый блок** и добавляется в `map`.
- Если `map` заполнен, **он переаллоцируется** (редко, т.к. `map` большой).

---

### **18. Скорость вставки: `deque` vs `vector`**
| Операция       | `std::deque` | `std::vector` |
|----------------|-------------|--------------|
| `push_front`   | `O(1)`      | `O(n)`       |
| `push_back`    | `O(1)`      | `O(1)` (амортизированно) |
| `insert` в середину | `O(n)` | `O(n)` (но вектор быстрее из-за кэша) |

---

### **19. Время доступа по индексу: `deque` vs `vector`**
- **`std::vector`** – `O(1)` (прямой доступ).
- **`std::deque`** – `O(1)`, но **медленнее** из-за дополнительных вычислений блока.

---

### **20. Когда `std::deque` предпочтительнее `std::vector`?**
- **Частые `push_front`** (у `vector` это `O(n)`).
- **Нужен баланс между вставкой в начало/конец и доступом по индексу**.
- **Избегание переаллокаций** (у `deque` они редки).

---

### **21. Ограничения `std::deque` по сравнению с `std::list`**
- **Нет `O(1)` вставки в середину** (только `O(n)`).
- **Итераторы могут инвалидироваться при вставке/удалении**.
- **Нет `splice`** (быстрого переноса элементов между контейнерами).

---

### **22. Вставка/удаление в середине: `deque` vs `list`**
- **`std::list`** – `O(1)` (если есть итератор).
- **`std::deque`** – `O(n)` (требуется сдвиг элементов).

**Вывод:**
- Если нужны **частые вставки в середину** → `std::list`.
- Если важнее **доступ по индексу** → `std::deque`.

### **Итог**
`std::deque` – это **гибрид `vector` и `list`**, который:
- Подходит для **двусторонних операций** (`push_front`, `push_back`).
- Обеспечивает **доступ по индексу**, но медленнее `vector`.
- Экономичнее `list` по памяти, но проигрывает в гибкости вставок.