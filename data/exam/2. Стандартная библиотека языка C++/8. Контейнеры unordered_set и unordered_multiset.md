# Контейнеры unordered_set и unordered_multiset

Вот детальные ответы на ваши вопросы о `std::unordered_set` и связанных темах в C++:

---

### 1. `std::unordered_set`: назначение
**`std::unordered_set`** — это ассоциативный контейнер из `<unordered_set>`, хранящий уникальные элементы без определённого порядка.  
**Основные цели:**
- Быстрый поиск, вставка и удаление элементов (в среднем за O(1)).
- Хранение уникальных значений (дубликаты запрещены).
- Использование хеш-таблицы для организации данных.

**Пример:**
```cpp
#include <unordered_set>
std::unordered_set<int> nums = {1, 2, 3, 4};
```

---

### 2. Операции над `unordered_set` и их сложность
| **Операция**            | **Синтаксис**                     | **Сложность**       |
|-------------------------|-----------------------------------|---------------------|
| Вставка                 | `insert(value)` или `emplace(...)` | В среднем O(1)      |
| Удаление                | `erase(value)` или `erase(iterator)` | В среднем O(1)      |
| Поиск                   | `find(value)`                     | В среднем O(1)      |
| Проверка наличия        | `count(value)`                    | В среднем O(1)      |
| Доступ к bucket-ам      | `bucket_count()`, `bucket_size(n)` | O(1)               |
| Резервирование памяти   | `reserve(n)`                      | O(n)               |

**Примеры:**
```cpp
std::unordered_set<std::string> words;
words.insert("apple");       // Вставка
words.emplace("banana");     // In-place создание
words.erase("apple");        // Удаление
if (words.find("banana") != words.end()) { /* Найдено */ }
```

---

### 3. Порядок элементов в `unordered_set`
- **Порядок не гарантируется** и зависит от хеш-функции и состояния хеш-таблицы.
- **Изменить порядок нельзя**, так как он определяется внутренней структурой (bucket-ами).
- **Нюанс:** Порядок может измениться при рехешировании (например, при увеличении размера таблицы).

---

### 4. Пользовательские типы данных в `unordered_set`
Можно использовать, если для типа определена:
1. **Хеш-функция** (специализация `std::hash`).
2. **Оператор сравнения `==`** (для разрешения коллизий).

**Пример:**
```cpp
struct Person {
    std::string name;
    int age;
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

std::unordered_set<Person> people;
```

---

### 5. Требования к типам элементов
1. **Должен быть определён `std::hash<T>`** (или пользовательская хеш-функция).
2. **Должен поддерживать `operator==`** (или пользовательский компаратор).
3. **Должен быть копируемым или перемещаемым** (для вставки и удаления).

---

### 6. `insert` vs `emplace`
| **Метод**   | **Синтаксис**               | **Когда использовать**                |
|-------------|-----------------------------|---------------------------------------|
| `insert`    | `insert(value)`             | Когда объект уже создан.              |
| `emplace`   | `emplace(args...)`          | Когда нужно создать объект на месте (из аргументов конструктора). |

**Пример:**
```cpp
std::unordered_set<std::pair<int, int>> s;
s.insert({1, 2});          // Создаёт временный pair, затем копирует
s.emplace(3, 4);           // Создаёт pair на месте из (3, 4)
```

---

### 7. Перенос элемента между `unordered_set`
Используйте `extract` (C++17):
```cpp
std::unordered_set<int> set1 = {1, 2, 3};
std::unordered_set<int> set2;

auto node = set1.extract(2);  // "Извлечь" элемент
if (!node.empty()) {
    set2.insert(std::move(node));  // Перенос без копирования
}
```

**Нюанс:** `extract` сохраняет даже хеш элемента, что ускоряет вставку.

---

### 8. `set` vs `unordered_set`
| **Критерий**         | **`std::set`**                  | **`std::unordered_set`**        |
|----------------------|---------------------------------|----------------------------------|
| **Сложность операций** | O(log n)                       | В среднем O(1)                  |
| **Порядок элементов** | Отсортирован (по `<`)          | Не гарантирован                 |
| **Требования к типам** | `operator<` или компаратор     | Хеш-функция и `operator==`      |
| **Использование**     | Нужен порядок или малый размер | Критична скорость, порядок не важен |

---

### 9. Копирование между `vector` и `unordered_set`
**Из `vector` в `unordered_set`:**
```cpp
std::vector<int> vec = {1, 2, 3, 2};
std::unordered_set<int> s(vec.begin(), vec.end());  // Дубликаты удаляются
```

**Из `unordered_set` в `vector`:**
```cpp
std::vector<int> newVec(s.begin(), s.end());
```

**Через алгоритмы:**
```cpp
std::copy(s.begin(), s.end(), std::back_inserter(newVec));
```

---

### 10. `unordered_multiset` и получение всех значений по ключу
`unordered_multiset` позволяет хранить дубликаты.  
**Как получить все значения:**
```cpp
std::unordered_multiset<int> ms = {1, 2, 2, 3};
auto range = ms.equal_range(2);  // Возвращает пару итераторов
for (auto it = range.first; it != range.second; ++it) {
    std::cout << *it << " ";  // 2 2
}
```

---

### 11. Удаление элементов по критерию
**Удалить все подходящие элементы** (используйте `erase` + предикат):
```cpp
std::unordered_set<int> s = {1, 2, 3, 4, 5};
auto pred = [](int x) { return x % 2 == 0; };
for (auto it = s.begin(); it != s.end(); ) {
    if (pred(*it)) it = s.erase(it);
    else ++it;
}
```

**Удалить не более N элементов**:
```cpp
int n = 2;
for (auto it = s.begin(); it != s.end() && n > 0; ) {
    if (pred(*it)) {
        it = s.erase(it);
        --n;
    } else ++it;
}
```

---

### 12. Хеш-функция в `unordered_set`
**Хеш-функция** преобразует ключ в `size_t` для размещения в bucket-ах.  
**Требования:**
- Консистентность: если `a == b`, то `hash(a) == hash(b)`.
- Желательно минимизировать коллизии.

**Пример своей хеш-функции:**
```cpp
struct MyHash {
    size_t operator()(const MyClass& obj) const {
        return std::hash<int>()(obj.id) ^ std::hash<std::string>()(obj.name);
    }
};
std::unordered_set<MyClass, MyHash> mySet;
```

---

### 13. Bucket-ы и производительность
- **Bucket** — "ячейка" в хеш-таблице, содержащая элементы с одинаковым хешом.
- **Влияние на производительность**:
    - Чем больше bucket-ов, тем меньше коллизий (но больше памяти).
    - Идеальный случай: 1 элемент на bucket.

**Управление bucket-ами:**
```cpp
s.bucket_count();       // Текущее количество
s.load_factor();        // Среднее заполнение (элементы / bucket-ы)
s.max_load_factor(0.7); // Установить максимальный коэффициент заполнения
s.rehash(100);          // Явно изменить количество bucket-ов
```

---

### 14. Рехеширование (Rehashing)
**Что это?** Перестройка хеш-таблицы при увеличении размера, чтобы уменьшить коллизии.  
**Когда происходит?**
- При добавлении элементов, если `size() > max_load_factor() * bucket_count()`.
- При вызове `rehash()` или `reserve()`.

**Как управлять?**
```cpp
std::unordered_set<int> s;
s.reserve(1000);  // Зарезервировать место для 1000 элементов
s.rehash(512);    // Явно установить количество bucket-ов
```

**Нюанс:** Рехеширование инвалидирует все итераторы и указатели.

---

Если у вас остались вопросы или нужно углубиться в конкретный аспект, уточните!