# Контейнеры map и multimap

### **1. Контейнер `std::map`. Для чего используется?**
`std::map` — это ассоциативный контейнер, хранящий пары **ключ-значение** в отсортированном порядке. Он реализован как **красно-черное дерево** (сбалансированное бинарное дерево поиска).

**Основные применения:**
- Быстрый поиск по ключу (O(log n)).
- Хранение данных в отсортированном виде.
- Уникальность ключей (каждый ключ встречается только один раз).

---

### **2. Операции над `map`. Какова сложность этих операций?**
Основные операции и их сложность:

| Операция             | Сложность       | Описание |
|----------------------|----------------|----------|
| `insert`, `emplace`  | O(log n)       | Вставка элемента |
| `erase`              | O(log n)       | Удаление элемента |
| `find`               | O(log n)       | Поиск по ключу |
| `operator[]`         | O(log n)       | Доступ или вставка |
| `at`                 | O(log n)       | Доступ с проверкой |
| `lower_bound`        | O(log n)       | Поиск первого >= ключа |
| `upper_bound`        | O(log n)       | Поиск первого > ключа |
| `begin`, `end`       | O(1)           | Итераторы |
| `size`, `empty`      | O(1)           | Проверка размера |

---

### **3. В каком порядке находятся элементы `std::map`? Можно ли изменить порядок элементов?**
- Элементы хранятся **в порядке возрастания ключей** (по умолчанию).
- Порядок можно изменить, передав **пользовательский компаратор** в шаблон:
  ```c++
  std::map<int, string, std::greater<int>> m; // Убывающий порядок
  ```

---

### **4. Могут ли в качестве ключей `map` использоваться пользовательские типы данных? Что для этого нужно сделать?**
**Да**, но ключ должен быть:
1. **Сравнимым** (должен быть определен `operator<` или передан компаратор).
2. **Копируемым/перемещаемым**.
3. **Иметь `const`-корректность** (ключи нельзя изменять после вставки).

**Пример:**
```c++
struct Person {
    string name;
    int age;
    bool operator<(const Person& other) const {
        return age < other.age;
    }
};

std::map<Person, string> people;
```

**Альтернатива:** передача компаратора в шаблон.
```c++
auto cmp = [](const Person& a, const Person& b) { return a.name < b.name; };
std::map<Person, string, decltype(cmp)> people(cmp);
```

---

### **5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?**
- Должен поддерживать **копирование/перемещение** (если не используется `emplace`).
- Может быть любым (нет ограничений, как у ключей).

---

### **6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?**
| `map[key] = value` | `map.emplace(key, value)` |
|--------------------|---------------------------|
| Создает элемент, если ключа нет | Создает элемент на месте (без лишних копирований) |
| Вызывает конструктор копирования/присваивания | Передает аргументы напрямую в конструктор |
| Менее эффективен (если тип сложный) | Более эффективен (избегает промежуточных копий) |

**Пример:**
```c++
std::map<int, std::string> m;
m[1] = "test"; // Создает пустую строку, затем присваивает
m.emplace(2, "test"); // Сразу создает pair(2, "test")
```

---

### **7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?**
| `map[key] = value` | `map.at(key) = value` |
|--------------------|-----------------------|
| Вставляет элемент, если ключа нет | Бросает `std::out_of_range`, если ключа нет |
| Может изменить размер `map` | Не изменяет размер `map` |
| Подходит для записи | Подходит только для модификации существующих элементов |

---

### **8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`**
```c++
#include <optional>
#include <map>
#include <string>

std::optional<std::string> TryGetValue(const std::map<int, std::string>& m, int key) {
    auto it = m.find(key);
    if (it != m.end()) {
        return it->second;
    }
    return std::nullopt;
}
```

---

### **9. Как можно ускорить вставку в `map`?**
1. **Использовать `emplace` вместо `insert`** (избегает лишних копирований).
2. **Использовать `try_emplace` (C++17)** — не перемещает ключ, если он уже есть.
3. **Предварительно зарезервировать память** (но `map` не поддерживает `reserve`, в отличие от `unordered_map`).
4. **Использовать `unordered_map`**, если порядок не важен (O(1) вставка).

---

### **10. Что происходит при использовании оператора `[]` для элемента, который ещё не существует в `std::map`?**
- Если ключа нет, **создается новый элемент** с этим ключом и **значением по умолчанию** (`value_type()`).
- Затем выполняется присваивание (`operator=`).

**Пример:**
```c++
std::map<int, int> m;
m[5] = 10; // Если ключа 5 нет, создается m[5] = 0, затем присваивается 10
```

---

### **11. Как быстро перенести элемент из одного контейнера `map` в другой `map` того же типа?**
Использовать **`extract` (C++17)** — перемещает узел без перераспределения памяти:
```c++
std::map<int, string> m1, m2;
m1[1] = "test";
auto node = m1.extract(1); // Извлекаем узел
m2.insert(std::move(node)); // Вставляем в m2
```

---

### **12. Как получить все значения `multimap` с заданным ключом?**
Использовать `equal_range`:
```c++
std::multimap<int, string> mm = {{1, "a"}, {1, "b"}, {2, "c"}};
auto [begin, end] = mm.equal_range(1); // Диапазон всех элементов с ключом 1
for (auto it = begin; it != end; ++it) {
    cout << it->second << endl; // Выведет "a", "b"
}
```

---

### **13. Что возвращает метод `insert` для `std::map` и как он отличается от `std::multimap`?**
| `std::map::insert` | `std::multimap::insert` |
|--------------------|-------------------------|
| Возвращает `pair<iterator, bool>`: `bool` = `true`, если вставка успешна (ключа не было) | Всегда вставляет, возвращает `iterator` на новый элемент |
| Ключи уникальны | Допускает дубликаты ключей |

---

### **14. В чём разница между `lower_bound` и `upper_bound`?**
| `lower_bound(key)` | `upper_bound(key)` |
|--------------------|--------------------|
| Возвращает **первый** элемент `>= key` | Возвращает **первый** элемент `> key` |
| Если ключ есть, указывает на него | Если ключ есть, указывает на следующий |

**Пример:**
```c++
std::map<int, string> m = {{1, "a"}, {3, "b"}};
auto lb = m.lower_bound(2); // Указывает на {3, "b"}
auto ub = m.upper_bound(2); // Указывает на {3, "b"}
```

---

### **15. Как реализовать пользовательскую функцию сравнения для `std::map`?**
1. **Через `operator<`** (если тип свой).
2. **Через функтор/lambda:**
```c++
struct CaseInsensitiveCompare {
    bool operator()(const string& a, const string& b) const {
        return std::lexicographical_compare(
            a.begin(), a.end(), b.begin(), b.end(),
            [](char c1, char c2) { return tolower(c1) < tolower(c2); }
        );
    }
};

std::map<string, int, CaseInsensitiveCompare> m;
```

---

### **16. Какова временная сложность вставки, поиска и удаления в `std::map`?**
- **Вставка (`insert`, `emplace`): O(log n)**
- **Поиск (`find`, `operator[]`, `at`): O(log n)**
- **Удаление (`erase`): O(log n)**

---

### **17. В каких случаях использовать `map`, а в каких `unordered_map`?**
| `std::map` | `std::unordered_map` |
|------------|----------------------|
| Гарантирует порядок элементов | Порядок не гарантирован |
| O(log n) операции | O(1) в среднем, O(n) в худшем случае |
| Требует компаратор | Требует хэш-функцию |
| Подходит для диапазонных запросов | Подходит для быстрого доступа |

**Выбор:**
- Если нужен порядок → `map`.
- Если важна скорость → `unordered_map`.

---

### **18. Что происходит с итераторами при вставке нового элемента?**
- **Итераторы остаются валидными** (кроме удаленных элементов).
- **Указатели/ссылки на элементы остаются валидными** (так как узлы не перераспределяются).

---

### **19. Когда стоит использовать `std::multimap` вместо `std::map`?**
- Когда **несколько значений** могут иметь **один ключ**.
- Пример:
  ```c++
  std::multimap<string, string> phonebook;
  phonebook.insert({"Alice", "123"});
  phonebook.insert({"Alice", "456"}); // Два номера у Alice
  ```

---

### **20. В чем различие между доступом к элементам с помощью метода `at` и операции `[]`?**
| `map.at(key)` | `map[key]` |
|--------------|-----------|
| Бросает `std::out_of_range`, если ключа нет | Создает новый элемент, если ключа нет |
| Только для чтения/модификации | Может увеличить размер `map` |
| Константная сложность (O(log n)) | Тоже O(log n), но с побочным эффектом |

---

### **21. Чем отличается `emplace` от `try_emplace`?**
| `emplace` | `try_emplace` (C++17) |
|-----------|-----------------------|
| Всегда создает новый элемент | Не перемещает ключ, если он уже есть |
| Может перемещать ключ даже при неудаче | Эффективнее, если ключ уже существует |

**Пример:**
```c++
std::map<int, string> m;
m.emplace(1, "test"); // Всегда создает pair
m.try_emplace(1, "test"); // Не создает, если ключ 1 уже есть
```

---

### **22. Что происходит, если использовать `std::map` с ключами, не поддерживающими `operator<`?**
**Ошибка компиляции**, если:
- Не определен `operator<`.
- Не передан компаратор.

**Решение:**
```c++
struct Key { int a, b; };
auto cmp = [](const Key& x, const Key& y) { return x.a < y.a; };
std::map<Key, int, decltype(cmp)> m(cmp);
```

---

### **23. В каком порядке возможен обход элементов контейнера `map`?**
- **По возрастанию ключей** (по умолчанию).
- **По убыванию** (если задан `std::greater`).
- **Произвольный** (если использовать итераторы или `unordered_map`).

**Пример:**
```c++
for (const auto& [key, value] : m) { // C++17
    cout << key << ": " << value << endl;
}
```

---

### **24. Как удалить из контейнера `map` все элементы, удовлетворяющие заданному критерию?**
Использовать **erase + remove_if** (через итераторы):
```c++
std::map<int, string> m = {{1, "a"}, {2, "b"}, {3, "c"}};
for (auto it = m.begin(); it != m.end(); ) {
    if (it->first % 2 == 0) { // Удаляем четные ключи
        it = m.erase(it);
    } else {
        ++it;
    }
}
```

**С C++20:**
```c++
std::erase_if(m, [](const auto& p) { return p.first % 2 == 0; });
```

---

### **25. Как удалить из контейнера `map` не более `N` элементов, удовлетворяющих заданному критерию?**
```c++
size_t n = 2; // Максимум 2 элемента
for (auto it = m.begin(); it != m.end() && n > 0; ) {
    if (it->first % 2 == 0) {
        it = m.erase(it);
        --n;
    } else {
        ++it;
    }
}
```

---

### **Итог**
`std::map` — мощный контейнер для работы с отсортированными данными. Его эффективность (O(log n)) делает его полезным для задач, где важен порядок и уникальность ключей. Для максимальной производительности стоит использовать `emplace`, `extract` и `try_emplace`. Если порядок не важен, лучше подойдет `unordered_map`.