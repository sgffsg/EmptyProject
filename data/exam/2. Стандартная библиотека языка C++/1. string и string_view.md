# std::string и std::string_view

Вот подробные ответы на все ваши вопросы о строках в C++:

---

### 1. **Что представляет собой класс `std::string` в C++?**
`std::string` — это класс стандартной библиотеки C++ (STL), представляющий собой динамическую строку символов. Он инкапсулирует управление памятью, предоставляет безопасные и удобные методы для работы со строками и автоматически обрабатывает освобождение памяти.

### 2. **Какие типы данных могут использоваться для хранения символов в `std::string`?**
`std::string` использует `char` (обычно 1 байт) для хранения символов. Однако существуют его вариации:
- `std::wstring` — использует `wchar_t` (широкие символы, размер зависит от платформы: 2 или 4 байта).
- `std::u16string` — `char16_t` (UTF-16, 2 байта).
- `std::u32string` — `char32_t` (UTF-32, 4 байта).

### 3. **Основные преимущества `std::string` по сравнению с C-строками:**
- **Автоматическое управление памятью** (не нужно вручную выделять/освобождать память).
- **Безопасность** (меньше риск переполнения буфера).
- **Удобные методы** (`find`, `substr`, `append` и др.).
- **Поддержка операторов** (`+`, `==`, `<` и др.).
- **Изменяемый размер** (можно увеличивать/уменьшать длину).
- **Итераторы** (совместимость с алгоритмами STL).

### 4. **Внутреннее устройство `std::string` в типичных реализациях:**
Обычно `std::string` содержит:
- Указатель на динамически выделенный буфер (`char*`).
- Размер (`size`) — текущая длина строки.
- Вместимость (`capacity`) — сколько памяти выделено.
- **Small String Optimization (SSO)** — для коротких строк (обычно до 15 символов) данные хранятся внутри объекта без выделения динамической памяти.

### 5. **Разница между `std::string` и `std::wstring`:**
- `std::string` использует `char` (обычно ASCII или UTF-8).
- `std::wstring` использует `wchar_t` (широкие символы, подходит для Unicode, но размер зависит от ОС: 2 байта в Windows, 4 в Linux).

### 6. **Какие операции можно выполнять над `std::string`?**
- Конкатенация (`+`, `append`).
- Вставка (`insert`).
- Удаление (`erase`, `clear`).
- Поиск (`find`, `rfind`).
- Изменение размера (`resize`).
- Получение подстроки (`substr`).
- Сравнение (`==`, `!=`, `<`, `>` и др.).
- Доступ к символам (`[]`, `at`, `front`, `back`).

### 7. **Разница между размером (`size`) и вместимостью (`capacity`):**
- `size()` — текущее количество символов в строке.
- `capacity()` — сколько памяти выделено (может быть больше `size` для оптимизации добавления символов).

### 8. **Что такое Small String Optimization (SSO)?**
Оптимизация, при которой короткие строки (обычно до 15-23 символов) хранятся внутри объекта `std::string` без выделения динамической памяти. Это ускоряет работу и уменьшает фрагментацию.

### 9. **Как изменяются `size` и `capacity` при `erase`?**
- `size` уменьшается на количество удалённых символов.
- `capacity` обычно **не изменяется** (память не освобождается автоматически, чтобы избежать лишних аллокаций).

### 10. **Сложность операций вставки и замены символов:**
- Вставка (`insert`) или удаление (`erase`) в середине строки — **O(n)** (сдвиг символов).
- Добавление в конец (`push_back`, `+=`) — **амортизированное O(1)** (если не нужно перевыделять память).
- Доступ по индексу (`[]`, `at`) — **O(1)**.

### 11. **Класс `std::string_view`, отличие от `std::string`:**
- `string_view` — это **невладеющая** ссылка на строку (не управляет памятью).
- Не выделяет память (только указывает на существующие данные).
- Легковесный (обычно содержит только указатель и размер).
- Нельзя изменить данные, на которые указывает (только читать).

### 12. **Когда использовать `string_view`, а когда `string`?**
- `string_view` — для **чтения** строк без копирования (аргументы функций, временные подстроки).
- `string` — когда нужно **владеть** данными или изменять строку.

### 13. **Отличие `substr` в `std::string` и `std::string_view`:**
- `string::substr` возвращает новую строку (`std::string`), выделяя память.
- `string_view::substr` возвращает новый `string_view` (без копирования данных).

### 14. **Как найти все вхождения подстроки в строке?**
```cpp
std::string str = "hello world hello";
std::string substr = "hello";
size_t pos = 0;
while ((pos = str.find(substr, pos)) != std::string::npos) {
    std::cout << "Found at: " << pos << std::endl;
    pos += substr.length();
}
```

### 15. **Как объединить две строки?**
- Через оператор `+`: `std::string result = s1 + s2;`
- Через `append`: `s1.append(s2);`

### 16. **Как быстро найти все вхождения подстроки?**
- Использовать алгоритм **Кнута-Морриса-Пратта (KMP)** или **Бойера-Мура** (но в `std::string::find` используется упрощённый алгоритм).
- Для множественных поисков можно построить **суффиксное дерево** или использовать **регулярные выражения** (`std::regex`).

### 17. **Операторы сравнения для `std::string`:**
- `==`, `!=`, `<`, `>`, `<=`, `>=` (лексикографическое сравнение).

### 18. **Преобразование `std::string` в число и обратно:**
- В число:
  ```cpp
  int num = std::stoi("42");
  double d = std::stod("3.14");
  ```
- Обратно:
  ```cpp
  std::string s = std::to_string(123);
  ```

### 19. **Как ускорить работу со строками?**
- Использовать `reserve()` для предварительного выделения памяти.
- Использовать `string_view` вместо копирования.
- Избегать частых переаллокаций (например, конкатенация в цикле).
- Использовать SSO (короткие строки хранятся на стеке).

### 20. **Что будет с `string_view` после разрушения строки?**
`string_view` **не владеет** данными, поэтому после уничтожения исходной строки он становится **невалидным** (обращение к нему — неопределённое поведение).

---

### Дополнительные нюансы:
- В C++17 появились `std::string_view` и методы `data()` (гарантирует нуль-терминированную строку).
- В C++20 добавлены `starts_with`, `ends_with` для `std::string`.
- Для многобайтовых кодировок (UTF-8) `size()` возвращает количество байт, а не символов (используйте библиотеки типа ICU для корректной работы).

Если нужно углубиться в какой-то аспект, дайте знать!