# std::vector и std::array

### **1. `std::array` vs C-массив**
**`std::array`** – это шаблонный контейнер, обертка над C-массивом с дополнительными возможностями:
- **Фиксированный размер** (известен на этапе компиляции).
- **Поддерживает STL-интерфейс** (`size()`, `begin()`, `end()`).
- **Безопасный доступ** (`at()` с проверкой границ).
- **Можно копировать и передавать по значению** (в отличие от C-массива).

**Пример:**
```cpp
std::array<int, 3> arr = {1, 2, 3}; // Аналог int arr[3] = {1, 2, 3};
```

**Отличия от C-массива:**  
| `std::array` | C-массив |
|-------------|----------|
| Размер — часть типа (`std::array<int, 3>`) | Размер — отдельный параметр (`int[3]`) |
| Передается по значению | При передаче в функцию превращается в указатель |
| Есть методы (`size()`, `at()`) | Нет методов, только ручное управление |

---

### **2. Передача `std::array` по значению**
**Да, можно** (в отличие от C-массива, который передается как указатель):
```cpp
void printArray(std::array<int, 3> arr) { // Копирование
    for (int x : arr) std::cout << x << " ";
}
```

---

### **3. Трехмерный массив через `std::array`**
```cpp
std::array<std::array<std::array<int, 3>, 3>, 3> cube;
cube[0][0][0] = 1; // Доступ к элементу
```

---

### **4. `std::vector` vs C-массив vs `std::array`**
| `std::vector` | `std::array` | C-массив |
|--------------|-------------|----------|
| Динамический размер | Фиксированный размер | Фиксированный размер |
| Управление памятью (куча) | Стек или куча | Стек или куча |
| Поддержка STL | Поддержка STL | Нет STL-интерфейса |
| Доступ по индексу (`O(1)`) | Доступ по индексу (`O(1)`) | Доступ по индексу (`O(1)`) |

---

### **5. Внутреннее устройство `std::vector`**
**Схема:**
```
[Указатель] → [элемент 1][элемент 2]...[элемент N][свободная память]
```  
- **`data()`** – указатель на начало.
- **`size`** – текущее количество элементов.
- **`capacity`** – выделенная память.

**При `push_back`:**
1. Если `size < capacity`, элемент добавляется в конец.
2. Если `size == capacity`, происходит **реаллокация** (обычно `capacity *= 2`).

---

### **6. `push_back` в заполненный `vector`**
- **Выделяется новый блок памяти** (обычно в 2 раза больше).
- **Элементы копируются/перемещаются** в новый блок.
- **Старая память освобождается**.

**Сложность:** `O(n)` (амортизированно `O(1)`).

---

### **7. Основные операции `std::vector`**
| Операция          | Сложность      |
|-------------------|---------------|
| `push_back`       | `O(1)` (амортизированно) |
| `pop_back`        | `O(1)` |
| `operator[]`, `at` | `O(1)` |
| `insert`, `erase` | `O(n)` |
| `size`, `empty`   | `O(1)` |
| `clear`           | `O(n)` |

---

### **8. Оптимизации `std::vector`**
1. **`reserve()`** – предварительное выделение памяти.
2. **`emplace_back`** – избегает копирования.
3. **Использование `shrink_to_fit()`** для уменьшения `capacity`.

---

### **9. `at()` vs `operator[]`**
| `at(index)` | `operator[]` |
|------------|-------------|
| Проверяет границы (бросает `std::out_of_range`) | Не проверяет (UB при выходе за границы) |
| Медленнее (из-за проверки) | Быстрее |

**Когда использовать:**
- `at()` – если важна безопасность.
- `operator[]` – если нужна скорость и гарантируется корректность индекса.

---

### **10. Обход элементов `vector`**
**Прямой порядок:**
```cpp
for (auto it = vec.begin(); it != vec.end(); ++it) { /* ... */ }
// Или:
for (int x : vec) { /* ... */ }
```

**Обратный порядок:**
```cpp
for (auto it = vec.rbegin(); it != vec.rend(); ++it) { /* ... */ }
```

---

### **11. Хранение элементов в памяти**
- **Последовательно, без промежутков** (как C-массив).
- Гарантируется **непрерывность памяти** (`data()` возвращает указатель на массив).

---

### **12. Размер (`size`) vs Вместимость (`capacity`)**
- **`size`** – текущее количество элементов.
- **`capacity`** – выделенная память (в элементах).

**Пример:**
```cpp
std::vector<int> vec;
vec.reserve(10); // capacity = 10, size = 0
vec.push_back(1); // size = 1
```

---

### **13. Инвалидация итераторов**
**Инвалидируются при:**
- `push_back` (если `size == capacity`).
- `insert`, `erase`, `resize` (если происходит сдвиг элементов).

**Не инвалидируются при:**
- `push_back` (если `size < capacity`).
- `pop_back`.

**Причина:** Реаллокация меняет адреса элементов.

---

### **14. `emplace` vs `push/insert`**
| `push_back(val)` | `emplace_back(args...)` |
|------------------|------------------------|
| Создает временный объект | Конструирует элемент на месте |
| Медленнее для сложных типов | Эффективнее (избегает копирования) |

**Пример:**
```cpp
vec.push_back(std::string("test")); // Создает временную строку
vec.emplace_back("test"); // Прямой вызов конструктора
```

---

### **15. Идиома `erase/remove`**
Удаление элементов по условию:
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
vec.erase(std::remove_if(vec.begin(), vec.end(), [](int x) { return x % 2 == 0; }), vec.end());
// vec = {1, 3, 5}
```

---

### **16. Разворот `vector` за `O(n)` времени и `O(1)` памяти**
```cpp
std::reverse(vec.begin(), vec.end());
```

---

### **17. Указатель на первый элемент**
```cpp
int* ptr = vec.data(); // Или &vec[0]
```

---

### **18. Амортизированная сложность `push_back`**
- **Амортизированно `O(1)`** – несмотря на редкие `O(n)` реаллокации.
- **Амортизированная сложность** – средняя стоимость операции при многократном вызове.

---

### **19. Вставка элементов из другого контейнера**
```cpp
std::deque<int> dq = {4, 5, 6};

// В конец (O(n))
vec.insert(vec.end(), dq.begin(), dq.end());

// В начало (O(n))
vec.insert(vec.begin(), dq.begin(), dq.end());

// В середину (O(n))
vec.insert(vec.begin() + 1, dq.begin(), dq.end());
```

---

### **20. `shrink_to_fit()`**
Освобождает неиспользуемую память:
```cpp
vec.shrink_to_fit(); // capacity = size
```
**Когда использовать:** После массового удаления элементов.

---

### **21. Обратные итераторы**
```cpp
for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
    std::cout << *it << " "; // Обход в обратном порядке
}
```

---

### **22. `clear()`**
Удаляет все элементы, но **не освобождает память** (`capacity` не меняется).

---

### **23. Итератор `end()` при изменении размера**
- Всегда указывает **за последний элемент**.
- Инвалидируется при реаллокации.

---

### **24. `std::vector` без оператора присваивания**
**Да, может** (но нельзя использовать `insert`, `push_back` с копированием).

---

### **25. `std::vector` без конструктора по умолчанию**
**Да, может** (если элементы создаются через `emplace_back` или `reserve` + `push_back` с аргументами).

---

### **26. `reserve()`**
Предварительно выделяет память:
```cpp
vec.reserve(100); // capacity >= 100
```
**Зачем:** Избежать реаллокаций при росте.

---

### **27. `std::vector` vs `std::list`**
| `std::vector` | `std::list` |
|--------------|------------|
| Быстрый доступ по индексу (`O(1)`) | Доступ по индексу (`O(n)`) |
| Медленные вставки в середину (`O(n)`) | Быстрые вставки (`O(1)`) |
| Кэш-френдли (непрерывная память) | Промахи кэша (разрозненная память) |

**Когда использовать:**
- `vector` – если важна **локальность данных** и **доступ по индексу**.
- `list` – если нужны **частые вставки/удаления в середине**.

---

### **28. Ограничения `std::vector` vs `std::deque`**
- **Нет `push_front`** (у `deque` есть, `O(1)`).
- **Реаллокации дороже** (у `deque` они менее затратны).

---

### **29. Вставка/удаление в середине: `vector` vs `list`**
- **`std::list`** – `O(1)` (если есть итератор).
- **`std::vector`** – `O(n)` (требуется сдвиг элементов).

**Вывод:**
- Для частых вставок в середину **лучше `list`**.
- Для доступа по индексу **лучше `vector`**.

### **Итог**
- `std::array` – фиксированный размер, безопасная замена C-массива.
- `std::vector` – динамический массив с оптимизациями под случайный доступ.
- `std::list` – для частых вставок/удалений в середине.
- `std::deque` – компромисс между `vector` и `list` для двусторонних операций.