# Разработка кода, устойчивого к возникновению исключений

## Гарантии безопасности исключений и устойчивый код в C++

## 1. Гарантии безопасности исключений

В C++ существует три уровня гарантий безопасности исключений:

### 1.1 Базовая гарантия (Basic Guarantee)
- **Суть**: При возникновении исключения программа остается в согласованном состоянии
- **Обязательства**:
    - Нет утечек ресурсов
    - Все инварианты класса сохраняются
    - Объекты остаются в допустимом состоянии (хотя возможно и не в том, которое ожидалось)
- **Пример**: Стандартные контейнеры обеспечивают базовую гарантию

### 1.2 Строгая гарантия (Strong Guarantee)
- **Суть**: Если операция завершается исключением, состояние программы остается таким, как будто операция не выполнялась
- **Обязательства**:
    - Либо операция завершается успешно
    - Либо состояние программы не изменяется
- **Пример**: `std::vector::push_back` (при условии, что перемещающие операции noexcept)

### 1.3 Гарантия отсутствия исключений (No-throw Guarantee)
- **Суть**: Операция никогда не генерирует исключений
- **Обязательства**:
    - Функция помечена как `noexcept`
    - Гарантированно завершается успешно
- **Пример**: Деструкторы должны обеспечивать эту гарантию

## 2. Принципы написания устойчивого к исключениям кода

1. **Используйте RAII** для управления ресурсами
2. **Минимизируйте изменения состояния** до завершения операций
3. **Разделяйте операции** на две фазы:
    - Подготовка (может генерировать исключения)
    - Фиксация (не должна генерировать исключения)
4. **Избегайте указателей** в пользу умных указателей
5. **Обеспечьте безопасность базовых операций** (конструкторов, деструкторов, операторов присваивания)
6. **Документируйте гарантии** для каждой функции

## 3. Идиома RAII (Resource Acquisition Is Initialization)

**Суть**: Получение ресурса должно происходить в конструкторе, а освобождение - в деструкторе.

```cpp
class FileHandle {
    FILE* file;
public:
    explicit FileHandle(const char* filename) : file(fopen(filename, "r")) {
        if (!file) throw std::runtime_error("File open failed");
    }
    
    ~FileHandle() { if (file) fclose(file); }
    
    // Запрещаем копирование
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // Разрешаем перемещение
    FileHandle(FileHandle&& other) noexcept : file(other.file) {
        other.file = nullptr;
    }
    
    void readData() { /* ... */ }
};

void processFile() {
    FileHandle f("data.txt");  // Ресурс автоматически освободится
    f.readData();
}  // Деструктор вызывается автоматически
```

**Преимущества RAII**:
- Автоматическое освобождение ресурсов
- Упрощение кода (нет необходимости в явном освобождении)
- Безопасность при исключениях

## 4. Обеспечение строгой гарантии безопасности

**Техники**:
1. **Copy-and-Swap**: Создаем копию, модифицируем ее, затем обмениваем с оригиналом
2. **Отложенные изменения**: Сначала выполняем все операции, которые могут бросить исключение, затем применяем изменения

### Пример с Copy-and-Swap:

```cpp
class String {
    char* data;
    size_t size;
    
    void swap(String& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
    
public:
    String& operator=(const String& other) {
        String temp(other);  // Может бросить исключение
        swap(temp);         // Не бросает исключений
        return *this;
        // temp уничтожается, освобождая старые ресурсы
    }
    
    // ...
};
```

## 5. Определение уровня безопасности функции

Анализируйте функцию по следующим критериям:

1. **Бросает ли она исключения?** Если нет - no-throw гарантия
2. **Изменяет ли состояние объекта?** Если нет - строгая гарантия
3. **Сохраняются ли инварианты при исключении?** Если да - базовая гарантия

Пример анализа:

```cpp
void Stack::push(const T& value) {
    if (size == capacity) {
        // Может бросить исключение, но старые данные не изменены
        reserve(capacity * 2);  // Базовая гарантия
    }
    // Не бросает исключений
    data[size++] = value;      // Строгая гарантия
}
```

Итого: `push` обеспечивает строгую гарантию, если `reserve` обеспечивает строгую гарантию.

## 6. Пример преобразования небезопасного кода

### Небезопасный код:

```cpp
class Connection {
    Socket* socket;
    Data* buffer;
public:
    void sendMessage(const Message& msg) {
        delete[] buffer;           // 1. Освобождаем старый буфер
        buffer = new Data[msg.size()]; // 2. Может бросить исключение
        socket->write(msg.data());  // 3. Может бросить исключение
    }
};
```

**Проблемы**:
- Если исключение в пункте 2: утечка ресурсов (buffer уже удален)
- Если исключение в пункте 3: buffer изменен, но сообщение не отправлено

### Строгая гарантия (используем RAII и Copy-and-Swap):

```cpp
void Connection::sendMessage(const Message& msg) {
    std::unique_ptr<Data[]> newBuffer(new Data[msg.size()]); // 1. RAII
    socket->write(msg.data());                               // 2. Может бросить
    buffer = newBuffer.release();                           // 3. No-throw
}
```

### Альтернативный вариант (разделение на фазы):

```cpp
void Connection::prepareSend(const Message& msg) {
    delete[] buffer;
    buffer = new Data[msg.size()];  // Может бросить
}

void Connection::commitSend(const Message& msg) noexcept {
    socket->write(msg.data());      // Не должен бросать
}

// Использование:
try {
    conn.prepareSend(msg);
    conn.commitSend(msg);
} catch (...) {
    // Состояние либо не изменилось, либо полностью обновлено
}
```

## Заключение

1. **Всегда начинайте с базовой гарантии** - это минимальный уровень безопасности
2. **Стремитесь к строгой гарантии** там, где это возможно
3. **Деструкторы и перемещающие операции должны быть noexcept**
4. **Используйте RAII** для автоматического управления ресурсами
5. **Документируйте гарантии** для каждой публичной функции

Правильно спроектированная система исключений делает код более надежным и безопасным, особенно в сложных сценариях обработки ошибок.