# Шаблоны функций

### 1. Как объявить шаблон функции?
Шаблон функции в C++ объявляется с помощью ключевого слова `template`, за которым следует список параметров шаблона в угловых скобках `<>`.

**Синтаксис:**
```cpp
template <typename T>  // или template <class T>
void myFunction(T param) {
    // тело функции
}
```  
- `typename T` (или `class T`) — параметр шаблона, обозначающий тип.
- Можно использовать несколько параметров:
  ```cpp
  template <typename T1, typename T2>
  void foo(T1 a, T2 b) { ... }
  ```  

**Пример:**
```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```  

---

### 2. Может ли шаблонная функция не иметь аргументов?
**Да**, шаблонная функция может не иметь аргументов, если тип используется внутри функции (например, для возвращаемого значения или локальных переменных).

**Пример:**
```cpp
template <typename T>
T generateDefault() {
    return T();  // возвращает значение по умолчанию для типа T
}
```  
**Вызов:**
```cpp
int x = generateDefault<int>();  // явное указание типа
```  

---

### 3. Что может использоваться в качестве параметров шаблона?
Параметрами шаблона могут быть:
1. **Типы** (`typename T`, `class T`).
2. **Значения** (целочисленные, указатели, ссылки).
3. **Шаблоны** (шаблонные шаблонные параметры).

**Примеры:**

#### a) Типы:
```cpp
template <typename T>
void print(T value) { ... }
```  

#### b) Значения:
```cpp
template <int N>
void printArray() {
    int arr[N];  // массив размера N
}
```  

#### c) Указатели/ссылки:
```cpp
template <const char* str>
void printMessage() {
    std::cout << str;
}
```  

#### d) Шаблонные шаблонные параметры:
```cpp
template <template <typename> class Container, typename T>
void process(Container<T>& c) { ... }
```  

---

### 4. Для чего используется специализация шаблонов функций?
Специализация позволяет предоставить отдельную реализацию шаблона для конкретного типа или набора параметров, когда общий шаблон не подходит.

**Пример:**
```cpp
// Общий шаблон
template <typename T>
void print(T value) {
    std::cout << "Общий шаблон: " << value << std::endl;
}

// Специализация для типа const char*
template <>
void print<const char*>(const char* value) {
    std::cout << "Специализация для строки: " << value << std::endl;
}
```  
**Вызов:**
```cpp
print(10);               // Общий шаблон: 10
print("Hello, world!");  // Специализация для строки: Hello, world!
```  

---

### 5. Как объявить специализацию шаблонной функции?
Специализация объявляется с помощью `template<>`, затем указывается сигнатура функции с конкретными типами.

**Синтаксис:**
```cpp
template <>
ReturnType FunctionName<SpecificType>(Parameters) { ... }
```  

**Пример:**
```cpp
template <>
void print<int>(int value) {
    std::cout << "Специализация для int: " << value << std::endl;
}
```  

---

### 6. Может ли специализация шаблонной функции сама быть шаблоном?
**Да**, если специализация частичная (только для классов, **но не для функций!**).

**Для функций:**
- Полная специализация — да.
- Частичная специализация — **нет** (только перегрузка).

**Пример полной специализации с шаблоном:**
```cpp
template <typename T>
void foo(T a) { ... }

// Специализация для std::vector любого типа
template <typename U>
void foo<std::vector<U>>(std::vector<U> vec) { ... }  // Ошибка! Так нельзя.
```  
**Вместо этого используется перегрузка:**
```cpp
template <typename U>
void foo(std::vector<U> vec) { ... }  // Это перегрузка, а не специализация.
```  

---

### 7. Как объявляются шаблонные операторы?
Шаблонные операторы объявляются так же, как шаблонные функции, но с синтаксисом оператора.

**Пример шаблонного оператора `+`:**
```cpp
template <typename T>
class MyBox {
    T value;
public:
    MyBox(T v) : value(v) {}
    
    // Шаблонный оператор +
    template <typename U>
    auto operator+(const MyBox<U>& other) const {
        return MyBox<decltype(value + other.value)>(value + other.value);
    }
};
```  

**Пример шаблонного оператора вывода `<<`:**
```cpp
template <typename T>
std::ostream& operator<<(std::ostream& os, const MyBox<T>& box) {
    os << box.getValue();
    return os;
}
```  

**Использование:**
```cpp
MyBox<int> a(5), b(10);
auto c = a + b;  // MyBox<int>(15)
std::cout << c;  // 15
```  

---

### Итог:
1. Шаблон функции объявляется через `template <typename T>`.
2. Шаблонная функция может не иметь аргументов.
3. Параметры шаблона: типы, значения, шаблоны.
4. Специализация нужна для особых случаев.
5. Специализация объявляется через `template<>`.
6. Специализация функции не может быть частичным шаблоном (только полная).
7. Шаблонные операторы объявляются как шаблонные методы или функции.

Если нужны дополнительные нюансы — спрашивайте!