# Наследование

- Концепция, при которой новый абстрактный тип данных наследует данные и функциональность существующего типа
- Способствует повторному использованию кода
- Расширение функционала за счёт добавления новых данных и/или операций
- Позволяет строить иерархии классов

```c++
struct Point {
  double x = 0, y = 0;
};

class GameObject {
public:
  Point GetPosition() const { return m_position; }
  void SetPosition(Point pos) { m_position = pos; }
private:
  Point m_position;
};

struct Vector {
  double dx = 0, dy = 0;
};

class Rocket : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) {
    auto pos = GetPosition();
    pos.x += m_speed.dx * timeDelta;
    pos.y += m_speed.dy * timeDelta;
    SetPosition(pos);
  }
private:
  Vector m_speed;
};

int main() {
  Rocket r;
  r.SetSpeed({.dx = 10, .dy = 20});
  r.Update(1);
  auto pos = r.GetPosition();
  std::cout << pos.x << ", " << pos.y << "\n";
}
```

## 1. Смысл отношения наследования.
Наследование — это механизм, позволяющий создавать новый класс (производный) на основе существующего (базового), заимствуя его структуру и поведение.

Основные цели:
- Повторное использование кода (наследование методов и полей).
- Расширение функциональности (добавление новых методов/полей в производном классе).
- Полиморфизм (возможность переопределения методов для разных классов в иерархии).

```c++
class Animal {
public:
    void eat() { std::cout << "Eating...\n"; }
};

class Dog : public Animal {  // Dog наследует Animal
public:
    void bark() { std::cout << "Barking!\n"; }
};
```

---

## 2. Что такое базовый, родительский и производный классы?
- Базовый (родительский) класс — класс, от которого происходит наследование (Animal в примере выше).
- Производный (дочерний) класс — класс, который наследует свойства базового (Dog).

Синонимы:
- Базовый = родительский = суперкласс (в некоторых языках).
- Производный = дочерний = подкласс.

---

## 3. Обозначение наследования на диаграммах классов.
- Сплошная линия со стрелкой (от производного к базовому классу).
- Стрелка — пустой треугольник.

```c++
[Производный] ——▷ [Базовый]
[Dog] ——▷ [Animal]
```

---

## 4. Вызов конструкторов и деструкторов при наследовании.
- Конструкторы: Вызываются от базового к производному.
- Деструкторы: Вызываются от производного к базовому.

Порядок вызова:
- Конструктор базового класса.
- Конструкторы полей производного класса (в порядке объявления).
- Конструктор производного класса.

```c++
class Base {
public:
    Base() { std::cout << "Base constructor\n"; }
    ~Base() { std::cout << "Base destructor\n"; }
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived constructor\n"; }
    ~Derived() { std::cout << "Derived destructor\n"; }
};

// При создании Derived:
// Base constructor → Derived constructor
// При уничтожении:
// Derived destructor → Base destructor
```

---

## 5. Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
### Публичное наследование
- Производный класс наследует доступ ко всем членам базового класса, за исключением приватных.
- Объект производного класса может быть приведён к типу базового класса, что позволяет использовать объекты производного класса там, где ожидается объект базового класса.
- При создании объекта производного класса сначала вызывается конструктор базового класса, затем конструктор производного. Деструкторы вызываются в обратном порядке.

Применяется в большинстве случаев наследования в C++. Позволяет расширять базовый класс новыми функциями или данными.

### Приватное наследование
- Публичные и защищённые члены базового класса становятся приватными в производном классе.
- К приватным членам базового класса нельзя получить прямой доступ из производного класса, но их можно использовать внутри функций-членов производного класса.
- Интерфейс базового класса не наследуется, но его реализация — да.
  
Применяется в ситуациях, когда нужно ограничить доступ к некоторым методам базового класса или переопределить виртуальные функции.

### Защищённое наследование
- Все открытые члены базового класса наследуются как защищённые в производном классе.
- К защищённым членам можно получить доступ только из производного класса, но не извне.
- Если у производного класса будут свои классы-наследники, то в этих классах также можно обращаться к защищённым членам базового класса.

Применяется в редких случаях, например, когда нужно защитить определённые элементы базового класса от внешней части программы, но при этом обеспечить доступ к ним из производных классов.

---

## 6. К каким полям и методам класса может иметь доступ класс-наследник?
Зависит от типа наследования и модификаторов доступа в базовом классе:

public-наследование:
- public → public,
- protected → protected,
- private → недоступен.

protected-наследование:
- public и protected → protected,
- private → недоступен.

private-наследование:
- Все члены базового класса → private.

Важно:
- private-члены базового класса никогда не доступны в производном (даже через protected/private наследование).

---

## 7. В каком случае возможно приведение типа вверх по иерархии классов. Как влияет тип наследования на приведение типа по иерархии наследования?
Приведение вверх (upcast): Преобразование Derived* → Base* (всегда безопасно).

Влияние типа наследования:
- public-наследование: Позволяет неявное приведение.
- private/protected-наследование: Требует явного приведения (static_cast).

```c++
class Base {};
class Derived : public Base {};

Base* b = new Derived;  // OK (public-наследование)

class PrivateDerived : private Base {};
Base* b2 = new PrivateDerived;  // Ошибка! Требуется static_cast.
```

---

## 8. Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
Если метод в производном классе имеет то же имя и сигнатуру, что и в базовом:
- Он переопределяет метод базового класса (если он virtual).
- Иначе — скрывает его (см. пункт 9).

```c++
class Base {
public:
    virtual void foo() { std::cout << "Base::foo\n"; }
};

class Derived : public Base {
public:
    void foo() override { std::cout << "Derived::foo\n"; }  // Переопределение
};
```

---

## 9. Как класс-наследник может вызвать одноименный метод своего родителя?
Используйте оператор разрешения области видимости (::):

```c++
class Derived : public Base {
public:
    void foo() {
        Base::foo();  // Вызов метода базового класса
        std::cout << "Derived::foo\n";
    }
};
```

Для конструкторов:
```c++
Derived::Derived() : Base() { /* ... */ }  // Явный вызов конструктора базового класса
```

---

## 10. Чем отличается class X final { /*...*/ }; от class X { /*...*/ };. Когда следует объявлять класс или структуру финальной?
Разница между  class X final { /*...*/ };  и  class X { /*...*/ };  заключается в ограничении наследования и переопределения.
- Класс, объявленный как final, нельзя расширить (наследовать). Любая попытка создать подкласс от такого класса вызывает ошибку компиляции.
- Метод, объявленный как final, нельзя переопределить в подклассах. Это полезно, когда необходимо, чтобы логика метода осталась неизменной во всех производных классах.
- Переменную, объявленную как final, нельзя изменить после инициализации. Это делает её константой.

  `class X final { ... };` запрещает наследование от X.

  `virtual void foo() final;` запрещает переопределение метода в производных классах.

Когда использовать?
- Для оптимизации (компилятор может удалить виртуальную таблицу).
- Для защиты от непреднамеренного расширения (например, класс-утилита).

```c++
class NoInheritance final {};
class Error : public NoInheritance {};  // Ошибка компиляции
```

---

## 11. Как в функцию void F(Base&) передать ссылку на объект класса class Derived : private Base {...};?
Если наследование private, приведение Derived → Base запрещено без явного указания:

Решение:
- Использовать public-наследование (если возможно).
- Или добавить в Derived метод для явного преобразования:


```c++
class Derived : private Base {
public:
    Base& asBase() { return *this; }  // Явное приведение
};

void F(Base& b) {}

int main() {
    Derived d;
    F(d.asBase());  // OK
}
```

Чтобы передать ссылку на объект класса Derived в функцию void F(Base&), нужно привести тип объекта к Base. 

Это позволяет использовать ссылку на базовый класс для указания на объект производного класса, при этом компилятор не требует явного приведения типов.

```c++
class Derived : private Base { ... };  

void F(Base& base) {  
    // ...  
}  

int main() {  
    Derived d;  
    Base& base = derived;  
    F(base);  // Вызывает метод базового класса, так как base указывает на объект Derived  
}  
```

