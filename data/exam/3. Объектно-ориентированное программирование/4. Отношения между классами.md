# Отношения между классами

## 1. Отношение композиции. Обозначение композиции на диаграмме классов.
Композиция — это строгий вид отношения «часть-целое», где:
- Часть не может существовать без целого.
- Уничтожение целого влечёт уничтожение всех его частей.

Обозначение на UML-диаграмме:
- Сплошная линия с закрашенным ромбом со стороны целого.
```c++
[Целое] ◆—— [Часть]
```


---

## 2. Как композиция реализуется в C++?
Композиция реализуется через полное владение объектом-частью:
- Часть создаётся и уничтожается внутри класса-целого.
- Обычно хранится по значению или через std::unique_ptr.

```c++
class Engine {
public:
    void start() { std::cout << "Engine started\n"; }
};

class Car {
private:
    Engine engine_;  // Композиция: двигатель - часть автомобиля
public:
    void startCar() { engine_.start(); }
};

// Использование:
Car car;
car.startCar();  // Двигатель существует только пока существует Car
```

Особенности:
- Если Car уничтожается, Engine тоже автоматически уничтожается.
- Нет необходимости в ручном управлении памятью.


---

## 3. Отношение агрегации. Обозначение агрегации на диаграмме классов.
Агрегация — это слабый вид отношения «часть-целое», где:
- Часть может существовать независимо от целого.
- Уничтожение целого не влечёт уничтожение частей.

Обозначение на UML-диаграмме:
- Сплошная линия с пустым ромбом со стороны целого.
```c++
[Целое] ◇—— [Часть]
```

---

## 4. Как агрегация реализуется в C++?
Агрегация реализуется через хранение указателей или ссылок на объекты, которые создаются вне класса-целого.

```c++
class Student {
public:
    void study() { std::cout << "Studying...\n"; }
};

class University {
private:
    std::vector<Student*> students_;  // Агрегация: студенты могут существовать без университета
public:
    void addStudent(Student* student) { students_.push_back(student); }
};

// Использование:
Student student;
University uni;
uni.addStudent(&student);  // Student передан извне
```

- Университет не управляет временем жизни студентов.
- Можно использовать std::shared_ptr, если нужно разделяемое владение.

---

## 5. Чем композиция отличается от агрегации?
Композиция:
- Часть не существует без целого.
- Уничтожение целого → уничтожение частей.
- Ромб закрашен.
- Реализация: объект по значению или unique_ptr.

Агрегация:
- Часть может существовать отдельно.
- Уничтожение целого не затрагивает части.
- Ромб пустой.
- Реализация: сырые указатели, ссылки, shared_ptr.


- Композиция: Дом и Комната (комнаты не могут быть без дома).
- Агрегация: Библиотека и Книга (книги могут существовать без библиотеки).

---

## 6. Зависимость. Обозначение зависимости на диаграмме классов.
Зависимость — временное отношение, где один класс использует другой в течение выполнения операции, но не хранит его как поле.

Обозначение на UML:
- Пунктирная стрелка от зависимого класса к используемому.
```c++
[Класс A] ╌╌> [Класс B]
```

Метод draw() класса Canvas принимает объект Shape, но не хранит его.


---

## 7. Транзитивность зависимостей.
Если:
- Класс A зависит от B,
- Класс B зависит от C,
- то A косвенно зависит от C.

```c++
class C {};
class B { void foo(C c) {} };  // B зависит от C
class A { void bar(B b) {} };  // A зависит от B (и транзитивно от C)
```



---

## 8. Чем зависимость отличается от агрегации и композиции?
Зависимость:
- Время связи: Временная (вызов метода, параметр).
- Влияние на жизнь объекта:	Нет.
- UML-обозначение:	Пунктирная стрелка.

Агрегация/Композиция:
- Время связи: Постоянная (поле класса).
- Влияние на жизнь объекта:	Композиция: управляет временем жизни.
- UML-обозначение:	Сплошная линия с ромбом.

```c++
class Logger {
public:
    void log(const std::string& message) { /* ... */ }  // Зависимость от std::string
};
```

---

## 9. Когда применять зависимость, когда агрегацию, а когда композицию?
Композиция:
- Если часть не имеет смысла без целого (например, Сердце и Человек).
- Если время жизни частей должно совпадать с жизнью целого.

Агрегация:
- Если часть может принадлежать разным целым или существовать самостоятельно (например, Преподаватель и Кафедра).
- Если целое только «ссылается» на часть (например, Автомобиль и Водитель).

Зависимость:
- Если класс использует другой класс временно (например, передача объекта в метод).
- Для уменьшения связности (например, Сервис принимает Logger в методе, но не хранит его).

```c++
// Композиция
class Brain {};
class Human {
    Brain brain_;  // Человек не может существовать без мозга
};

// Агрегация
class Wheel {};
class Car {
    std::vector<Wheel*> wheels_;  // Колёса могут быть заменены или существовать отдельно
};

// Зависимость
class Printer {
public:
    void print(const Document& doc) { /* ... */ }  // Printer не владеет Document
};
```