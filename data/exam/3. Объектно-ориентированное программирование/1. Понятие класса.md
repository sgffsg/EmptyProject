# Понятие класса


## 1. Что такое класс
- В ООП вводится понятие Класса – пользовательского типа данных, объединяющего данные и методы их обработки
    - Класс – тип, описывающий устройство объекта
- Объектом называется экземпляр класса
    - Собака – это класс
    - Собака Жучка из 3 подъезда – это объект, представитель или экземпляр класса «Собака»
    - Чертеж дома – класс, построенный по нему дом - объект

- Класс в C++ - это пользовательский тип данных, который объединяет данные (поля) и функции (методы) для работы с этими данными в одной логической единице. 
- Класс является основой объектно-ориентированного программирования в C++ и позволяет реализовать такие принципы как инкапсуляция, наследование и полиморфизм.




---

## 2. Объявление класса в C++
```c++
class Car
{
  // Поля класса (данные и методы)
};

// Использование класса
int main()
{
  Car car1;
  Car car2;
}
```

---

## 3. Проблемы прямого доступа к данным класса. Инкапсуляция.
Прямой доступ к данным класса (полям) извне может привести к нескольким проблемам:
- Нарушение инвариантов класса: внешний код может установить некорректные значения (например, отрицательную ширину прямоугольника)
- Сложность модификации: если позже потребуется изменить способ хранения данных, придется менять весь код, который напрямую обращается к полям
- Отсутствие контроля: невозможно отследить, когда и кто изменяет данные


- Инкапсуляция - это принцип ООП, который предполагает сокрытие внутренней реализации класса и предоставление строго определенного интерфейса для работы с ним. В C++ инкапсуляция реализуется через модификаторы доступа (private, protected, public).

Хорошей практикой считается делать поля класса private и предоставлять доступ к ним через методы (геттеры и сеттеры), если это необходимо.

---

## 4. Методы класса
- Вместо прямого доступа к своим данным класс предоставляет методы
- Метод – функция, объявленная внутри класса или структуры
  - Методы также называют функциями-членами класса (class member functions)
- Методы класса задают операции, которые можно выполнить над объектом
- В классах методы делают публичными, а данные – приватными

### Объявление метода класса
```c++
class SomeClass {
public:
  // Это метод класса. Выглядит как функция, описанная внутри класса.
  void SetData(int data) {
    // К приватным данным можно обращаться только внутри методов класса.
    m_data = data;
  }

private:
  // Данные надёжно спрятаны от внешнего мира.
  // Никто, кроме самого класса, не имеет к ним доступа.
  int m_data = 42;
};
```

```c++
class Time
{
public:
  int GetHours() { return m_secondsSinceMidnight / 3600; }
  int GetMinutes() { return (m_secondsSinceMidnight / 60) % 60; }
  int GetSeconds() { return m_secondsSinceMidnight % 60; }

  bool SetTime(int hours, int minutes, int seconds)
  {
    if (hours < 0 || hours >= 24 || minutes < 0 || minutes >= 60 
       || seconds < 0 || seconds >= 60) {
      return false;
    }

    m_secondsSinceMidnight = hours * 60 * 60 + minutes * 60 + seconds;
    return true;
  }

private:
  int m_secondsSinceMidnight = 0;
};
```

```c++
class Circle
{
public:
  void SetRadius(double r)
  {
    m_radius = r;
  }
  double GetRadius() { return m_radius; }
  double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
  double m_radius = 0;
};

int main()
{
  Circle c;
  c.SetRadius(20);
  std::cout << c.GetArea() << std::endl;
}
```

## Методы и состояние класса
- Состояние объекта формируется его членами данными
- Чтобы изменить состояние объекта, нужно изменить его данные
- Когда данные приватные, сделать это можно только в методе класса

### Как быть с константными объектами?
- Когда объект константный, его состояние должно быть нельзя изменить
- Если метод может изменить состояние объекта, значит его нельзя вызвать у константного объекта
- Как быть?

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() { return m_radius; }
    double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

## Константные методы
- Метод, внутри которого не разрешается менять состояние объекта, помечают константным с помощью спецификатора const
- Внутри const-метода нельзя менять состояние объекта
  - Присваивать значения полям класса
  - Вызывать неконстантные методы текущего объекта
  - Вызвать у поля текущего объекта неконстантный метод
  - Передать поле класса в функцию, принимающую аргумент по неконстантной ссылке
- К константных объектов разрешается вызывать только константные методы
  - То же самое касается объектов, доступных по константной ссылке

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() const { return m_radius; }
    double GetArea() const { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

---

## 5. Указатель this
- Внутри методов класса для обращения к данным и методам можно использовать их имена
- В метод класса неявно передается указатель на объект, для которого он вызывается
    - Этот указатель указатель доступен по ключевому слову this

```c++
// Структура глазами компилятора
struct Point {
    double x = 0, y = 0;

    // Первым параметром в метод передаётся неявный параметр this.
    void MoveBy(/* Point* const this, */ Vector v) {
        // При обращении к полям и методам через this вместо точки
        // используется стрелочка ->, состоящая из символов - и >.
        this->x += v.x;
        this->y += v.y;
    }
};
```

```c++
struct Point {
    double x = 0, y = 0;

    void Set(double x, double y) {
        // Область видимости параметров x и y ограничена 
        // методом Point::Set. Поэтому внутри метода Set 
        // имена x и y относятся к параметрам, а не к полям.

        // Когда мы пишем this->x и this->y, то явно сообщаем 
        // компилятору, что обращаемся к полям текущего объекта.
        this->x = x;
        this->y = y;

        // Если напишем x = x, то присвоим параметру x его собственное значение.
    }
};
```

### Когда в C++ использовать this внутри методов классов?
- Используйте this, если должны. Во всех остальных случаях не используйте
    - Не надо превращать C++ в javascript
- Когда нужно писать this?
    - Если нужно вернуть или передать ссылку или указатель на текущий объект
    - Если в шаблонном классе нужно обратиться к методу или полю базового класса, зависящему от шаблонного параметра

```c++
struct Vector
{
  double x = 0, y = 0;

  // Оператор += возвращает ссылку на текущий объект,
  // чтобы можно было использовать цепочку вызовов:
  // Vector v1, v2, v3;
  // v1 += v2 += v3;
  Vector& operator+=(Vector const& other)
  {
    x += other.x;
    y += other.y;
    
    return *this;
  }
};
```

Он используется:
- Для разрешения неоднозначности, когда имя параметра метода совпадает с именем поля класса:
```c++
void setWidth(double width) {
    this->width = width;
}
```
- Для возврата ссылки на текущий объект (часто используется в цепочках вызовов):
```c++
Rectangle& setWidth(double width) {
    this->width = width;
    return *this;
}
// Использование:
rect.setWidth(10).setHeight(20);
```

- Для передачи текущего объекта в другие функции.


---

## 6. Константные методы.

- Физическая константность
  - Объект объявлен как const
  - Его состояние не изменяется
- Логическая константность
  - Объект неизменен внешне
  - Внутреннее состояние может меняться
    - Объект может кешировать данные


##№# Изменчивые (mutable) данные класса
- Спецификатор mutable разрешает изменять поле, даже если содержащий объект объявлен константным
  - Mutable-поля можно изменять внутри константных методов
- Означает, что поле не влияет на наблюдаемое извне состояние класса
  - Мьютексы
  - Кеширование вычисленных значений
  - Ленивые вычисления

Константный метод - это метод, который не изменяет состояние объекта (не изменяет его поля). Объявляется с ключевым словом const после списка параметров:
```c++
double area() const {
    return width * height;
}
```

Особенности:
- Могут быть вызваны у константных объектов
- Не могут изменять поля класса (кроме mutable-полей)
- Могут вызывать только другие константные методы
- Обеспечивают безопасность и ясность кода

---

## 7. Статические данные и методы класса.
### Статические поля класса
- Статическое поле – общее для всех экземпляров
- Создаётся при запуске программы и уничтожается при её завершении
- Для доступа к статическому полю не нужно указывать объект
  - Можно использовать из статических методов
- Перед объявлением статического поля пишется ключевое слово static

```c++
// car.h

class Car {
public:
    …
    static bool IsSpeedValidForGear(int speed, Gear gear);
private:
    bool m_engineIsOn = false;
    int m_speed = 0;
    Gear m_gear = Gear::NEUTRAL;

    // Объявляем таблицу диапазонов скоростей статической и константной,
    // чтобы она была одна всю программу и не изменялась.
    static const std::vector<GearSpeedRange> s_speedTable;
};
```

```c++
// car.cpp
#include "car.h"

// Так объявляется статическая переменная за пределами класса.
const std::vector<GearSpeedRange> Car::s_speedTable = {
    { Gear::NEUTRAL, 0, 150 },
    { Gear::FIRST, 0, 30 },
    { Gear::SECOND, 20, 50 },
    { Gear::THIRD, 30, 70 },
    { Gear::FOURTH, 40, 100 },
    { Gear::FIFTH, 60, 150 },
    { Gear::REVERSE, 0, 30 },
};

bool Car::IsSpeedValidForGear(int speed, Gear gear) {
    for (auto& range : s_speedTable) {
        if (range.gear == gear) {
            return range.minSpeed <= speed && speed <= range.maxSpeed;
        }
    }
    return false;
}
```

### Определение статического поля внутри класса (начиная с++17)
```c++
class Car {
    
private:
    // Так статическое поле объявляется и определяется внутри класса.
    inline static const std::vector<GearSpeedRange> s_speedTable = {
        { Gear::NEUTRAL, 0, 150 },
        { Gear::FIRST, 0, 30 },
        { Gear::SECOND, 20, 50 },
        { Gear::THIRD, 30, 70 },
        { Gear::FOURTH, 40, 100 },
        { Gear::FIFTH, 60, 150 },
        { Gear::REVERSE, 0, 30 },
    };
};
```

### Статические поля в классах Стандартной Библиотеки
```c++
std::string text = "A quick brown fox jumps over the lazy dog";
std::string needle; // Иголка, которую мы будем искать в стоге сена.
std::cin >> needle; // Вводим текст для поиска.

// Метод find возвращает позицию в строке, с которой начинается искомый текст.
// Если текст не найден, возвращается значение std::string::npos.
if (const size_t foundAt = text.find(needle); foundAt != std::string::npos) {
    std::cout << needle << " is found at position " << found_at << std::endl;
} else {
    std::cout << needle << " was not found" << std::endl;
}
```

### Статические данные и методы – итоги
- Статические методы не привязаны к конкретному экземпляру класса
- Статические поля используются для хранения данных, общих для всех экземпляров класса
- Статические данные часто делают константными


---

## 8. mutable-данные класса.

- Мьютекс – примитив синхронизации, разрешающий доступ к объекту только одному из потоков
  - `std::mutex`
- Когда в классе содержится мьютекс, его практически всегда помечают mutable
- Ключевое слово mutable позволяет изменять поле в константных методах или у константных объектов:

```c++
class Cache {
private:
    mutable bool cacheValid;
    mutable double cachedValue;
    
public:
    double getValue() const {
        if (!cacheValid) {
            // Даже в константном методе можем изменять mutable-поля
            cachedValue = computeValue();
            cacheValid = true;
        }
        return cachedValue;
    }
};
```

### Используйте mutable-поля аккуратно
- Используйте mutable, чтобы обеспечить логическую константность
- Наблюдаемое состояние должно оставаться неизменным, когда объект меняет внутреннее состояние
- Не нарушайте правила доступа к константным объектам

```c++
class Mutable
{
public:
  int GetValue() const
  {
    if (m_value == -1)
    {
      m_value = 42;
    }
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Mutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Mutable::Change"
              << std::endl;
  }
private:
  mutable int m_value = -1;
  int m_counter = 0;
};
```

```c++
class Immutable
{
public:
  int GetValue() const
  {
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Immutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Immutable::Change"
              << std::endl;
  }
private:
    int m_value = 42;
    int m_counter = 0;
};
```

```c++
const Mutable mut;
const Immutable immut;

int main()
{
    std::cout << "Immutable: " << &immut << " - " << immut.GetValue() << std::endl;
    std::cout << "  Mutable: " << &mut << " - " << mut.GetValue() << std::endl;

    const_cast<Mutable&>(mut).Change();
    std::cout << mut.GetCounter() << std::endl;

    const_cast<Immutable&>(immut).Change();
    std::cout << immut.GetCounter() << std::endl;
}
```

- Спецификатор mutable разрешает изменять поле, даже если содержащий объект объявлен константным
  - Mutable-поля можно изменять внутри константных методов
- Означает, что поле не влияет на наблюдаемое извне состояние класса
  - Мьютексы
  - Кеширование вычисленных значений
  - Ленивые вычисления

---

## 9. Свойства
- Свойство – составляющая часть объекта, доступ к которой осуществляется программистом как к полю
  - При записи свойства можно выполнить валидацию или преобразование входных данных
  - При чтении свойства можно вычислить результат
- Свойства могут быть доступны на чтение, запись или на чтение и запись
- Отладчик может IDE может отображать значения свойств наравне со значениями полей
  - Getter-ы свойств не должны иметь видимых побочных эффектов
- В C++ и некоторых других языках программирования свойства, как элемент языка, отсутствуют
  - В этом случае эмулируют свойства за счёт get- и  set- методов

### Пример – свойства в языке C#
```c++
public class TimePeriod
{
    private double _seconds;

    public double Hours
    {
        get { return _seconds / 3600; }
        set
        {
            if (value < 0 || value >= 24)
                throw new ArgumentOutOfRangeException(nameof(value),
                      "The valid range is between 0 and 24.");

            _seconds = value * 3600;
        }
    }
}
```

```c++
internal class Circle
{
    private double _radius = 0;
    public double Radius
    {
        get { return _radius; }
        set
        {
            if (value < 0) throw new ArgumentException("Radius must not be negative");
            _radius = value;
        }
    }

    public double Area
    {
        get { return Radius * Radius * Math.PI; }
    }

    public Circle(double radius)
    {
         if (radius < 0) throw new ArgumentException("Radius must not be negative");
        _radius = radius;
    }
}

Circle c = new(10);
c.Radius = 3;

Console.WriteLine("Area:" + c.Area.ToString());
```

```c++
internal class Counter
{
    private int _value = 0;

    // Поле _value будет увеличиваться всякий раз, когда происходит чтение свойства Value.
    // Даже, если просматривать его под отладчиком.
    // Это может вызвать удивление.
    public int Value {  get { return _value++; } }

    // Это свойство будет долго вычисляться при просмотре под отладчиком.
    public int LongCalculation
    {
        get
        {
            int sum = 0;
            for (int i = 0; i < 1000000000; ++i)
            {
                ++sum;
            }
            return sum;
        }
    }
}
```

```c++
class Point
{
public:
  double x, y;
};
 
class Triangle
{
public:
  double GetArea() const;
  double GetPerimeter() const;
  Point GetCenter() const;
 
  void Move(double dx, double dy);
  void Scale(double sx, double sy);
  void Rotate(Point center, double angle);
 
private:
  Point m_p0, m_p1, m_p2;
};
```

---

## 10. Размещение кода класса в .h И .cpp файлах
- Общепринятой практикой является размещение объявления классов в заголовочных файлах .h, а их реализации – в файлах .cpp
  - Облегчается использование класса
  - Легко найти класс
- Каждый класс может быть подключен для дальнейшего использования при помощи директивы #include "имя заголовочного файла"
  - При внесении изменений в реализацию метода класса перекомпиляции подвергнутся только измененные файлы


---

## 11. Чем класс отличается от структуры? Когда использовать структуры, а когда классы?
В C++ класс и структура почти идентичны. Единственное различие - уровень доступа по умолчанию:
- В классе по умолчанию private
- В структуре по умолчанию public

Исторически сложилось несколько соглашений об использовании:
- Структуры используют для простых агрегатов данных без сложного поведения (например, точка с координатами)
- Классы используют для сложных объектов с инкапсуляцией и поведением

- Однако это лишь соглашение - технически вы можете использовать любой из этих типов для любых целей.

---

## 12. Модификаторы уровня доступа к содержимому классов
- Public-методы и данные класса определяют его интерфейс
  - доступ к ним возможен из любой части кода
  - Public-область определяет то, как класс может использоваться пользователями класса
- Размещайте в публичной области класса только необходимый набор операций высокого уровня
- Вызов public-метода должен переводить объект из одного валидного состояния в другое валидное состояние, либо не менять состояние объекта
- Публичные данные – чаще всего, плохая практика
  - Класс сам должен управлять своими данными

### Закрытые (приватные) поля и методы класса
- Private-данные и методы класса определяют его реализацию
  - Доступ разрешен только из методов этого класса
- Рекомендуется все данные класса делать закрытыми, их обработку осуществлять внутри методов
- Закрытые методы класса обычно используются публичными и защищенными методами, решая внутренние задачи класса
  - Если приватный метод не используется, удалите его

```c++
class Time {
public:
    … 
    bool Set(int hours, int minutes, int seconds) {
        if (hours < 0 || hours >= 24 || minutes < 0
            || minutes >= 60 || seconds < 0 || seconds >= 60) {
            return false;
        }

        // Вызываем приватный метод.
        SetUnchecked(hours, minutes, seconds);
        return true;
    }

    void SetMidnight() {
        SetUnchecked(0, 0, 0);
    }

private:
    // Приватный метод. Устанавливает время, не проверяя аргументы.
    void SetUnchecked(int hours, int minutes, int seconds) {
        m_seconds = (hours * 60 + minutes) * 60 + seconds;
        return ;
    }

    int m_seconds = 0;
};
```

### Защищенные поля класса
- Protected-данные и методы определяют интерфейс для производных классов
  - Доступ к ним разрешен изнутри методов данного класса и всех его потомков
- В защищенной зоне размещают методы, которые не должны быть видны снаружи класса, но реализация которых может быть переопределена или использована производными классами
