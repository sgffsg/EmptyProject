# Полиморфизм

### **Виртуальные методы в C++**

#### **1. Что такое виртуальные методы и для чего они нужны? Чем отличаются виртуальные методы от невиртуальных?**
**Виртуальные методы** – это функции-члены класса, которые позволяют реализовать **полиморфизм времени выполнения** (динамическое связывание). Они объявляются с ключевым словом `virtual`.

**Отличия виртуальных методов от невиртуальных:**  
| Характеристика | Виртуальный метод | Невиртуальный метод |
|---------------|------------------|---------------------|
| **Связывание** | Динамическое (во время выполнения) | Статическое (во время компиляции) |
| **Переопределение** | Можно переопределить в производном классе | Переопределение скрывает метод базового класса |
| **Вызов через указатель/ссылку** | Вызывается версия производного класса | Вызывается версия базового класса |
| **Таблица виртуальных методов (vtable)** | Есть | Нет |
| **Накладные расходы** | Есть (доп. косвенный вызов) | Нет |

**Пример:**
```cpp
class Base {
public:
    virtual void show() { cout << "Base\n"; }  // Виртуальный метод
    void print() { cout << "Base print\n"; }   // Невиртуальный метод
};

class Derived : public Base {
public:
    void show() override { cout << "Derived\n"; }  // Переопределение
    void print() { cout << "Derived print\n"; }   // Скрытие (не переопределение)
};

int main() {
    Base* b = new Derived();
    b->show();  // "Derived" (виртуальный вызов)
    b->print(); // "Base print" (невиртуальный вызов)
    delete b;
    return 0;
}
```

---

#### **2. Как переопределить виртуальную функцию в производном классе?**
Для переопределения виртуальной функции в производном классе нужно:
1. Объявить функцию с тем же именем и сигнатурой.
2. Использовать `override` (начиная с C++11) для явного указания переопределения.

**Пример:**
```cpp
class Base {
public:
    virtual void func() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    void func() override { cout << "Derived\n"; }  // Явное переопределение
};
```

**Почему `override` полезен?**
- Позволяет компилятору проверить, что метод действительно переопределяет виртуальную функцию.
- Защищает от ошибок (например, опечаток в сигнатуре).

---

#### **3. Для чего в C++ деструктор объявляется виртуальным? В каких случаях деструктор не нужно объявлять виртуальным?**
**Вирутальный деструктор** нужен, чтобы при удалении объекта через указатель на базовый класс вызывался **правильный деструктор** (производного класса).

**Пример проблемы без виртуального деструктора:**
```cpp
class Base {
public:
    ~Base() { cout << "Base dtor\n"; }  // Не виртуальный!
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived dtor\n"; }
};

int main() {
    Base* b = new Derived();
    delete b;  // Вызовется только ~Base() → утечка ресурсов!
    return 0;
}
```

**Решение:**
```cpp
virtual ~Base() { cout << "Base dtor\n"; }  // Теперь вызовется и ~Derived()
```

**Когда деструктор не нужно делать виртуальным?**
- Если класс **не предназначен** для наследования.
- Если класс **не содержит виртуальных методов** (значит, он не полиморфный).
- В **final-классах** (C++11 и выше).

---

#### **4. Особенности вызова виртуальных функций в конструкторе и деструкторе класса**
В **конструкторе** и **деструкторе** виртуальные функции ведут себя **как невиртуальные** – вызывается версия текущего класса, а не производного.

**Причина:**
- В конструкторе производный класс ещё не полностью инициализирован.
- В деструкторе производный класс уже частично разрушен.

**Пример:**
```cpp
class Base {
public:
    Base() { callVirtual(); }
    virtual ~Base() { callVirtual(); }
    virtual void callVirtual() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    void callVirtual() override { cout << "Derived\n"; }
};

int main() {
    Derived d;  // В конструкторе Base: "Base" (не "Derived"!)
    return 0;   // В деструкторе Base: снова "Base"
}
```

---

#### **5. Спецификатор `override`**
**Для чего?**
- Явно указывает, что метод переопределяет виртуальную функцию.
- Позволяет компилятору проверить корректность переопределения.

**Пример ошибки:**
```cpp
class Base {
public:
    virtual void foo(int) {}
};

class Derived : public Base {
public:
    void foo(float) override {}  // Ошибка: сигнатура не совпадает!
};
```

---

#### **6. Спецификатор `final`**
**Для чего?**
- Запрещает дальнейшее переопределение метода.
- Запрещает наследование от класса.

**Пример:**
```cpp
class Base {
public:
    virtual void foo() final {}  // Больше нельзя переопределять
};

class Derived : public Base {
    void foo() override {}  // Ошибка: метод final!
};

class FinalClass final {};  // Нельзя наследовать
class TryInherit : FinalClass {};  // Ошибка!
```

---

#### **7. Может ли конструктор быть виртуальным?**
**Нет**, потому что:
- Виртуальные функции требуют наличия объекта (vtable), но конструктор **создает** объект.
- Это логически бессмысленно, так как тип объекта известен на этапе компиляции.

---

#### **8. Что такое полиморфизм?**
**Полиморфизм** – это возможность использовать объекты разных классов через единый интерфейс.

**Виды полиморфизма в C++:**
1. **Полиморфизм времени выполнения** (через виртуальные функции).
2. **Параметрический полиморфизм** (шаблоны).
3. **Ad-hoc полиморфизм** (перегрузка функций).

---

#### **9. Абстрактный класс**
**Абстрактный класс** – это класс, содержащий хотя бы одну **чистую виртуальную функцию** (`= 0`).

**Для чего нужен?**
- Задать интерфейс без реализации.
- Запретить создание экземпляров.

**Пример:**
```cpp
class Abstract {
public:
    virtual void foo() = 0;  // Чистая виртуальная функция
};

class Concrete : public Abstract {
public:
    void foo() override {}  // Обязательная реализация
};

int main() {
    // Abstract a;  // Ошибка: абстрактный класс
    Concrete c;     // OK
    return 0;
}
```

---

#### **10. Интерфейс в C++**
В C++ нет отдельного понятия "интерфейс", но его можно эмулировать с помощью **абстрактного класса без полей и с чисто виртуальными методами**.

**Пример:**
```cpp
class IPrintable {
public:
    virtual void print() = 0;
    virtual ~IPrintable() = default;  // Виртуальный деструктор
};

class Document : public IPrintable {
public:
    void print() override { cout << "Printing document\n"; }
};
```

---

#### **11. Отличие абстрактного класса от интерфейса**
| Характеристика | Абстрактный класс | Интерфейс |
|---------------|------------------|-----------|
| **Поля** | Может иметь | Только константы (`static const`) |
| **Методы** | Может иметь реализацию | Только чистые виртуальные |
| **Наследование** | Может наследовать другой класс | Только интерфейсы |
| **В C++** | Класс с `= 0` | Абстрактный класс без полей |

---

#### **12. Как наследование позволяет реализовывать полиморфизм времени выполнения?**
Через:
1. **Указатели/ссылки на базовый класс**, которые могут ссылаться на объекты производных классов.
2. **Виртуальные функции**, которые вызываются в зависимости от реального типа объекта.

**Пример:**
```cpp
Base* obj = new Derived();
obj->foo();  // Вызовется Derived::foo(), если она виртуальна
```

---

#### **13. Реализация виртуальных функций в компиляторах**
Обычно через:
1. **Таблицу виртуальных методов (vtable)** – массив указателей на функции.
2. **Указатель на vtable (vptr)** – добавляется в каждый объект.

**Пример:**
```
Объект Derived:
+---------+
| vptr    | → [ &Base::foo, &Derived::bar ]
+---------+
| данные  |
+---------+
```

---

#### **14. `dynamic_cast` и приведение типа вниз по иерархии**
**`dynamic_cast`** – это безопасное приведение типа, которое работает **только с полиморфными классами** (имеющими виртуальные функции).

**Пример:**
```cpp
Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);  // OK
if (d) { /* Успешное приведение */ }

Base* b2 = new Base();
Derived* d2 = dynamic_cast<Derived*>(b2);  // nullptr (не удалось)
```

**Особенности:**
- Работает только с указателями/ссылками.
- Для ссылок кидает `std::bad_cast` при ошибке.
- Требует **RTTI (Run-Time Type Information)**.

---

### **Итог**
- Виртуальные методы нужны для **полиморфизма**.
- Деструктор должен быть виртуальным, если класс полиморфный.
- `override` и `final` улучшают безопасность кода.
- Абстрактные классы и интерфейсы задают контракты для наследования.
- `dynamic_cast` позволяет безопасно приводить типы.

Если нужны дополнительные нюансы – спрашивайте!