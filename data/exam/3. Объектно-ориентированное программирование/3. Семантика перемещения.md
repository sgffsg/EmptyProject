# Семантика перемещения

## 1. Перемещающий конструктор
Перемещающий конструктор (move constructor) — это специальный конструктор класса, который позволяет эффективно передавать ресурсы из одного объекта в другой, избегая глубокого копирования.

### Проблемы с копированием объектов
- Проблемы с производительностью
    - Избыточное создание временных объектов
        - Оптимизатор не всегда справляется
    - Создание копий «тяжелых» объектов может сильно ударить по производительности
- Не для всех типов объектов имеет смысл семантика копирования
    - fstream, thread, mutex
    - В то же время может быть необходима семантика перемещения содержимого от одного объекта к другому

```c++
class Student {
public:
    explicit Student(const std::string& name)
        : m_name(name)
    {
    }

    const std::string& GetName() const
    {
        return m_name;
    }

private:
    std::string m_name;
};

int main()
{
    // Создаст временную строку из строкового литерала string,
    // а потом в конструкторе копирования скопирует её в m_name
    Student student("Ivan");
}
```

### Избыточное копирование объектов
- В приведенном примере конструктор std::string будет вызван дважды
    - Для создания временного объекта std::string из строкового литерала
    - Для копирования параметра name в поле m_name
- C++11 это позволяет за счет нового типа ссылок на rvalue
    - Все контейнеры STL в стандарте C++11 поддерживают семантику перемещения своих элементов при копировании и присваивании

### Что такое Rvalue и Lvalue?
- Название термина происходит от синтаксиса операции присваивания во многих языках программирования:
    - <выражение1> = <выражение2>
    - <Выражение1> после вычисления должно привести к местоположению объекта данных, в который будет производиться запись (левостороннее значение или lvalue)
    - <Выражение2> после вычисления должно обозначать величину, которая будет присвоена объекту данных (правостороннее значение или rvalue)
- Примеры
    - `ptr = NULL;`
    - `arr[i*2] = b;`
    - `*(pInt + 3) = 42;`

### Два типа ссылок в C++
- Обычные (l-value) ссылки:
    - `Type & ref = someVar;`
    - `const Type & constRef = someVar;`
- В C++11 введен новый тип ссылок: rvalue reference:
    - `Type && ref = someRvalueExpr;`
- Использование rvalue ссылок позволяет реализовать семантику перемещения в конструкторе и операторе присваивания
    - Рассмотрим на следующем примере

```c++
class MovingStudent {
public:
    explicit MovingStudent(const std::string& name)
        : m_name(name) {
        std::cout << "MovingStudent(const std::string& name)\n";
    }

    explicit MovingStudent(std::string&& name)
        : m_name(std::move(name)) {
        std::cout << "MovingStudent(std::string&& name)\n";
    }

    const std::string& GetName() const { return m_name; }
private:
    std::string m_name;
};

int main() {
    std::string name("Ivan");
    MovingStudent student2(name); // Будет вызвано копирование name
    MovingStudent student3("Ivan"); // Будет вызвано перемещение временного объекта
    MovingStudent student4(std::move(name)); // Будет вызвано перемещение из name
}
```

```c++
struct Name {
    Name(const char*) {
        std::cout << "Name(const char*)\n";
    }
    Name(const Name&) {
        std::cout << "Name(const Name&)\n";
    }
    Name(Name&&) {
        std::cout << "Name(Name&&)\n";
    }
};

class ByValueStudent
{
public:
    explicit ByValueStudent(Name name)
        : m_name(std::move(name))
    {
    }

private:
    Name m_name;
};

int main() {
    Name n("Ivan");
    std::cout << "---\n";
    ByValueStudent student5(n); // Copy + Move
    std::cout << "---\n";
    ByValueStudent student6("Ivan"); // Create + Move
    std::cout << "---\n";
    ByValueStudent student7(std::move(n)); // Move + Move
}
```

- Перемещающий конструктор
    - Служит для создания нового объекта на основе значения временного объекта
        - Содержимое временного объекта перемещается к создаваемому объекту
- Перемещающий оператор присваивания
    - Служит для изменения значения объекта путем присваивания значения временного объекта
        - Содержимое временного объекта перемещается к объекту в левой части присваивания
        - Перегрузка операторов присваивания будет рассмотрена в следующей лекции

- Принимает rvalue-ссылку (&&).
- Должен быть помечен как noexcept (чтобы, например, std::vector мог эффективно его использовать).
- "Крадёт" ресурсы у исходного объекта, оставляя его в валидном, но неопределённом состоянии.



---

## 2. В чём отличие перемещения от копирования?
### Требования Стандарта к перемещающему конструктору
- Значение создаваемого объекта должно быть равно значению оригинального объекта до вызова перемещающего конструктора
- После перемещения объект должен остаться в некотором валидном состоянии, возможно, неизвестном
    - В общем случае полагаться на состояние объекта после перемещения нельзя
        - string, vector
- Для некоторых классов (например, unique_ptr) поведение перемещающего конструктора определено
    - Правый указатель будет «пустым»

```c++
class String {
public:
    …
    String(String&& other) noexcept
        : m_size{ std::exchange(other.m_size, 0) }
        , m_capacity{ std::exchange(other.m_capacity, 0) }
        , m_chars{ std::exchange(other.m_chars, s_emptyString) }
    {
    }
    …
private:
    …
    inline static char s_emptyString[] = { '\0' };
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

---

## 3. Какие преимущества даёт перемещение по сравнению с копированием?
- Производительность: Избегает лишних выделений памяти и копирований (особенно важно для контейнеров, строк, умных указателей).
- Безопасность: Позволяет явно выразить намерение передать владение ресурсом.
- Поддержка в STL: Многие алгоритмы (std::sort, std::vector::push_back) используют перемещение, если оно доступно.

```c++
std::vector<std::string> v;
std::string s = "Hello";
v.push_back(std::move(s));  // Эффективнее, чем копирование
```

---

## 4. Какие стандартные классы поддерживают семантику перемещения?
Почти все классы STL поддерживают семантику перемещения:
- Контейнеры: std::vector, std::string, std::map и т. д.
- Умные указатели: std::unique_ptr, std::shared_ptr.
- Потоки: std::thread, std::fstream (но копирование запрещено).
- Обёртки: std::function, std::optional.

```c++
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1);  // Ресурсы перемещены, v1 теперь пуст
```

---

## 5. В каком состоянии должен остаться объект после перемещения?
Объект, из которого было выполнено перемещение, должен оставаться:
- Валидным (можно безопасно вызывать деструктор или присваивать новое значение).
- Неопределённым (но лучше явно обнулить поля, как в примере с String).

Требования:
- Должен быть деструктируемым (вызов деструктора не должен приводить к UB).
- Можно вызывать методы без предпосылок (например, clear()).

Bad:
```c++
std::string s1 = "test";
std::string s2 = std::move(s1);
std::cout << s1;  // Неопределённое поведение (но на практике может работать)
```

Good:
```c++
s1.clear();  // Явно приводим в известное состояние
```



---

## 6. Перемещающий оператор присваивания
Аналогичен перемещающему конструктору, но освобождает текущие ресурсы объекта.

### Перемещающий оператор присваивания
- Данный оператор используется при присваивании значения временного объекта
    - Как и перемещающий конструктор, вместо копирования он просто забирает данные у переданного объекта
- Значение левого аргумента должно быть эквивалентно значению правого аргумента ДО операции присваивания
- Правый аргумент должен остаться в валидном состоянии
    - Для некоторых стандартных типов состояние объекта после перемещения определено: std::unique_ptr перестаёт владеть объектом

```c++
class String {
public:
    …
    String(String&& other) noexcept
        : m_size{ std::exchange(other.m_size, 0) }
        , m_capacity{ std::exchange(other.m_capacity, 0) }
        , m_chars{ std::exchange(other.m_chars, s_emptyString) }
    {
    }
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            std::swap(m_size, other.m_size);
            std::swap(m_capacity, other.m_capacity);
            std::swap(m_chars, other.m_chars);
        }
        return *this;
    }
private:
    …
    inline static char s_emptyString[] = { '\0' };
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

---

## 7. Когда нужно создавать пользовательские конструктор/деструктор/операции присваивания?
Правило трёх (до C++11): Если класс управляет ресурсами (память, файлы и т. д.), нужно определить:
- Деструктор (освобождение ресурсов).
- Конструктор копирования (глубокое копирование).
- Оператор присваивания копированием.

```c++
class ResourceHolder {
public:
    ~ResourceHolder();                          // Деструктор
    ResourceHolder(const ResourceHolder&);       // Копирование
    ResourceHolder& operator=(const ResourceHolder&);
    ResourceHolder(ResourceHolder&&) noexcept;   // Перемещение
    ResourceHolder& operator=(ResourceHolder&&) noexcept;
};
```
Исключения:
- Если класс не владеет ресурсами, можно полагаться на автоматически сгенерированные методы.
- Если перемещение запрещено, можно объявить его как = delete.
---

## 8. Запрещение присваивания и перемещения объектов
Удаление методов:
```c++
ClassName(const ClassName&) = delete;
ClassName& operator=(const ClassName&) = delete;
```

Примеры:
std::mutex (копирование и перемещение запрещены).
std::unique_ptr (копирование запрещено, перемещение разрешено).

Совет: Если класс управляет эксклюзивным ресурсом, запретите копирование.

---

## 9. Что делает std::move?
- Не перемещает объект!
- Просто преобразует lvalue в rvalue, разрешая вызов перемещающих операций.
- Фактическое перемещение выполняется перемещающим конструктором/оператором.

```c++
std::string s1 = "Hello";
std::string s2 = std::move(s1);  // Вызов перемещающего конструктора
```

После std::move объект остаётся в неопределённом состоянии.

---

## 10. "Правило пяти"

Если класс определяет хотя бы один из следующих методов, обычно нужно определить и остальные:
- Деструктор.
- Конструктор копирования.
- Оператор присваивания копированием.
- Перемещающий конструктор.
- Перемещающий оператор присваивания.

Причина: Чтобы избежать частичной или некорректной работы с ресурсами.

```c++
class File {
public:
    ~File() { close(); }
    File(const File&) = delete;  // Запрещаем копирование
    File(File&& other) noexcept : handle_(other.handle_) {
        other.handle_ = nullptr;
    }
    // ... остальные методы
private:
    FILE* handle_;
};
```

Исключение: Если класс не владеет ресурсами (например, содержит только int), можно использовать автоматически сгенерированные методы.