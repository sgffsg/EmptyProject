# Лекция 1

C++ Статически типизированный - переменные не могут менять свой тип после объявления.

В С++23 можно использовать std::print

`std::print("hello wrld");`

## Типы данных

### Целые числа со знаком или без:
- int, short, char,long
- unsigned `[int, short, char,long]` - беззнаковые от 0 до 2^63. Переполнение приводит к зацикливанию. При увеличении предела превратится в 0, при уменьшении 0 получится максимальное значение.
- signed `[int, short, char,long]` - со знаком. При переполнении будет неопределенное поведение(программа может выдавать разные результаты на различных архитектурах)

### Числа с плавающей запятой
- `float, double, long double` (32bit)

### Логический тип
- `bool` - неявно преобразует любое ненулевое значение в true, а 0 в false

### Числовые литералы:
#### Десятичные
- `12345`, `-34021`
- `999999L`, `99983UL` (long и unsigned long)
- `999'456` - группировка разрядов
#### Шестнадцатеричные
- `0xFeedBeef`, `0x328aadb`
#### Двоичные
- `0b1110010`
#### Восьмеричные (начинаются с 0)
- `003`, `0723`
#### Вещественные
- `1.35`, `8.45f` (float)
- `2e+10f`, `-3.835e-6L` (`2 * 10^10` - float, `-3,835 * 10 ^ -6` - long double)
#### Символьные константы
- `'A'` - 65, `'1'` - 49
- `\n` - escape последовательность
- `'\''` - символ '
- `'\0'` - символ с кодом 0
- `'\n'` - символ перевода строки - код 13
- `'\177'` - символ с кодом 127
- `'\xff'` - символ с кодом 255
- Строковые литералы
  Строковая константа - массив символов, завершающийся символом с кодом ('\0') - `"Hello " "world" = "Hello world"`

```c++
int main()
{
    char letterA = 'A'; // ~= 65
    char eol = '\n';
    
    //Использование символов \
    std::string filepath = "c:\\path\\to\\file.txt";
    
    //Raw string literals
    std::string filepath1 = R"(c:\path\to\file.txt)";
    
    // Можно сцеплять несколько строковых литералов в один
    std::string multiLineString =
    "<html>\n"
    "</html>";
    
    //При помощи raw string literal можно упростить задание строк, содержащих спецсимволы
    std::string html = R"marker(<html>
    <body>
    </body>
    </html>)marker";
    
    std::string x = "Apple" "\n" "Dog" "," "Banana\n";
    std::cout << x << "---";
}
```

### Целые числа различного размера:
- char
- short, short int
- int
- long, long int

#### Целые числа со знаком и без знака:
- signed
- unsigned

#### Гарантируется следующее соотношение размеров целочисленных типов:
- sizeof(char) <= sizeof(short)
- sizeof(short) <= sizeof(int)
- sizeof(int) <= sizeof(long)

#### Типы int и short - знаковые
- int == signed int
- short == signed short

#### Тип char обычно тоже знаковый:
- Поведение может меняться в зависимости от компилятора
- `signed char, unsigned char`

### Прочие целые числа:
- `size_t` - Беззнаковый тип, способный храмить размер объекта в памяти или количество типов.
  Используем этот тип т.к. на различных платформах используются разные разрядности. на 64bit платформе будет 64 разрядный, на 32bit - 32 разрядный.
- `int8_t, int16_t, int32_t, int64_t` - Числа с фиксированной разрядностью
- `uint8_t, uint16_t, uint32_t, uint64_t` - Числа без знака фксированной разрядности
- `int_fast8_t, int_fast16_t, int_fast32_t, int_fast64_t` - Самый быстрый знаковый целочисленный тип не меньшей разрядности.
  Если надо работать с числами не меньше 16битной разрядности максимально быстро. Он использует инструкции процессора, позволяющие
  максимально быстро работать с этими данными.
- `uint_fast8_t, uint_fast16_t, uint_fast32_t, uint_fast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.
- `intmax_t, uintmax_t` - Целое число, имеющее максимальную разрядность, с которой процессор может эффективно работать.
- `intptr_t, uintptr_t` -
  Указатели используются при работе с объектами в памяти. Они хранят указатели. Разница
- `intleast8_t, intleast16_t, intleast32_t, intleast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.

### Почему всегда нельзя использовать тип int?
Тип int может иметь 32bit разрядности, а нам нужно хранить числа более плотно в памяти, чтобы использовать кеш.

Самые быстрые типы памяти - регистры - ячейки памяти для которых у процессора есть инструкции. Но регистров мало.

С другой стороны есть оперативная память(отдельная микросхема далеко от процессора). От процессора до памяти по проводам несколько тактов, чтобы дойти.

Кеш память работает быстро, ~2-3 такта чтобы записать. Делится на уровни кеша.

### Числа с плавающей запятой:
#### Хранят вещественные числа различного размера и точности
- float
- double
- long double
#### Гарантированы следующе соотношения размеров вещественных типов данных:
- sizeof(float) <= sizeof(double)
- sizeof(double) <= sizeof(long double)
#### Могут поддерживать специальные значения:
- Положительная и отрицательная бесконечности (INFINITY)
- Отрицательный ноль равен положительному нулю
1. `1.0/0.0  ==  INFINITY`
2. `1.0/-0.0 == -INFINITY`
- Не-числа(not-a-number, NaN)
Несравнимы на равенство ни с чем (включая самих себя)

Они хранят числа приблизительно. Точность представления меняется от удаленности от 0
Числа ближе к 0 хранятся с большей точностью, чем те которые дальше

### Объявление локальных переменных и констант
```c++
int main()
{
    // Объявление переменной
    double carSpeed;
    carSpeed = 45.8;
    
    // Объявление переменной можно совместить с её инициализацией
    int userAge = 20;
    float x = 12.6f;
    
    // Константа при объявлении всегда должна быть проинициализирована
    const double SPEED_OF_LIGHT = 299792458.0;
    const int SECONDS_IN_HOUR = 3600;
    const int HOURS_IN_DAY = 3600;
    
    // Гарантировано вычисляется вовремя компиляции
    constexpr int CONSTED = 300;
    
    // Инициализация константы в результате выражения
    const int SECONDS_IN_DAT = SECONDS_IN_HOUR * HOURS_IN_DAY;
}
```

1. Если прочитать неинициализированную переменную, то будет неопределенное поведение
2. `const` можно писать и слева и справа от переменной
3. Попытка изменить значение константы после объявления выдаст ошибку компиляции
4. Функция д.б. ~15-20 строк

### Автоматическое определение типа переменной
```c++
int main()
{
    // double
    auto PI = 3.14159265;
    
    // const float
    const auto E = 2.71828f;
    
    // float (float * int)
    auto e2 = E * 2;
    
    // const double (double / int)
    const auto halfPI = PI / 2;
    
    // long double (функция sqrt возвращает значение long double)
    auto sqrtPI = sqrt(PI);
}
```

### Область видимости переменной
```c++
int main()
{
    // Область видимости переменной ограничена блоком, внутри которого она объявлена
    std::string username = "Ivan Petrov";
    int age = 10;
    
    {
        // Переменная из внутреннего блока может иметь имя, совпадающее с именем из внешнего блока
        // При этом внутри этого блока она замещает собой одноименную переменную из внешего блока
        std::string username = "Sergey Ivanov";
        assert(username == "Sergey Ivanov");
        
        // Тип переменной age может отличаться от типа одноименной переменной из внешнего блока
        double age = 7.7; 
    }
    
    // При возврате во внешний блок видимой снова становится внешняя переменная
    assert(username == "Ivan Petrov");
}
```

### Объявление глобальных переменных
```c++
// Глобальные переменные по умолчанию инициализируются нулями
int globalVar;
int anotherGlobalVar = 42; // Можно проинициализировать заранее заданным значением

std::cout << globalVar << std::endl; // 0
globalVar = 13;
std::cout << globalVar << std::endl; // 13
std::cout << anotherGlobalVar << std::endl; // 42

```