# Лекция 1

C++ Статически типизированный - переменные не могут менять свой тип после объявления.

В С++23 можно использовать std::print

`std::print("hello wrld");`

## Типы данных

### Целые числа со знаком или без:
- int, short, char,long
- unsigned `[int, short, char,long]` - беззнаковые от 0 до 2^63. Переполнение приводит к зацикливанию. При увеличении предела превратится в 0, при уменьшении 0 получится максимальное значение.
- signed `[int, short, char,long]` - со знаком. При переполнении будет неопределенное поведение(программа может выдавать разные результаты на различных архитектурах)

### Числа с плавающей запятой
- `float, double, long double` (32bit)

### Логический тип
- `bool` - неявно преобразует любое ненулевое значение в true, а 0 в false

### Числовые литералы:
#### Десятичные
- `12345`, `-34021`
- `999999L`, `99983UL` (long и unsigned long)
- `999'456` - группировка разрядов
#### Шестнадцатеричные
- `0xFeedBeef`, `0x328aadb`
#### Двоичные
- `0b1110010`
#### Восьмеричные (начинаются с 0)
- `003`, `0723`
#### Вещественные
- `1.35`, `8.45f` (float)
- `2e+10f`, `-3.835e-6L` (`2 * 10^10` - float, `-3,835 * 10 ^ -6` - long double)
#### Символьные константы
- `'A'` - 65, `'1'` - 49
- `\n` - escape последовательность
- `'\''` - символ '
- `'\0'` - символ с кодом 0
- `'\n'` - символ перевода строки - код 13
- `'\177'` - символ с кодом 127
- `'\xff'` - символ с кодом 255
- Строковые литералы
  Строковая константа - массив символов, завершающийся символом с кодом ('\0') - `"Hello " "world" = "Hello world"`

```c++
int main()
{
    char letterA = 'A'; // ~= 65
    char eol = '\n';
    
    //Использование символов \
    std::string filepath = "c:\\path\\to\\file.txt";
    
    //Raw string literals
    std::string filepath1 = R"(c:\path\to\file.txt)";
    
    // Можно сцеплять несколько строковых литералов в один
    std::string multiLineString =
    "<html>\n"
    "</html>";
    
    //При помощи raw string literal можно упростить задание строк, содержащих спецсимволы
    std::string html = R"marker(<html>
    <body>
    </body>
    </html>)marker";
    
    std::string x = "Apple" "\n" "Dog" "," "Banana\n";
    std::cout << x << "---";
}
```

### Целые числа различного размера:
- char
- short, short int
- int
- long, long int

#### Целые числа со знаком и без знака:
- signed
- unsigned

#### Гарантируется следующее соотношение размеров целочисленных типов:
- sizeof(char) <= sizeof(short)
- sizeof(short) <= sizeof(int)
- sizeof(int) <= sizeof(long)

#### Типы int и short - знаковые
- int == signed int
- short == signed short

#### Тип char обычно тоже знаковый:
- Поведение может меняться в зависимости от компилятора
- `signed char, unsigned char`

### Прочие целые числа:
- `size_t` - Беззнаковый тип, способный храмить размер объекта в памяти или количество типов.
  Используем этот тип т.к. на различных платформах используются разные разрядности. на 64bit платформе будет 64 разрядный, на 32bit - 32 разрядный.
- `int8_t, int16_t, int32_t, int64_t` - Числа с фиксированной разрядностью
- `uint8_t, uint16_t, uint32_t, uint64_t` - Числа без знака фксированной разрядности
- `int_fast8_t, int_fast16_t, int_fast32_t, int_fast64_t` - Самый быстрый знаковый целочисленный тип не меньшей разрядности.
  Если надо работать с числами не меньше 16битной разрядности максимально быстро. Он использует инструкции процессора, позволяющие
  максимально быстро работать с этими данными.
- `uint_fast8_t, uint_fast16_t, uint_fast32_t, uint_fast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.
- `intmax_t, uintmax_t` - Целое число, имеющее максимальную разрядность, с которой процессор может эффективно работать.
- `intptr_t, uintptr_t` -
  Указатели используются при работе с объектами в памяти. Они хранят указатели. Разница
- `intleast8_t, intleast16_t, intleast32_t, intleast64_t` - Самый быстрый беззнаковый целочисленный тип не меньшей разрядности.

### Почему всегда нельзя использовать тип int?
Тип int может иметь 32bit разрядности, а нам нужно хранить числа более плотно в памяти, чтобы использовать кеш.

Самые быстрые типы памяти - регистры - ячейки памяти для которых у процессора есть инструкции. Но регистров мало.

С другой стороны есть оперативная память(отдельная микросхема далеко от процессора). От процессора до памяти по проводам несколько тактов, чтобы дойти.

Кеш память работает быстро, ~2-3 такта чтобы записать. Делится на уровни кеша.

### Числа с плавающей запятой:
#### Хранят вещественные числа различного размера и точности
- float
- double
- long double
#### Гарантированы следующе соотношения размеров вещественных типов данных:
- sizeof(float) <= sizeof(double)
- sizeof(double) <= sizeof(long double)
#### Могут поддерживать специальные значения:
- Положительная и отрицательная бесконечности (INFINITY)
- Отрицательный ноль равен положительному нулю
1. `1.0/0.0  ==  INFINITY`
2. `1.0/-0.0 == -INFINITY`
- Не-числа(not-a-number, NaN)
Несравнимы на равенство ни с чем (включая самих себя)

Они хранят числа приблизительно. Точность представления меняется от удаленности от 0
Числа ближе к 0 хранятся с большей точностью, чем те которые дальше

### Объявление локальных переменных и констант
```c++
int main()
{
    // Объявление переменной
    double carSpeed;
    carSpeed = 45.8;
    
    // Объявление переменной можно совместить с её инициализацией
    int userAge = 20;
    float x = 12.6f;
    
    // Константа при объявлении всегда должна быть проинициализирована
    const double SPEED_OF_LIGHT = 299792458.0;
    const int SECONDS_IN_HOUR = 3600;
    const int HOURS_IN_DAY = 3600;
    
    // Гарантировано вычисляется вовремя компиляции
    constexpr int CONSTED = 300;
    
    // Инициализация константы в результате выражения
    const int SECONDS_IN_DAT = SECONDS_IN_HOUR * HOURS_IN_DAY;
}
```

1. Если прочитать неинициализированную переменную, то будет неопределенное поведение
2. `const` можно писать и слева и справа от переменной
3. Попытка изменить значение константы после объявления выдаст ошибку компиляции
4. Функция д.б. ~15-20 строк

### Автоматическое определение типа переменной
```c++
int main()
{
    // double
    auto PI = 3.14159265;
    
    // const float
    const auto E = 2.71828f;
    
    // float (float * int)
    auto e2 = E * 2;
    
    // const double (double / int)
    const auto halfPI = PI / 2;
    
    // long double (функция sqrt возвращает значение long double)
    auto sqrtPI = sqrt(PI);
}
```

### Область видимости переменной
```c++
int main()
{
    // Область видимости переменной ограничена блоком, внутри которого она объявлена
    std::string username = "Ivan Petrov";
    int age = 10;
    
    {
        // Переменная из внутреннего блока может иметь имя, совпадающее с именем из внешнего блока
        // При этом внутри этого блока она замещает собой одноименную переменную из внешего блока
        std::string username = "Sergey Ivanov";
        assert(username == "Sergey Ivanov");
        
        // Тип переменной age может отличаться от типа одноименной переменной из внешнего блока
        double age = 7.7; 
    }
    
    // При возврате во внешний блок видимой снова становится внешняя переменная
    assert(username == "Ivan Petrov");
}
```

### Объявление глобальных переменных
```c++
// Глобальные переменные по умолчанию инициализируются нулями
int globalVar;
int anotherGlobalVar = 42; // Можно проинициализировать заранее заданным значением

std::cout << globalVar << std::endl; // 0
globalVar = 13;
std::cout << globalVar << std::endl; // 13
std::cout << anotherGlobalVar << std::endl; // 42

```

# Синонимы типов, перечислимый тип, операции

## Ввод-вывод строк

```c++
int main()
{
    std::string phrase;
    std::getline(std::cin, phrase); // Чтение до символа конца строки

    std::string name, surname;
    std::cin >> name >> surname; // Чтение name surname, разделенные пробелами
}
```

## Синонимы типов

- В С++ можно задавать альтернативные имена для существующих типов
- Ключевое слово `using`:
1. using NewType = OldType;
2. `template < template-parameter-list >` <br> `using NewType = OldType;`
- Применение:
1. Упрощение сложных типов данных
2. Повышение переносимости программ
3. Упрощение записи шаблонных типов
4. Улучшение читаемости кода

```c++
using Matrix3x3d = std::array<std::array<double, 3>, 3>;

void PrintMatrix(const Matrix3x3d>& matrix)
{
    for (auto& row: matrix) // Пробегаем по строкам
    {
        for (double item: row) // Пробегаем по элементам
        {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
}
```

```c++
template <typename T, unsigned Rows, unsigned Columns>
using MatrixT = std::array<std::array<T, Columns>, Rows>

templaye <typename T, unsigned Rows, unsigned Columns>
void PrintMatrix(const MatrixT<T, Rows, Columns>& matrix)
{
    for (auto& row: matrix) // Пробегаем по строкам
    {
        for (double item: row) // Пробегаем по элементам
        {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
}
```

### Синонимы типов в стиле C
- C++ унаследовал ключевое слово `typedef`
- Синтаксис: <br>
  `typedef ExistingType NewType`
- Ограничения: нельзя объявлять шаблоны
- Можно встретить в устаревших кодовых базах и заголовочных файлах
- В прогах на С++ объявлять синонимы типо с помощью `using`

## Перечислимый тип данных

Задает набор именованных целочисленных значений
- День недели или название месяца
- Состояние конечного автомата
- Модель компьютера

Особенности:
- Имена в различных перечислениях должны отличаться друг от друга
- Значения внутри одного перечисления могут совпадать: <br>
  `enum Status {Ol, Failure, Success = Ok};`
- Могут неявно преобразовываться к целым числам

```c++
enum TrafficLight
{
    Red,
    Green,
    Blue,
};

TrafficLight tl = Blue;
std::cout << tl << std::endl; // Выведет 2
```

Проблема enum
```c++
enum TrafficLight
{
    Red, Green, Blue,
};

// Не скомпилируется т.к. значение Red уже используется TrafficColor
enum CarColor
{
    Red, Green, Blue,
};
```

### Scoped enum (появились в С++11)

- Ограничивают область видимости значений перечислимого типа именем перечисления
- Позволяют преодолеть ограничение традиционного enum на уникальность значений
- Не имеют неявного преобразования к целым числам


```c++
enum class TraficLightColor
{
    Yellow, Red, Green
};

enum class CarColor { Red, Black, White };
```

## Основные операторы
1. Общие
- Арифметические операторы и оператор присваивания
- Логические операторы и операторы сравнения
- Оператор sizeof
2. Управление ходом выполнения программы
- Условные операторы
- Операторы циклов
- Оператор множественного выбора
3. Операторы для работы с массивами, структурами и объединениями
4. Операторы для работы с указателями

## Арифметические операторы

- Бинарные
1. `+`
2. `-`
3. `*`
4. `/`
5. `%` (остаток от деления – применяется только к целым) <br>
   `int i = 10 % 3;` ` i = 1;`
6. Деление целых сопровождается отбрасыванием дробной части
   `float f = 8 / 3;` `f = 2.0`
- Унарные (ставятся перед операндом)
1. `+`
   `int i = +1;`
2. `-`
   `int j = -8;`

```c++
int main()
{
  /*
  Вася купил 10 килограммов яблок,
  а бананов - на 5 килограммов больше, чем яблок.
  Груш он купил столько же, сколько яблок и бананов вместе.
  
  Во сколько раз больше масса всех фруктов, чем яблок?
  */
  double apples = 10;
  double bananas = apples + 5;
  double pears = apples + bananas;

  double totalFruit = apples + bananas + pears;

  double ratio = totalFruit / apples;
  std::cout << "Total fruit to aplles ratio is " << ratio << "\n";
}

```

## Операторы отношения

- Операторы отношения
1. `>`
2. `>=`
3. `<`
4. `<=`
- Операторы сравнения на равенство
1. `==`
2. `!=`

## Логические операторы

- && - логическое И <br>
  `char ch = getchar();` <br>
  `int isDigit = (ch >= ‘0’) && (ch <= ‘9’);`

- || - логическое ИЛИ
  `char ch = getchar();` <br>
  `if ((ch == ‘ ‘) || (ch == ‘\n’) || (ch == ‘\t’))` <br>
  `cout << "Разделитель";`

- ! – логическое НЕ <br>
  `if (!valid)`
- Вычисления операторов `&&` и `||` прекращаются как только станет известна истинность или ложность результата

## Операторы инкремента и декремента

- Увеличивают или уменьшают значение операнда на 1
1. `++`
2. `--`
- Имеют две формы
1. Префиксная форма (возвращает новое значение аргумента) <br>
   `int i = 0;` <br>
   `int j = ++i;` `i = 1; j = 1;`
2. Постфиксная форма (возвращает старое значение аргумента) <br>
   `int i = 0;` <br>
   `int j = i--;` `i = -1; j = 0;`
- Операторы инкремента и декремента можно применять только к переменным <br>
  `int i = (j + y)++;` `/* ошибка */`

```c++
int main()
{
  /*
  Пользователь вводит натуральное число.
  Вывести количество цифр 2 в десятичной записи этого числа
  */
  std::cout << "Enter a natural number: ";
  int number;
  std::cin >> number;

  int n = number;
  int twos = 0; 
  do
  {
    const int units = n % 10; // units – число в разряде единиц
    if (units == 2)
      ++twos;
    n /= 10;
  } while (n != 0);
  std::cout << "Decimal notation of " << number 
    << " contains " << twos << " 2s\n";
}
```

## Операторы обработки битов

- & - побитовое И <br>
  `int i = 0b1101 & 0b0110;` `/* i = 0b0100 */`
- | - побитовое ИЛИ
  `int i = 0b1100 | 0b0010;` `/* i = 0b1110 */`
- ^ - побитовое исключающее ИЛИ
  `int i = 0b0101 ^ 0b1100;` `/* i = 0b1001 */`
- << - сдвиг влево
  `int i = 0b0001 << 3;` `/* i = 0b1000 */`
-  >> - сдвиг вправо
        `int i = 0b11001 >> 2;` `/* i = 0b00110 */`
- ~ - побитовое отрицание (унарный оператор).
  `char i = ~0b00000001;` `/* i = 0b11111110) */`

```c++
struct RGBAColor {
  uint8_t r = 0;
  uint8_t g = 0;
  uint8_t b = 0;
  uint8_t a = 255;
};

RGBAColor RGBAColorFromARGB(uint32_t argb)
{
  return {
    static_cast<uint8_t>(argb >> 16),
    static_cast<uint8_t>(argb >> 8),
    static_cast<uint8_t>(argb),
    static_cast<uint8_t>(argb >> 24),
  };
}

int main()
{
  uint32_t value;
  std::cin >> std::hex >> value;
  Print(RGBAColorFromARGB(value));
  Print(RGBAColorFromABGR(value));
}
```

```c++
RGBAColor RGBAColorFromABGR(uint32_t abgr)
{
  return {
    static_cast<uint8_t>(abgr),
    static_cast<uint8_t>(abgr >> 8),
    static_cast<uint8_t>(abgr >> 16),
    static_cast<uint8_t>(abgr >> 24),
  };
}

void Print(RGBAColor color)
{
  std::cout << "r: "   << +color.r
            << ", g: " << +color.g
            << ", b: " << +color.b
            << ", a: " << +color.a
            << std::endl;
  // Унарный + преобразует uint8_t в int,
  // чтобы значение выводилось в виде числа,
  // а не в виде символа
}
```

## Операторы и выражения присваивания

- Служат для присваивания переменным значения некоторого выражения
1. `i = 3;`
2. `i += 8;`
3. `i <<= 1;`
4. `j %= 3;`
- Типом и значением выражения присваивания является тип и значение левого операнда после завершения присваивания
```c++
while ((c = getchar()) != EOF)
{
// do something
}
```

### Наивный аналог std::popcoun
```c++
// PopCount: подсчет количества битов в числе x , равных 1
int PopCount(unsigned х)
{
	int b;
	for (b = 0; х != 0; x >>= 1)
	{
		if (x & 0x01)
			++b; 
	} 
	return b; 
}
```

### Чтение чисел до первого отрицательного
```c++
#include <iostream>

int ReadInt()
{
    int n;
    std::cin >> n;
    return std::cin && n >= 0 ? n : -1;
}

int main()
{
    // Считываем до первого отрицательного числа
    for (int n; (n = ReadInt()) >= 0;)
    {
        std::cout << n << std::endl;
    }
}
```

## Условное выражение

- Условное выражение имеет вид: <br>
  выр1 ? выр2 : выр3
1. Сначала вычисляется выражение 1
2. Если оно истинно (не равно нулю), то вычисляется выражение 2 и его значение становится значением всего условного выражения
3. В противном случае вычисляется выражение 3 и становится значением всего условного выражения
- Пример
  `z = (a > b) ? a : b;` `/* z = max(a, b)*/`

## Приоритет и ассоциативность операций

- Приоритет определяет порядок выполнения операций в отсутствие скобок <br>
  `A + B * C вычисляется как A + (B * C)`
- Ассоциативность выполняет порядок вычисления операций с одинаковым приоритетом
1. Левоассоциативность: <br>
   `A - B - C вычисляется как (A - B) - C`
2. Правоассоциативность: <br>
   `A = B = C вычисляется как A = (B = C)`

# Преобразование типов

- Происходит, когда операнды оператора принадлежат к разным типам
- Неявное преобразование к типу int
  `int i = 7.0 + 3 – 2.0f;`
- Явное преобразование к типу int в стиле C
  `int i = (int)(7.0 + 3 – 2.0f);`
- Если один из аргументов является знаковым целым, а второй беззнаковым, результатом будет целое число без знака

## Опасность неявного приведения типов

```c++
int CenterPictureOnTheScreen(	int pictureWidth, unsigned screenWidth)
{
	return (screenWidth - pictureWidth) / 2;
}

int main(int argc, char * argv)
{
	unsigned screenWidth = 100;

	unsigned pic1Width = 50;
	int pic1X = CenterPictureOnTheScreen(pic1Width, screenWidth);
	// pic1x = 25: ok

	unsigned pic2Width = 150;
	int pic2X = CenterPictureOnTheScreen(pic2Width, screenWidth);
	// pic2x = 2147483623: error
}
```

## Явное приведение типов в стиле C
```c++
int CenterPictureOnTheScreen(int pictureWidth, unsigned screenWidth)
{
	return ((int)screenWidth - pictureWidth) / 2;
}

int main()
{
	unsigned screenWidth = 100;

	unsigned pic1Width = 50;
	int pic1X = CenterPictureOnTheScreen(pic1Width, screenWidth);
	// pic1x = 25: ok

	unsigned pic2Width = 150;
	int pic2X = CenterPictureOnTheScreen(pic2Width, screenWidth);
	// pic2x = -25:ok
}
```

### Недостатки оператора преобразования типов в стиле C

- Преобразование типов в стиле C выполняет любое преобразование, что повышает шанс ошибок
- Сложно найти в тексте программы
- Не поддерживает полиморфизм
- Не даёт понять, меняется ли константность объекта

### Пример

```c++
void Test(double doubleValue)
{
   // Программист хотел преобразовать doubleValue к int, но случайно написал &
   // &doubleValue хранит адрес переменной doubleValue
	int intValue = (int)&doubleValue;
   // intValue хранит целочисленное значение части адреса
}
```

```c++
struct Point
{
	double x;
	double y;
};

void Test1(const Point& p)
{
	/*	программист отвлекся и вместо 
		int x = (int)p.x; 
		написал: (int)p */
	int x = (int)p;
	// x хранит адрес p вместо целочисленного значения координаты x
}
```

## Преобразование типов в С++

- В языке C++ введены 4 оператора приведения типов
1. `static_cast<Type>(arg)`
2. `dynamic_cast<Type>(arg)`
3. `const_cast<Type>(arg)`
4. `reinterpret_cast<Type>(arg)`
- Каждый из них предназначен для конкретной задачи <br>
  Сложнее ошибиться
- Их легче найти в коде
- В программах на C++ следует использовать эти операторы

### Оператор static_cast

- Выполняет статическое преобразование одного типа к другому
1. Например, double в int
2. Указатель void* в указатель на конкретный тип
- Также выполняет статическое преобразование указателей и ссылок в пределах иерархии классов <br>
  Например, если Cat унаследован от Animal, то можно выполнять преобразования: <br>
1. Cat* в Animal*
2. Animal* в Cat*

```c++
void Test(double doubleValue)
{
	// Ошибка компиляции
	int intValue = static_cast<int>(&doubleValue);
}

struct Point
{
	double x;
	double y;
};

void Test1(const Point * p)
{
	int x = static_cast<int>(p->x);	// ok
	int y = static_cast<int>(p);		// ошибка компиляции
}
```

### Оператор const_cast

- Снимает константность с ссылки или указателя
- Если оригинальный объект был константным, попытка снять с него константность и изменить значение вызовет неопределённое поведение

```c++
// Оригинальный объект не является константным
double PI = 3.14159265;

const double& CONST_PI = PI;
// Изменить константную ссылку CONST_PI нельзя:
// CONST_PI = 4;

// Но можно снять константность со ссылки и модифицировать объект.
const_cast<double&>(CONST_PI) = 4;

std::cout << "Now pi is " << PI << std::endl;
```

### Снятие константности с константного объекта вызывает UB
```c++
// PI - константный объект.
const double PI = 3.1415927;

int main()
{
    // Здесь мы обманываем компилятор,
    // снимая константность к константной переменной.
    double& nonConstPI = const_cast<double&>(PI);

    // Попытка изменить константный объект, сняв константность со ссылки на него,
    // приводит к неопределённому поведению
    nonConstPI = 4;

    std::cout << "PI:" << PI << ", nonConstPI: " << nonConstPI << std::endl;
}
```

### Оператор reinterpret_cast
- Может применяться для преобразования между целочисленными типами и указателями, а также между указателями на несвязанные друг с другом типы данных
- Пригодится при прямой работе с памятью

```c++
#include <iostream>
#include <cstdint>
#include <string>

void ChangeString(std::uintptr_t p)
{
    std::string* pstr = reinterpret_cast<std::string*>(p);
    *pstr = "Goodbye";
}

int main()
{
    std::string name = "Hello";
    // Так нельзя, так как uintptr_t и std::string* - разные типы
    // ChangeString(&name);
    
    // Так можно
    ChangeString(reinterpret_cast<uintptr_t>(&name));

    std::cout << name << std::endl; // Выведет Goodbye
}
```

### Оператор dynamic_cast
- Применяется для динамического преобразования типов в пределах иерархии классов
- C dynamic_cast познакомимся, когда будем проходить наследование


# Управление выполнением программы

## Инструкции и блоки
- Выражение (например, x = 0) становится инструкцией, если в конце поставить точку с запятой
1. `x = a + b;`
2. `std::cout << "Hello";`
3. `DrawCat(cat);`
- Фигурные скобки { и } используются для объединения объявлений и инструкций в составную инструкцию, или блок <br>
  с т.з. синтаксиса языка блок воспринимается как одна инструкция

### Блоки и область видимости

- Блок создаёт новую область видимости переменных, которые в нём объявлены
- При покидании блока видимости переменная уничтожается, а занимаемая ею область памяти – освобождается

```c++
int main(int argc, char * argv)
{
	int a = 0;
	if (argc > 1)
	{
		int b = argc - 1;
	}
	return 0;
}
```

## Конструкция if-else
- Оператор if позволяет выполнить тот или иной участок кода в зависимости от значения некоторого выражения
```c++
if (<выражение>)
    <инстр.1>
else
    <инстр.2>
if (<выражение>)
    <инстр>
```

Пример:
```c++
int number;
if (std::cin >> number) // Удалось ли прочитать number из консоли?
{
    if (number % 2 == 0)
        std::cout << "Number is even";
    else
        std::cout << "Number is odd";
}
// Можно ли здесь использовать переменную number?
```

### В выражении if можно объявлять переменные
```c++
if (int number; std::cin >> number)
{ // Видимость переменной `number` ограничена блоком if
    if (number % 2 == 0)
        std::cout << "Number is even";
    else
        std::cout << "Number is odd";
}
else
{
    // Переменная number видна и здесь,
    // но тут number не инициализирована и использовать её нельзя
    number = 42;
}
// Здесь number не видна
```

### Значение объявленной переменной участвует в проверке условия
```c++
int x;
int y;
std::cin >> x >> y;
if (int sum = x + y)
{ // сюда попадём, если sum — не 0
    std::cout << sum << std::endl;
}
else
{
    // Переменная sum равна нулю
}
```

### Конструкция else-if
- Позволяет осуществлять многоступенчатое решение
```c++
if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else if (выражение) 
    инструкция 
else 
    инструкция 
```

### Пример, бинарный поиск
```c++
/* Найти x в v[0] <= v[1] <= ... <= v[n-1] */
int BinarySearch(int x, const int v[], int n)
{
	int low = 0;
	int high = n;
	
	while (low < high)
	{
		mid = (low + high) / 2;
		if (x < v[mid])
			high = mid;
		else if (x > v[mid])
			low = mid + 1;
		else /* совпадение найдено */
			return mid;
	}
	return -1; /* совпадения нет */
}
```

## Оператор switch
- Используется для выбора одного из нескольких путей <br>
  Если выражение равно одному из указанных целочисленных констант, выполняются соответствующие действия
- Инструкция break выполняет выход из блока switch

```c++
#include <string>
#include <iostream>
#include <cassert>
 
enum class WeekDay
{
  Sunday, Monday, Tuesday, Wednesday,
  Thursday, Friday, Saturday
};
 
std::string WeekDayToString(WeekDay weekDay)
{
  switch (weekDay)
  {
  case WeekDay::Sunday:    return "Sunday";
  case WeekDay::Monday:    return "Monday";
  case WeekDay::Tuesday:   return "Tuesday";
  case WeekDay::Wednesday: return "Wednesday";
  case WeekDay::Thursday:  return "Thursday";
  case WeekDay::Friday:    return "Friday";
  case WeekDay::Saturday:  return "Saturday";
  default:
    assert(!"This is not possible");
    return "";
  }
}
 
void main()
{
  std::cout << WeekDayToString(WeekDay::Sunday) << std::endl;
}
```

```c++
#include <iostream>
 
int main() /* подсчет цифр, символов-разделителей и прочих символов */
{
  int numSpaces = 0;
  int numDigits[10] = {};
  int numOther = 0;
  char ch;
  while (std::cin.get(ch))
  {
    switch (ch)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      ++numDigits[ch - '0'];
      break;
    case ' ':  case '\n': case '\t':
      ++numSpaces;
      break;
    default:
      ++numOther;
    }
  }
 
  std::cout << "Digits:";
  for (int n : numDigits)
  {
    std::cout << " " << n;
  }
  std::cout << ", whitespaces: " << numSpaces << ", other: " << numOther << std::endl;
  return 0;
}
```

# Циклическое выполнение
- Цикл – последовательность из нескольких операторов, указываемая в программе один раз, которая выполняется несколько раз подряд
- Допускается существование бесконечного цикла
- Тело цикла - последовательность операторов, предназначенная для многократного выполнения в цикле

## Циклическое выполнение в языке Си
- Циклическое выполнение в языке Си осуществляется при использовании следующих операторов цикла:
1. `while`
2. `for`
3. `do..while`
- Внутри циклов могут использоваться операторы управления работой цикла:
1. `break` для досрочного выхода из цикла
2. `continue` для пропуска текущей итерации

### Оператор while
- Оператор while служит для организации циклов с предусловием <br>
  цикл, который выполняется, пока истинно некоторое условие, указанное перед его началом
- Синтаксис
```c++
while (выражение)
инструкция
```
2. Инструкция (тело цикла) выполняется до тех пор, пока выражение принимает ненулевое значение

### Пример: нахождение наибольшего общего делителя
```c++
// Поиск наибольшего общего делителя чисел a и b
{
  unsigned a = 714;
  unsigned b = 312;
  cout << "Greatest Common Denominator of " << a << " and " << b << " is ";
  while (b != 0)
  {
    swap(a, b);
    b = b % a;
  }
  cout << max(a, 1u) << endl;
}
```

### Оператор for
- Оператор for служит для организации циклов со счетчиком
- Синтаксис

```c++
for (выр1; выр2; выр3)
инструкция
```

- Выражение1 выполняется один раз перед началом цикла <br>
  Например, оператор инициализации счетчика цикла
- Выполнение инструкции (тело цикла) продолжается до тех пор, пока выражение2 имеет ненулевое значение <br>
  если выражение2 отсутствует, то выполнение цикла продолжается бесконечно
- После каждой итерации цикла выполняется выражение3 <br>
  Например, изменение счетчика цикла

Простой цикл for
```c++
void main()
{
  // Выводит 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
  // Область видимости переменной i ограничена телом цикла
  for (int i = 0; i < 10; ++i)
  {
    cout << i << ", ";
  }
  cout << endl;
 
  for (int i = 100; i >= 0; i -= 2)
  {
    cout << i << ", ";
  }
  cout << endl;
}
```

### Range-based for
- Версия цикла for, предназначенная для перебора элементов некоторого диапазона <br>
  Массивы, строки, контейнеры стандартной библиотеки, пользовательские типы данных
- Синтаксис:
```c++
for (тип идентификатор : диапазон)
инструкция
```

```c++
// Обход элементов массива
{
  int numbers[] = { 10, 15, 17, 33, 18 };
  int sum = 0;
  int product = 1;
  cout << "Array items: ";
  for (int number : numbers)
  {
    cout << number << ", ";
    sum += number;
    product *= number;
  }
  cout << endl << "\tSum: " << sum << endl << "\tProduct: " << product << endl;
}
```
```c++
// Обход символов строки и контейнера map
{
  string pangram = "the quick brown fox jumps over the lazy dog";
 
  map<char, int> characterOccurrences;
  for (char ch : pangram)
  {
    cout << ch;
    if (isalpha(ch))
    {
      // Возращенное значение частоты встречаемости символа увеличиваем на 1
      ++characterOccurrences[ch];
    }
  }
 
  cout << "Character occurrence in \"" << pangram << "\":" << endl;
  for (const auto & charOcc : characterOccurrences)
  {
    cout << "\t" << charOcc.first << ": " << charOcc.second << endl;
  }
 
  cout << "Character occurrence in \"" << pangram << "\":" << endl;
  for (const auto [ch, count] : characterOccurrences)
  {
    cout << "\t" << ch << ": " << count << endl;
  }
}
```

### Оператор do-while
- Оператор do-while служит для организации циклов с постусловием
1. цикл, в котором условие проверяется после выполнения тела цикла
2. тело всегда выполняется хотя бы один раз
- Синтаксис
```c++
do
инструкция
while (выражение);
```
- Инструкция выполняется до тех пор, пока выражение принимает ненулевое значение

```c++
// Ввод продолжается, пока пользователь не введет bye
{
  string userInput;
  do 
  {
    cout << R"(Enter text or "bye" to finish: )";

    getline(cin, userInput);
    cout << "You entered: " << userInput << endl;

  } while (userInput != "bye");
}
```

### Бесконечные циклы for, while, do-while
```c++
  // Генератор псевдослучайных чисел с использованием Вихря Мерсенна (Mersenne Twister)
  mt19937 generator;
  // Адаптер для получения равномерно распределенных чисел в диапазоне [1; 10]
  uniform_int_distribution<int> dist(1, 10);
  for (;;) {
    cout << "Next random number: " << dist(generator) << endl;
    cout << "Type q or Q to quit the game: ";
    string userInput;
    getline(cin, userInput);
    if (userInput == "q" || userInput == "Q") {
      break;
    }
  }
 
  // Также можно использовать цикл while:
  while (true) {
    //тело цикла 
  }

  // либо цикл do-while: 
  do {
    //тело цикла
  } while(true);
```

### Инструкции break и continue

- Инструкция break осуществляет немедленный выход из тела цикла, внутри которого она находится <br>
  Также инструкция break осуществляет выход из оператора switch
- Инструкция continue осуществляет пропуск оставшихся операторов тела цикла, внутри которого она находится, и переход на следующую итерацию цикла
1. В циклах while и do-while осуществляется переход к проверке условия
2. В цикле for осуществляется переход к приращению переменной цикла

### Пример: поиск простых чисел

```cout << "Primes: ";
for (int i = 2; i < 100; ++i) {
  bool isPrime = true;
  // Наивный метод определения простоты числа i
  //  проверяем i на делимость на любое из чисел диапазона [2; sqrt(i)]
  for (int j = 2; j * j <= i; ++j) {
    // Если найден множитель числа i, выходим из цикла при помощи break
    if (i % j == 0) {
      isPrime = false;
      break;
    }
  }
  if (isPrime)
  {
    cout << i << ", ";
  }
}
```

### Инструкция goto
- Инструкция goto позволяет осуществить переход на заданную метку внутри текущей функции
- Синтаксис:
  `goto метка;`
- Как правило, использование инструкции goto усложняет структуру программы и без крайней необходимости ею пользоваться не стоит <br>
  Если Вы все еще думаете об использовании этого оператора – использовать его все равно не стоит
```c++
/* поиск совпадающих элементов в массивах */
for (i = 0; i < n; ++i)
{
	for (j = 0; j < m; ++j)
	{
		if (a[i] == b[j])
			goto found;
	}
}
/* нет одинаковых элементов */

found:
/* обнаружено совпадение: a[i] == b[j] 	*/
```

# Функции
- Именованная последовательность инструкций
- Основа процедурного программирования
- Определив однажды функцию, можно вызывать её многократно
- Могут иметь возвращаемое значение <br>
  Оператор return служит для возврата значения с выходом из функции
- Функция может иметь тип возвращаемого значения void

```c++
// Функция без параметров и возвращаемого значения
void SayHello() {
    std::cout << "Hello" << std::endl;
}

// Функция с параметром
void Print(int value) {
    std::cout << value << std::endl;
}

// Функция с параметрами, которая возвращает значение типа int
int Add(int x, int y) {
    return x + y;
}
```

## Объявление и определение функции
```c++
// Объявление функции.
int Add(int x, int y);

int Double(int x) {
    // Чтобы вызвать функцию, она должна быть объявлена до своего вызова
    return Add(x, x);
}

// Определение функции
int Add(int x, int y) {
    return x + y;
}

// Функция, которая не имеет возвращаемого значения
void Print(int x) {
    std::cout << x << std::endl;
}

int main() {
    Print(Double(7)); // Выведет 14
}
```

## Передача параметров по значению
- По умолчанию параметры передаются по значению
1. Функция работает со значением выражения
2. Эффект такой же, как если бы функция работал с копией переданного значения
- Изменение параметра внутри функции не сказывается на значении переданного аргумента

## Передача аргумента по значению
```c++
void TryToChange(int param) {
    param += 42;
    std::cout << "param = " << param << std::endl;
}

int main() {
    int x = 0;
    TryToChangeParam(x);
    std::cout << "x = " << x << std::endl;
}
// param = 42; x = 0;
```
```c++
// Заменяет в строке s все пробелы на символы подчёркивания и возвращает результат.
std::string UnderscoreSpaces(std::string s) {
    for (auto& ch : s) {
        if (ch == ' ') {
            ch = '_';
        }
    }
    // Теперь внутри s все пробелы заменены на подчёркивания.
    return s;
}

int main() {
    using namespace std::literals;
    std::string greeting = "Hello world"s;

    // Напечатает строку "Hello_world".
    std::cout << UnderscoreSpaces(greeting) << std::endl;
    
    // Переменная greeting останется без изменения.
    assert(greeting == "Hello world"s);
}
```

## Передача аргумента по ссылке
```c++
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::getline(std::cin, name);
    // Теперь в name — содержимое введённой строки.
}
```
```c++
#include <std::string>

// Удаляет все пробелы из строки. Параметр str принимается по ссылке.
void RemoveSpaces(std::string& str) {
    size_t dstIndex = 0;
    // Копируем только непробельные символы.
    for (char ch : str) {
        if (ch != ' ') { // Копируем символ, только если это не пробел.
            str[dstIndex] = ch;
            ++dstIndex;
        }
    }
    // Теперь dstIndex хранит позицию в строке, следующую 
    // за последним скопированным символом.
    str.resize(dstIndex); // Отрезаем всё лишнее.
}

using namespace std::literals;
int main() {
    std::string text = "Hello! How are you?"s;
    RemoveSpaces(text);
    // Теперь text хранит строку "Hello!Howareyou?"
}
```
```c++
// Возвращает число, обратное number, то есть 1 / number.
// Произведение числа на обратное ему даёт единицу.
// В переменную, переданную в параметре wasError, будет записан признак ошибки.
double Invert(double number, bool& wasError) {
    double result = 1. / number;
    
    // Функция std::isfinite проверяет, что аргумент – это
    // корректное число double, отличное от NaN и бесконечности. 
    wasError = !std::isfinite(result);
    return wasError ? 0.0 : result;
}

using namespace std::literals;

int main() {
    double number;
    std::cin >> number;
    bool wasError;
    if (double invNumber = Invert(number, wasError); !wasError) {
        std::cout << invNumber << std::endl;
    } else {
        std::cout << "Error"s << std::endl;
    }
}
```

### Ограничения параметров по ссылке
- По ссылке можно передать только реально существующий объект
- Нельзя передать константную переменную.
```c++
void RemoveSpaces(std::string& str) {…}

std::string ReadString() {
    std::string s;
    std::getline(std::cin, s);
    return s;
}

int main() {
    std::string s1 = "Hello! "s;
    std::string s2 = "How are you?"s;
    RemoveSpaces(s1 + s2);        // Ошибка: попытка передать временную строку.

    const std::string const_str = "Hello world!";
    RemoveSpaces(const_str);      // Ошибка: const_str — константная строка. Её нельзя
                                  // передать в функцию, принимающую ссылку на строку.

    RemoveSpaces(ReadString());   // Ошибка: попытка передать временный объект.

    std::string s = ReadString(); // Сохраняем строку в переменную s.
    RemoveSpaces(s);              // А вот так OK.

    std::vector<std::string> strings;
    strings.push_back(s);

    RemoveSpaces(strings[0]);     // Тут тоже всё в порядке. strings[0] — строка 
                                  // в реально существующем массиве.
}
```

## Передача по константной ссылке
- Если объект тяжёлый, то передача по ссылке экономит память и/или время процессора
- Если функция не меняет тяжёлый объект, его следует передать по константной ссылке

## Передача по константной ссылке
```c++
// Выводит строку, обрамлённую кавычками.
// Параметр str передан по константной ссылке.
void PrintQuoted(const std::string& str) {
    std::cout << '"' << str << '"' << std::endl;
}

int main() {
    std::string hello = "Hello "s;
    std::string world = "world"s;

    // Функция PrintQuoted может работать и с временным объектом.
    PrintQuoted(hello + world); 

    // В функцию можно передать и константную переменную.
    const std::string const_str = "Hello world!";
    PrintQuoted(const_str);
}
```

## Простые типы передавайте по значению
```c++
// Возвращает среднее значение между x и y.
// double — простой тип данных, поэтому выгоднее 
// передать его по значению, а не по константной ссылке.
double Middle(double x, double y) {
    return x + (y - x) * 0.5;
}
```

## По ссылке или по значению?
```c++
// Возвращает количество пробелов в строке str.
size_t CountSpaces(/* std::string */ str) {
    size_t num_spaces = 0;
    for (char ch : str) {
        if (ch == ' ') {
            ++num_spaces;
        }
    }
    return num_spaces;
}
```
```c++
// Возвращает true, если n чётное, и false, если нечётное.
bool IsEven(/* int */ n) {
    return (n % 2) == 0;
}

// Возвращает true, если n чётное, и false, если нечётное.
bool IsEven(int n) {
    return (n % 2) == 0;
}
```
```c++
// Обменивает переданные значения.
// Например, Swap(a, b) обменивает значения переменных a и b.
void Swap(/* int */ x, /* int */ y) {
    int tmp = x;
    x = y;
    y = tmp;
}

// Обменивает переданные значения.
// Например, Swap(a, b) обменивает значения переменных a и b.
void Swap(int& x, int& y) {
    int tmp = x;
    x = y;
    y = tmp;
}
```
```c++
// Возвращает модуль (абсолютное значение) числа.
int Abs(/* int */ x) {
    if (x < 0) {
        x = -x;
    }
    return x;
}

// Возвращает модуль (абсолютное значение) числа.
int Abs(int x) {
    if (x < 0) {
        x = -x;
    }
    return x;
}
```
```c++
// Возвращает копию строки str, в которой буквы приведены к нижнему регистру.
// Например, ToLowercase("Hello"s) вернёт строку "hello".
std::string ToLowercase(/* std::string */ str) {
    for (char& ch : str) {
        // Функция std::tolower приводит символ к нижнему регистру.
        ch = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
    }
    return str;
}

// Возвращает копию строки str, в которой буквы приведены к нижнему регистру.
// Например, ToLowercase("Hello"s) вернёт строку "hello".
std::string ToLowercase(std::string str) {
    for (char& ch : str) {
        // Функция std::tolower приводит символ к нижнему регистру.
        ch = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
    }
    return str;
}
```

## Структуры
- Структура - это одна или несколько переменных (возможно, различных типов), которые для удобства работы с ними сгруппированы под одним именем.
- Структуры помогают в организации сложных данных, позволяя группу связанных между собой переменных трактовать не как множество отдельных элементов, а как единое целое
```c++
struct Person
{
    std::string name;
    std::string surname;
    int birthYear;
};
```

```c++
// Структура Point, задающая точку на плоскости
struct Point
{
	int x;
	int y;
};
 
// Поля глобально объявленной структуры по умолчанию инициализируются нулями
Point globalPoint;

int main()
{
	// Объявляем переменную pt, а затем инициализируем ее поля одно за другим
	Point pt;
	pt.x = 10;
	pt.y = 20;
 
	// Объявление переменной-структуры можно совместить
	// с инициализацией ее полей
	Point pt0 = { 33, 24 };
	assert(pt0.x == 33 && pt0.y == 24);
	// Еще один способ инициализации структуры при ее объявлении
	Point pt1{ 14, -22 };
	assert(pt1.x == 14 && pt1.y == -22);
 
	// Недостающие поля при инициализации заполняются нулями
	Point pt2 = { 21 };
	assert(pt2.x == 21 && pt2.y == 0);
	Point pt3 = {};
	assert(pt3.x == 0 && pt3.y == 0);
 
	// Поля глобальных и статических переменных-структур по умолчанию 
	// инициализируются нулями
	static Point pt4;
	assert(pt4.x == 0 && pt4.y == 0);
	assert(globalPoint.x == 0 && globalPoint.y == 0);
}
```

```c++
struct Triangle
{
	Point vertex1;
	Point vertex2;
	Point vertex3;
};

// Инициализация структур, содержащих вложенные структуры
int main()
{
	Triangle t1 = 
	{
		{0, 0}, 
		{20, 100}, 
		{30, 15}
	};
	assert(t1.vertex1.x == 0 && t1.vertex1.y == 0);
	assert(t1.vertex2.x == 20 && t1.vertex2.y == 100);
	assert(t1.vertex3.x == 30 && t1.vertex3.y == 15);

	// Структура, все поля которой будут проинициализированы нулями
	Triangle t2 = {};
	assert(t2.vertex1.x == 0 && t2.vertex1.y == 0);
	assert(t2.vertex2.x == 0 && t2.vertex2.y == 0);
	assert(t2.vertex3.x == 0 && t2.vertex3.y == 0);
} 
```

```c++
// Структуры в качестве параметров функций и возвращаемых значений
double CalculateDistance(const Point & pt1, const Point & pt2)
{
	return hypot(pt1.x - pt2.x, pt1.y - pt2.y);
}
Point CalculateTriangleCenter(const Triangle & triangle)
{
	return {
		(triangle.vertex1.x + triangle.vertex2.x + triangle.vertex3.x) / 3,
		(triangle.vertex1.y + triangle.vertex2.y + triangle.vertex3.y) / 3,
	};
}
int main()
{
	Triangle t0 = {
		{ 0, 0 }, { 10, -20 }, {20, 20}
	};
	auto center = CalculateTriangleCenter(t0);
	assert(center.x == 10 && center.y == 0);
 
	// При передаче в функцию можно создать экземпляр структуры без объявления переменной
	// В этом случае в функцию будет передана ссылка временный объект
	center = CalculateTriangleCenter({ { 0, 0 }, { -20, 10 }, { 20, 20 } });
	assert(center.x == 0 && center.y == 10);
 
	Point pt0{ 1, 1 };
	Point pt1{ 4, 5 };
	double distance = CalculateDistance(pt0, pt1);
	// Проверка чисел с плавающей запятой на приблизительное равенство
	assert(abs(distance - 5.0) <= std::numeric_limits<double>::epsilon());
} 
```

```c++
enum class Month
{
	January, February, March,
	April, May, June,
	July, August, September,
	October, November, December
};
 
struct Date
{
	int day;
	Month month;
	int year;
};

// Person - пример более сложной стуктуры
struct Person
{
	std::string name;
	std::string address;
	Date birthday;
	int height;
};
```
```c++
// Проверка двух дат на равенство
bool Equals(const Date & d1, const Date& d2)
{
	return (d1.day == d2.day) && (d1.month == d2.month) && (d1.year == d2.year);
}
// Проверка двух людей на идентичность
bool Equals(const Person & p1, const Person & p2)
{
	return (p1.name == p2.name) && (p1.address == p2.address) &&
		Equals(p1.birthday, p2.birthday) && p1.height == p2.height;
}
int main()
{
	Person person1 = {
		"Ivanov Ivan", "Suvorova Street, 17", 
		{ 10, Month::March, 1975 }, 185
	};
	Person person2 = {
		"Sergeev Egor",  "Sovetskaya Street, 24",
		{ 11, Month::February, 1990 }, 116
	};
	Person person3 = {
		"Ivanov Ivan", "Suvorova Street, 17",
		{ 10, Month::March, 1975 }, 185
	};
	assert(!Equals(person1, person2));
	assert(!Equals(person2, person3));
	assert(Equals(person1, person3));
}
```

## Инициализация структур
```c++
enum class Gender { MALE, FEMALE, };

struct Person {
    std::string name; // Имя.
    int age;          // Возраст.
    Gender gender;    // Пол.
};

int main() {
    Person person;

    // Используем поля переменной person без предварительной инициализации.
    std::cout << "Name: " << person.name << std::endl;
    std::cout << "Age: " << person.age << std::endl;
    std::cout << "Gender: ";
    if (person.gender == Gender::MALE) {
        std::cout << "Male";
    } else if (person.gender == Gender::FEMALE) {
        std::cout << "Female";
    } else {
        std::cout << "Unknown";
    }
    std::cout << std::endl;
}


// Правильно
struct Person {
    std::string name; // Имя.
    int age = 0;          // Возраст.
    Gender gender = Gender::MALE;    // Пол.
};
```

# Массивы
- Массивы позволяют объявить несколько (один и более) последовательных объектов, объединенных под одним именем, и осуществлять к ним индексированный доступ
- В качестве индексов используются целые числа, или типы, приводимые к целым
- Размер массива задается статически на этапе компиляции и не может быть изменен в ходе работы программы
- Индекс начального элемента массива равен нулю
- Есть возможность объявления многомерных массивов

```c++
#include <cassert>
#include <string>
 
int g_globalArray[3];
int main()
{
  // Глобальные переменные-массивы по умолчанию инициализируются нуляем
  assert(g_globalArray[0] == 0 && g_globalArray[1] == 0 && g_globalArray[2] == 0);
 
  // Массив из 3-х элементов. Элементы не проинициализированы
  float floatNumbers[3];
  floatNumbers[0] = 1.0; floatNumbers[1] = 3.5; floatNumbers[2] = -4.5;
 
  // Массив при объявлении может быть проинициализирован
  [[maybe_unused]] double doubleNumbers[3] = { 3.8, 2.1, 3.53 };
 
  // Элементы массива, не указанные при инициализации, равны нулю
  double zeroFilledArray[3] = { 3.5, 7.2 };
  assert(zeroFilledArray[2] == 0.0);
 
  // Элементы проинициализированы нулями
  [[maybe_unused]] double zeroInitializedArray[3] = { };
 
  // Если не указать размер массива при инициализации, 
  // он будет определен автоматически
  [[maybe_unused]] double arrayOf5Items[] = { 3.5, 8.7, 2.3, -1.25, 0.0 };
 
  std::string name = "John", surname = "Doe";
  // При инициализации элементов массив могут также использоваться выражения
  std::string userNames[] = { "Ivan", "Sergey", name + " " + surname };
  // Так можно определить количество элементов в массиве
  assert(std::size(userNames) == 3);
  assert(userNames[2] == "John Doe");
}
```

### Массивы символов
```c++
void ArrayOfChars()
{
  // Константный массив из 5 элементов
  const char name[] = { 'J', 'o', 'h', 'n', '\0' };
 
  // Неконстантный массив из 4 элементов
  char surname[] = "Doe";
 
  // Константный массив из 6 элементов
  const char hello[6] = "Hello";
}
```

## Определение размера массива
```c++
#include <cassert>
#include <string>
  
void main() {
  std::string userNames[] = { "Ivan", "Sergey",  "Stepan" };
  assert(std::size(userNames) == 3);
 
  const char arr1[] = { 'J', 'o', 'h', 'n', '\0' };
  assert(std::size(arr1) == 5);
 
  char arr2[] = "Doe";
  assert(std::size(arr2) == 4);
}
```

## Многомерные массивы
```c++
#include <cassert>
 
using Matrix2x2 = double[2][2];

void main()
{
  Matrix2x2 mat = {
    {1.0, 2.5},
    {4.5, 3.2}
  };
  assert(mat[0][0] == 1.0);
  assert(mat[0][1] == 2.5);
  assert(mat[1][0] == 4.5);
  assert(mat[1][1] == 3.2);
}
```

### Передача массива в функцию
```c++
#include <cassert>
 
using Matrix2x2 = double[2][2];
 
void Fn(Matrix2x2 mat) {
  mat[0][0] = 3.0;
}
 
struct WrappedMatrix2x2 {
  Matrix2x2 items;
};
 
void Fn2(WrappedMatrix2x2 mat) {
  mat.items[0][0] = 3.0;
}

int main() {
  Matrix2x2 mat = {
    {1.0, 2.5},
    {4.5, 3.2}
  };
  assert(mat[0][0] == 1.0);
 
  // При передаче массива в функцию Fn будет передан оригинал
  Fn(mat);
  // Модификация элементов массива внутри Fn изменит переданный массив
  assert(mat[0][0] == 3.0);
 
  WrappedMatrix2x2 wrappedMat = {
    {
      { 1.0, 2.5 },
      { 4.5, 3.2 }
    } 
  };

  // В функцию Fn2 будет передана копия структуры wrappedMat
  Fn2(wrappedMat);
  // Модификация элементов массива внутри Fn2 не изменит оригинал
  assert(wrappedMat.items[0][0] == 1.0);
}
```

# Ссылки
- Ссылку можно рассматривать как еще одно имя объекта
- При объявлении ссылка должна быть обязательно проинициализирована <br>
  Синтаксис
  `Тип & идентификатор = переменная;`
- Объявление ссылки отличается от операции присваивания
- Инициализация создаёт ссылку, которая ссылается на другой объект
- Операция присваивания изменяет значение объекта, на который ссылается ссылка

```c++
int main() {
  std::string name = "Ivan"; // Это переменная типа std::string

  std::string& refName = name; // Ссылка на переменную name;
  refName += " Ivanov"; // Изменяем переменную name, используя ссылку

  std::cout << name << "\n"; // Ivan Ivanov

  int numbers[] = { 10, 20, 30, 40 };
  for (int i = 0; i < std::size(numbers); ++i) {
    int& currentNumber = numbers[i]; // Ссылка на текущий элемент массива
    currentNumber += 1;
  }

  for (int& number : numbers) { // Перебираем элементы по ссылке
    number += 2;
  }

  for (int number : numbers) {
    std::cout << number << " ";
  } // 13, 23, 33, 43
}
```

### Обмен значений переменных
```c++
#include <iostream>
using namespace std;

// Обменивает значения своих параметров
void Swap(int& a, int& b)
{
	int tmp = a;
	a = b;
	b = tmp;
}

int main()
{
	int a = 1, b = 3;
	cout << "a=" << a << ", b=" << b << endl;
	Swap(a, b);
	cout << "a=" << a << ", b=" << b << endl;
}
```

## Константные ссылки в качестве параметров функций
- Параметр, переданный в функцию по константной ссылке, доступен внутри нее только для чтения
- Если функция не изменяет значение своего аргумента, то имеет смысл передавать его по константной ссылке
- Простые типы данных эффективнее передавать по значению
1. char, short, int, float, double
2. Простые структуры (3-4 примитивных поля)

## Вывод структуры
```c++
struct Point
{
	int x, y;
};

void Print(const Point& pnt)
{
	cout << "(x:" << pnt.x << ", y:" << pnt.y << "\n";
}

int main()
{
	Point pnt = {10, 20};
	Print(pnt);  // Выведет (x:10, y:20)
}
```

## Ссылки на временные объекты
- Если при инициализации ссылка и объект имеют разные типы, создается временная копия нужного типа. Ссылка ссылается на копию
- Ссылка должна быть константной
- То же самое происходит при инициализации ссылки значением константы
- Изменение значения объекта не сказывается на значении временной копии
- Время жизни временного объекта равно области видимости созданной ссылки

Пример1:
```c++
int a = 1;
int & refA = a;			// ссылка на a

cout << "a = " << a << endl;
++refA;
cout << "Now a = " << a << endl << endl; 

const double& refDoubleA = a;	// ссылка на временный объект
cout << "refDoubleA = " << refDoubleA << endl;

// изменение a не оказывает влияния на refDoubleA
++a;
cout << "Now a = " << a << “, refDoubleA = " << refDoubleA << endl;
```

Пример2:
```c++
#include <iostream>

int Add(int x, int y)
{
	return x + y;
}

int main(int argc, char* argv[])
{
	int& wontCompile = Add(10, 20);  // Ошибка компиляции

	const int& result = Add(10, 20); // OK

	std::cout << result << "\n";
	return 0;
}
```

## Определение способа передачи параметра в функцию:

Функция изменяет значение аргумента?

- `Да` <br>
  Изменения должны быть видны вызывающему коду?
1. `Да`  -> `Принимаем аргумент по ссылке`
2. `Нет` -> `Принимаем аргумент по значению`

- `Нет` <br>
  Аргумент легковесный?
1. `Да`  -> `Принимаем аргумент по значению`
2. `Нет` -> `Принимаем аргумент по константной ссылке`

# Пространства имен
- Логически сгруппируют классы, переменные и функции в именованные области
1. Позволяют избежать конфликта имен идентификаторов в различных модулях проекта
2. Разбивают программу на функциональные единицы
- Доступ к идентификатору внутри пространства имен:
  `<namespace>::<identifier>`
1. Либо:
   `using namespace <namespace>; <identifier>;`
2. Либо:
   `using <namespace>::<identifier>; <identifier>;`
3. Не рекомендуется использовать using namespace в заголовочных файлах

```c++
namespace graphics {
namespace shapes {
struct Point {
    int x = 0;
    int y = 0;
};

void Print(Point p) {
    std::cout << p.x << ", " << p.y << "\n";
}
} // namespace shapes

void Draw(shapes::Point p) {
    // ...
}

} // namespace graphics

int main() {
    graphics::shapes::Point p{ 10, 20 };
    Print(p); // Print будет найдена благодаря ADL
    graphics::Draw(p); // Надо указать namespace, т.к. ADL не найдёт Draw

    using graphics::shapes::Point;
    Point p2; // Теперь можно не указывать полное имя для Point
}
```
```c++
namespace game::units
{
struct Monster
{
};
} // namespace game::units

void Test()
{
    using namespace game::units;
    Monster m;
}
```

## Безымянное пространство имён
- Типы, функции и переменные, объявленные в безымянном пространстве имён видны только в текущей единице компиляции
- Полезно для объявления внутренних функций
- Может помочь компилятору сгенерировать более компактный код
```c++
namespace {

struct Data
{
    int value;
};

void ProcessData(Data d)
{
}

} // namespace

int main()
{
    Data d;
    ProcessData(d);
}
```










