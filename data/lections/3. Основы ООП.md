# Основы ООП

## Парадигмы программирования
- Парадигма программирования – способ программирования, не зависящий от конкретного языка
- Стиль программирования как описания намерений программиста
- Модель или подход к решению проблемы
- Современные языки программирования допускают использование разных парадигм

## Структурное программирование
- Последовательное выполнение инструкций
- Явный запрет операции goto
- Ветвление для принятия решений
- Циклы для организации повторяющихся действий

## Процедурное программирование
- Развивает структурный подход
- Последовательно выполняемые операции собираются в подпрограммы: процедуры и функции
- Достоинства
  - Повторное использование кода
  - Улучшение читаемости когда

# Объектно-ориентированное программирование
Парадигма программирования, основанная на представлении предметной области в виде взаимосвязанных абстрактных объектов и их реализаций

## Основные понятия ООП
- Абстракция данных
- Инкапсуляция
- Наследование
- Полиморфизм
- Класс
- Объекты

### Абстракция данных
- Использование только тех характеристики объекта, которые с достаточной точностью описывает его в нашей системе
- Абстракция связывает тип данных с набором операций над ним
  - Пользователь работает с данными не напрямую, а через предоставленный набор операций
- Примеры
  - Класс std:string описывает тип данных «строка» и набор операций над ним
  - Класс Rational описывает тип данных «дробь» и набор операций над дробями
  - Класс Complex описывает «комплексное число» и операции над ним

### Инкапсуляция
- Способность объекта скрывать своё внутреннее устройство
  - Класс рассматривается как черный ящик
- Класс состоит из двух частей: интерфейса и реализации
  - Пользователи класса взаимодействуют только с его интерфейсом
  - Реализация отвечает за сохранение инвариантов класса (непротиворечивое внутреннее состояние объекта)
- Уменьшает число связей между классами и упрощает их независимую реализацию, модификацию и тестирование

```c++
class Car {
public:
  void TurnEngineOn() { m_isTurnedOn = true; }
  bool IsEngineTurnedOn() const { return m_isTurnedOn; }
  void Stop() { m_speed = 0; }
  double GetSpeed() const { return m_speed; }


  bool TurnEngineOff() {
    if (m_speed == 0) {
      m_isTurnedOn = false;
      return true;
    }
    return false;
  }

  bool Drive(double speed) {
    if (m_isTurnedOn && speed >= 0 && speed <= 150) {
      m_speed = speed;
      return true;
    }
    return false;
  }
private:
  bool m_isTurnedOn = false;
  double m_speed = 0;
};
```

### Наследование
- Концепция, при которой новый абстрактный тип данных наследует данные и функциональность существующего типа
- Способствует повторному использованию кода
- Расширение функционала за счёт добавления новых данных и/или операций
- Позволяет строить иерархии классов

```c++
struct Point {
  double x = 0, y = 0;
};

class GameObject {
public:
  Point GetPosition() const { return m_position; }
  void SetPosition(Point pos) { m_position = pos; }
private:
  Point m_position;
};

struct Vector {
  double dx = 0, dy = 0;
};

class Rocket : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) {
    auto pos = GetPosition();
    pos.x += m_speed.dx * timeDelta;
    pos.y += m_speed.dy * timeDelta;
    SetPosition(pos);
  }
private:
  Vector m_speed;
};

int main() {
  Rocket r;
  r.SetSpeed({.dx = 10, .dy = 20});
  r.Update(1);
  auto pos = r.GetPosition();
  std::cout << pos.x << ", " << pos.y << "\n";
}
```

### Полиморфизм
- Полиморфизмом – возможность работать с разными реализациями через один интерфейс
  - Полиморфизм позволяет обрабатывать объекты классов-потомков как однотипные объекты, даже если реализация их методов различается

```c++
struct Point { … };

class GameObject
{
public:
  Point GetPosition() const { return m_position; }
  void SetPosition(Point pos) { m_position = pos; }

  virtual void Update(double timeDelta) {}

private:
  Point m_position;
};

struct Vector { … };

Point MovePoint(Point p, Vector speed, double timeDelta)
{
  p.x += speed.dx * timeDelta;
  p.y += speed.dy * timeDelta;
  return p;
}
```

```c++
class Rocket : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) override {
    SetPosition(MovePoint(GetPosition(), m_speed, timeDelta));
  }

private:
  Vector m_speed;
};

constexpr double GravityConstant = 9.8;

class Ball : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) override {
    m_speed.dy -= timeDelta * GravityConstant;
    SetPosition(MovePoint(GetPosition(), m_speed,
                          timeDelta));
  }

private:
  Vector m_speed;
};

void UpdateGameObject(GameObject& gameObj) {
  gameObj.Update(10);
}

int main()
{
  Rocket r;
  Ball b;
  b.SetSpeed({ .dx = 10, .dy = 20 });
  r.SetSpeed({ .dx = 10, .dy = 20 });
  UpdateGameObject(r);
  UpdateGameObject(b);
}
```

```c++
#include <cassert>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>

struct Point
{
  int x = 0;
  int y = 0;
};

Point ReadPoint(std::istream& input)
{
  Point p;
  input >> p.x >> p.y;
  return p;
}

void WritePoint(std::ostream& output, Point p)
{
  output << p.x << " " << p.y;
}

int main()
{
  std::istringstream in("3 5 8 10");
  Point p1 = ReadPoint(in);
  assert(p1.x == 3 && p1.y == 5);
  Point p2 = ReadPoint(in);
  assert(p2.x == 8 && p2.y == 10);
  {
    std::ofstream out("points.txt");
    WritePoint(out, p1);
    out << " ";
    WritePoint(out, p2);
  }

  std::ifstream inputFile("points.txt");
  Point p3 = ReadPoint(inputFile);
  Point p4 = ReadPoint(inputFile);
  assert(p3.x == p1.x && p3.y == p1.y);
  assert(p4.x == p2.x && p4.y == p2.y);

  Point p5 = ReadPoint(std::cin);
  WritePoint(std::cout, p5);
}
```

```c++
class Shape {
public:
  virtual ~Shape() = default;
  Color GetColor() const { return m_color; }
  void SetColor(Color c) { m_color = c; }
  virtual double GetArea() const = 0;
private:
  Color m_color = Color::Red;
};
 
class Circle : public Shape {
public:
  double GetArea() const override { return M_PI * m_radius * m_radius; }
  double GetRadius() const { return m_radius; }
  void SetRadius(double r) { m_radius = r; }
private:
  double m_radius = 1.0;
};

void PrintShapeInfo(const Shape& s) {
  std::cout << "Color:" << s.GetColor() << "\n";
  std::cout << "Area:" << s.GetArea () << "\n";
}
```

# Анатомия класса

## Классы и объекты
- В ООП вводится понятие Класса – пользовательского типа данных, объединяющего данные и методы их обработки
  - Класс – тип, описывающий устройство объекта
- Объектом называется экземпляр класса
  - Собака – это класс
  - Собака Жучка из 3 подъезда – это объект, представитель или экземпляр класса «Собака»
  - Чертеж дома – класс, построенный по нему дом - объект

### Объявление класса в С++
```c++
class Car
{
  // Поля класса (данные и методы)
};

// Использование класса
int main()
{
  Car car1;
  Car car2;
}
```

## Данные объекта (переменные объекта, члены-данные)
- Члены-данные (data members) хранят всю необходимую информацию об объекте, формируют его состояние, характеристики и т.п.
- Изменение состояния объекта или его характеристик связано с изменением данных, в нем содержащихся

Пример - Автомобиль
```c++
enum class MakeOfCar {
  Toyota, Mitsubishi, Ford, Volkswagen,
};
 
enum class Color {
  Red, Green, Blue, Black,
};
 
class Car
{
  MakeOfCar m_make = MakeOfCar::Toyota;
  int m_yearOfManufacture = 2019;
  Color m_color = Color::Black;
  double m_fuel = 0;
};
```

Пример - Время
```c++
class Time
{
  int m_hours = 0;
  int m_minutes = 0;
  int m_seconds = 0;
};

class Time
{
  int m_secondsSinceMidnight = 0;
};
```

## Сокрытие данных по умолчанию
- В отличие от структур, по умолчанию доступ к содержимому класса закрыт
  - Снаружи класса нельзя обратиться к его данным

```c++
void Test()
{
  Time t;
  t.m_secondsSinceMidnight = 42;
  // error: cannot access private member declared in class 'Time'
}
```

## Ограничение доступа к содержимому классов и структур
- Каждое поле класса или структуры имеет определённый уровень доступа
- public – публичный уровень доступа. Можно обращаться отовсюду
  - В структурах это уровень доступа по умолчанию
- private – приватный (закрытый) уровень доступа. Нельзя обращаться из кода за пределами класса
  - В классах это уровень доступа по умолчанию
- protected – защищённый уровень доступа. Обращаться может сам класс и его наследники

```c++
// Структура глазами компилятора
struct Time
{
  // Этот спецификатор public неявно подразумевается внутри struct.
public:
  // Всё, что ниже public:, доступно для внешнего кода.
  int hours = 0;
  int minutes = 0;
  int seconds = 0;
};
```

```c++
// Класс глазами компилятора
class Time
{
  // Этот спецификатор private неявно подразумевается внутри class.
private:
  // Всё, что ниже private:, скрыто от внешнего мира.
  int m_hours = 0;
  int m_minutes = 0;
  int m_seconds = 0;
};
```

## Методы
- Вместо прямого доступа к своим данным класс предоставляет методы
- Метод – функция, объявленная внутри класса или структуры
  - Методы также называют функциями-членами класса (class member functions)
- Методы класса задают операции, которые можно выполнить над объектом
- В классах методы делают публичными, а данные – приватными

### Объявление метода класса
```c++
class SomeClass {
public:
  // Это метод класса. Выглядит как функция, описанная внутри класса.
  void SetData(int data) {
    // К приватным данным можно обращаться только внутри методов класса.
    m_data = data;
  }

private:
  // Данные надёжно спрятаны от внешнего мира.
  // Никто, кроме самого класса, не имеет к ним доступа.
  int m_data = 42;
};
```

```c++
class Time
{
public:
  int GetHours() { return m_secondsSinceMidnight / 3600; }
  int GetMinutes() { return (m_secondsSinceMidnight / 60) % 60; }
  int GetSeconds() { return m_secondsSinceMidnight % 60; }

  bool SetTime(int hours, int minutes, int seconds)
  {
    if (hours < 0 || hours >= 24 || minutes < 0 || minutes >= 60 
       || seconds < 0 || seconds >= 60) {
      return false;
    }

    m_secondsSinceMidnight = hours * 60 * 60 + minutes * 60 + seconds;
    return true;
  }

private:
  int m_secondsSinceMidnight = 0;
};
```

```c++
class Circle
{
public:
  void SetRadius(double r)
  {
    m_radius = r;
  }
  double GetRadius() { return m_radius; }
  double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
  double m_radius = 0;
};

int main()
{
  Circle c;
  c.SetRadius(20);
  std::cout << c.GetArea() << std::endl;
}
```

## Методы и состояние класса
- Состояние объекта формируется его членами данными
- Чтобы изменить состояние объекта, нужно изменить его данные
- Когда данные приватные, сделать это можно только в методе класса

### Как быть с константными объектами?
- Когда объект константный, его состояние должно быть нельзя изменить
- Если метод может изменить состояние объекта, значит его нельзя вызвать у константного объекта
- Как быть?

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() { return m_radius; }
    double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

## Константные методы
- Метод, внутри которого не разрешается менять состояние объекта, помечают константным с помощью спецификатора const
- Внутри const-метода нельзя менять состояние объекта
  - Присваивать значения полям класса
  - Вызывать неконстантные методы текущего объекта
  - Вызвать у поля текущего объекта неконстантный метод
  - Передать поле класса в функцию, принимающую аргумент по неконстантной ссылке
- К константных объектов разрешается вызывать только константные методы
  - То же самое касается объектов, доступных по константной ссылке

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() const { return m_radius; }
    double GetArea() const { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

## Физическая и логическая константность

- Физическая константность
  - Объект объявлен как const
  - Его состояние не изменяется
- Логическая константность
  - Объект неизменен внешне
  - Внутреннее состояние может меняться
    - Объект может кешировать данные


## Изменчивые (mutable) данные класса
- Спецификатор mutable разрешает изменять поле, даже если содержащий объект объявлен константным
  - Mutable-поля можно изменять внутри константных методов
- Означает, что поле не влияет на наблюдаемое извне состояние класса
  - Мьютексы
  - Кеширование вычисленных значений
  - Ленивые вычисления

```c++
size_t GetHash(const std::string& s) {
  std::hash<std::string> hasher;
  return hasher(s);
}

class PasswordCracker {
public:
  std::string CrackPassword(size_t hash, size_t maxChars) const {
    std::string prefix;
    return CrackPassword(prefix, hash, maxChars);
  }
private:
  std::string CrackPassword(std::string& prefix, size_t hash, size_t maxChars) const {
    if (GetHash(prefix) == hash) {
      return prefix; // Пароль найден
    }
    if (maxChars == 0)
      return {}; // Пароль не найден, перебор закончен

    for (char ch = 'A'; ch <= 'Z'; ++ch) {
      prefix += ch;
      if (auto pass = CrackPassword(prefix, hash, maxChars - 1); !pass.empty())
        return pass;
      prefix.pop_back();
    }
    return {};
  }
};
```

## Мьютекс
- Мьютекс – примитив синхронизации, разрешающий доступ к объекту только одному из потоков
  - std::mutex
- Когда в классе содержится мьютекс, его практически всегда помечают mutable

## Используйте mutable-поля аккуратно
- Используйте mutable, чтобы обеспечить логическую константность
- Наблюдаемое состояние должно оставаться неизменным, когда объект меняет внутреннее состояние
- Не нарушайте правила доступа к константным объектам

```c++
class Mutable
{
public:
  int GetValue() const
  {
    if (m_value == -1)
    {
      m_value = 42;
    }
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Mutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Mutable::Change"
              << std::endl;
  }
private:
  mutable int m_value = -1;
  int m_counter = 0;
};
```

```c++
class Immutable
{
public:
  int GetValue() const
  {
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Immutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Immutable::Change"
              << std::endl;
  }
private:
    int m_value = 42;
    int m_counter = 0;
};
```

```c++
const Mutable mut;
const Immutable immut;

int main()
{
    std::cout << "Immutable: " << &immut << " - " << immut.GetValue() << std::endl;
    std::cout << "  Mutable: " << &mut << " - " << mut.GetValue() << std::endl;

    const_cast<Mutable&>(mut).Change();
    std::cout << mut.GetCounter() << std::endl;

    const_cast<Immutable&>(immut).Change();
    std::cout << immut.GetCounter() << std::endl;
}
```

## Размещение классов в файлах
- Общепринятой практикой является размещение объявления классов в заголовочных файлах .h, а их реализации – в файлах .cpp
  - Облегчается использование класса
  - Легко найти класс
- Каждый класс может быть подключен для дальнейшего использования при помощи директивы #include "имя заголовочного файла"
  - При внесении изменений в реализацию метода класса перекомпиляции подвергнутся только измененные файлы

## Спецификаторы уровня доступа
- Public-методы и данные класса определяют его интерфейс
  - доступ к ним возможен из любой части кода
  - Public-область определяет то, как класс может использоваться пользователями класса
- Размещайте в публичной области класса только необходимый набор операций высокого уровня
- Вызов public-метода должен переводить объект из одного валидного состояния в другое валидное состояние, либо не менять состояние объекта
- Публичные данные – чаще всего, плохая практика
  - Класс сам должен управлять своими данными

## Закрытые (приватные) поля и методы класса
- Private-данные и методы класса определяют его реализацию 
  - Доступ разрешен только из методов этого класса
- Рекомендуется все данные класса делать закрытыми, их обработку осуществлять внутри методов
- Закрытые методы класса обычно используются публичными и защищенными методами, решая внутренние задачи класса
  - Если приватный метод не используется, удалите его

```c++
class Time {
public:
    … 
    bool Set(int hours, int minutes, int seconds) {
        if (hours < 0 || hours >= 24 || minutes < 0
            || minutes >= 60 || seconds < 0 || seconds >= 60) {
            return false;
        }

        // Вызываем приватный метод.
        SetUnchecked(hours, minutes, seconds);
        return true;
    }

    void SetMidnight() {
        SetUnchecked(0, 0, 0);
    }

private:
    // Приватный метод. Устанавливает время, не проверяя аргументы.
    void SetUnchecked(int hours, int minutes, int seconds) {
        m_seconds = (hours * 60 + minutes) * 60 + seconds;
        return ;
    }

    int m_seconds = 0;
};
```

## Защищенные поля класса
- Protected-данные и методы определяют интерфейс для производных классов
  - Доступ к ним разрешен изнутри методов данного класса и всех его потомков
- В защищенной зоне размещают методы, которые не должны быть видны снаружи класса, но реализация которых может быть переопределена или использована производными классами

## Свойства
- Свойство – составляющая часть объекта, доступ к которой осуществляется программистом как к полю
  - При записи свойства можно выполнить валидацию или преобразование входных данных
  - При чтении свойства можно вычислить результат
- Свойства могут быть доступны на чтение, запись или на чтение и запись
- Отладчик может IDE может отображать значения свойств наравне со значениями полей
  - Getter-ы свойств не должны иметь видимых побочных эффектов
- В C++ и некоторых других языках программирования свойства, как элемент языка, отсутствуют
  - В этом случае эмулируют свойства за счёт get- и  set- методов

### Пример – свойства в языке C#
```c++
public class TimePeriod
{
    private double _seconds;

    public double Hours
    {
        get { return _seconds / 3600; }
        set
        {
            if (value < 0 || value >= 24)
                throw new ArgumentOutOfRangeException(nameof(value),
                      "The valid range is between 0 and 24.");

            _seconds = value * 3600;
        }
    }
}
```

```c++
internal class Circle
{
    private double _radius = 0;
    public double Radius
    {
        get { return _radius; }
        set
        {
            if (value < 0) throw new ArgumentException("Radius must not be negative");
            _radius = value;
        }
    }

    public double Area
    {
        get { return Radius * Radius * Math.PI; }
    }

    public Circle(double radius)
    {
         if (radius < 0) throw new ArgumentException("Radius must not be negative");
        _radius = radius;
    }
}

Circle c = new(10);
c.Radius = 3;

Console.WriteLine("Area:" + c.Area.ToString());
```

```c++
internal class Counter
{
    private int _value = 0;

    // Поле _value будет увеличиваться всякий раз, когда происходит чтение свойства Value.
    // Даже, если просматривать его под отладчиком.
    // Это может вызвать удивление.
    public int Value {  get { return _value++; } }

    // Это свойство будет долго вычисляться при просмотре под отладчиком.
    public int LongCalculation
    {
        get
        {
            int sum = 0;
            for (int i = 0; i < 1000000000; ++i)
            {
                ++sum;
            }
            return sum;
        }
    }
}
```

```c++
class Point
{
public:
  double x, y;
};
 
class Triangle
{
public:
  double GetArea() const;
  double GetPerimeter() const;
  Point GetCenter() const;
 
  void Move(double dx, double dy);
  void Scale(double sx, double sy);
  void Rotate(Point center, double angle);
 
private:
  Point m_p0, m_p1, m_p2;
};
```

## Какие данные должен иметь Rectangle?
```c++
struct Point
{
  double x;
  double y;
};
 
class Rectangle
{
public:
  Point GetLeftTop() const;
  Point GetRightBottom() const;
  double GetWidth() const;
  double GetHeight() const;
  /* прочие методы */
private:
  /* данные */
};
```

## Указатель this

### Отличие методов от функций
- Методы объявляются внутри класса. Могут быть определены как внутри, так и снаружи
- Методы могут без ограничений обращаться к приватным и защищённым методам этого же класса
- Могут быть виртуальными и чисто виртуальными
- При вызове метода нужно указывать ассоциированный объект

```c++
struct Point {
    double x = 0, y = 0;
};

struct Vector {
    double x = 0, y = 0;
};

// Функция принимает ссылку на точку, которую нужно переместить.
void MovePoint(Point& p, Vector offset) {
    p.x += offset.x;
    p.y += offset.y;
}

int main() {
    Point p1, p2;

    // Сдвигаем точку p1 на вектор с координатами (1, 2.5).
    MovePoint(p1, {1, 2.5});

    // Сдвигаем точку p1 на вектор с координатами (-1, -1).
    MovePoint(p2, {-1, -1});
}
```

```c++
struct Vector {
    double x = 0, y = 0;
};

struct Point {
    double x = 0, y = 0;

    void MoveBy(Vector v) {
        // Внутри метода обращаемся к своим полям, указывая их имена.
        x += v.x;
        y += v.y;
    }
};

int main() {
    Point p1, p2;

    // Для вызова метода указываем объект.
    p1.MoveBy({1, 2.5});
    p2.MovePoint({-1, -1});
}
```

### Ссылка на себя
- Внутри методов класса для обращения к данным и методам можно использовать их имена
- В метод класса неявно передается указатель на объект, для которого он вызывается
  - Этот указатель указатель доступен по ключевому слову this

```c++
// Структура глазами компилятора
struct Point {
    double x = 0, y = 0;

    // Первым параметром в метод передаётся неявный параметр this.
    void MoveBy(/* Point* const this, */ Vector v) {
        // При обращении к полям и методам через this вместо точки
        // используется стрелочка ->, состоящая из символов - и >.
        this->x += v.x;
        this->y += v.y;
    }
};
```

```c++
struct Point {
    double x = 0, y = 0;

    void Set(double x, double y) {
        // Область видимости параметров x и y ограничена 
        // методом Point::Set. Поэтому внутри метода Set 
        // имена x и y относятся к параметрам, а не к полям.

        // Когда мы пишем this->x и this->y, то явно сообщаем 
        // компилятору, что обращаемся к полям текущего объекта.
        this->x = x;
        this->y = y;

        // Если напишем x = x, то присвоим параметру x его собственное значение.
    }
};
```

### Когда в C++ использовать this внутри методов классов?
- Используйте this, если должны. Во всех остальных случаях не используйте
  - Не надо превращать C++ в javascript
- Когда нужно писать this?
  - Если нужно вернуть или передать ссылку или указатель на текущий объект
  - Если в шаблонном классе нужно обратиться к методу или полю базового класса, зависящему от шаблонного параметра

```c++
struct Vector
{
  double x = 0, y = 0;

  // Оператор += возвращает ссылку на текущий объект,
  // чтобы можно было использовать цепочку вызовов:
  // Vector v1, v2, v3;
  // v1 += v2 += v3;
  Vector& operator+=(Vector const& other)
  {
    x += other.x;
    y += other.y;
    
    return *this;
  }
};
```

```c++
template <typename T>
class Base {
public:
    void SetValue(T v) {
        m_value = v;
    }

protected:
    T m_value = {};
};

template <typename T>
class Derived : public Base<T> {
public:
    void PrintValue() {
        // Без this-> будет ошибка компиляции
        std::cout << this->m_value << std::endl;
    }
};

int main() {
    Derived<int> derived;
    derived.PrintValue();
}
```

## Инициализация класса

### Начальное состояние объекта
- Состояние экземпляра класса определяется значением его полей
- Поля класса делают приватными, чтобы нельзя было нарушить инварианты класса
- Вызов публичного метода переводит объект из одного валидного состояния в другое валидное
  - Либо не изменяет состояние объекта
- Следствие: после своего создания объект должен быть в валидном состоянии
  - Для этого должен выполниться некоторый код


```c++
class Rational
{
public:
  int GetNumerator() const {
    return m_numerator;
  }

  int GetDenominator() const {
    return m_denominator;
  }

  void SetNumerator(int numerator) {
    m_numerator = numerator;
  }

  void SetDenominator(int denominator) {
    if (denominator != 0) {// Знаменатель не может быть равен нулю
      m_denominator = denominator;
    }
  }
private:
  int m_numerator = 0; // Числитель
  int m_denominator = 1; // Знаменатель
};
```

```c++
int main()
{
  Rational four;
  four.SetNumerator(4);

  // Создаём дробь 2/3 в три шага:
  Rational twoTrird; // 1. Объявляем переменную
  twoTrird.SetNumerator(2); // 2. Задаём числитель
  twoTrird.SetDenominator(3); // 3. Задаём знаменатель
}

const Rational two_third;

two_third.SetNumerator(2);   // <-- Ошибка.
two_third.SetDenominator(3); // <-- Ошибка.
```

## Конструктор
- Специальная функция-член класса для инициализации объекта в момент его создания
- Конструктор вызывается один раз в момент создания экземпляра класса (объявление переменной класса или вызов оператора new)
- В классе может быть несколько конструкторов, чтобы инициализировать по-разному
  - Они должны различаться количеством или типами аргументов
  - Для инициализации объекта может быть вызван только один из них

```c++
class Rational {
public:
  // Это конструктор, который инициализирует дробь нужными
  // значениями числителя и знаменателя.
  Rational(int numerator, int denominator)
  {
    assert(denominator != 0);
    m_numerator = numerator;
    m_denominator = denominator;
  }
  …
private:
  int m_numerator;
  int m_denominator;
};

int main() {
  // Конструктор можно вызвать, создав объект.
  // Параметры можно передать в фигурных скобках.
  Rational half{ 1, 2 };

  // После работы конструктора Rational поля
  // получили переданные в параметрах значения.
  assert(half.GetNumerator() == 1 && half.GetDenominator() == 2);

  // Вызвать конструктор явно нельзя.
  // Единственный способ — создать новый объект.
  half.Rational(10, 15); // <-- Ошибка!
}
```

## Конструктор по умолчанию
- Некоторые объекты могут иметь состояние по умолчанию
  - Пустая строка
  - Пустой вектор
  - Точка в начале координат
- Конструктор, не имеющий параметров, называется конструктором по умолчанию
  - Поля данных в таком конструкторе инициализируются значениями по умолчанию
- Может быть неявно сгенерирован компилятором
  - Если не объявлены другие конструкторы

### Объявление конструктора по умолчанию
```c++
class TV
{
public:
  TV()
  {
    m_isTurnedOn = false;
    m_currentChannel = 1;
  }
private:
  bool m_isTurnedOn;
  int m_currentChannel;
};
```

Можно проще:
```c++
class TV
{
public:
  /*Компилятор сгенерирует конструктор по умолчанию*/
private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
```

### Автоматическое генерирование конструктора по умолчанию
```c++
class TV {
public:
 // Явно объявив конструктор с параметрами,
  // запрещаем компилятору неявно создать конструктор по умолчанию
  TV(bool isTurnedOn, int currentChannel)
  {
    assert(currentChannel > 0 && currentChannel < 100);
    m_isTurnedOn = isTurnedOn;
    m_currentChannel = currentChannel;
  }

  // Явно просим компилятор сгенерировать конструктор по умолчанию
  TV() = default;
 
private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
```

## Список инициализации конструктора

### Момент вызова конструктора
```c++
#include <iostream>

using namespace std;

class Alice {
public:
    Alice() { std::cout << "Alice is created"s << std::endl; }
};

class Bob {
public:
    Bob() { std::cout << "Bob is created"s << std::endl; }
};

int main() {
    std::cout << "Enter main"s << std::endl;
    Alice alice;
    Bob bob;
    Alice alice2;
    std::cout << "Exit main"s << std::endl;
}
```

### Инициализация полей класса
```c++
class Carol {
public:
    Carol() { std::cout << "Carol is created"s << std::endl; }
private:
    // Теперь Алиса и Боб — поля класса Carol.
    Alice m_alice;
    Bob m_bob;
};

int main() {
    std::cout << "Enter main"s << std::endl;
    Carol carol;
    std::cout << "Exit main"s << std::endl;
}
```

### Проблема инициализации полей класса
```c++
class Alice {
public:
    Alice() {
        std::cout << "Alice is created"s << std::endl;
    }
    Alice(int age) {
        std::cout << "Alice("s << age << ") is created"s << std::endl;
    }
};

class Carol {
public:
    Carol(int age) { 
        std::cout << "Carol is created"s << std::endl; 
        m_alice = Alice(age);
    }

private:
    Alice m_alice;
};
```

### Как проинициализировать поле, если его тип не имеет конструктора по умолчанию
```c++
class Alice {
public:
    Alice(int age) {
        std::cout << "Alice("s << age << ") is created"s << std::endl;
    }
};

class Carol {
public:
    Carol(int aliceAge) { 
        std::cout << "Carol is created"s << std::endl; 
        m_alice = Alice(aliceAge);
    }

private:
    Alice m_alice; // Ошибка! Не можем создать объект без
                   // параметров конструктора.
};
```

### Инициализация данных экземпляра класса
- В качестве данных класса могут выступать другие классы
  - Их инициализация осуществляется ДО выполнения тела конструктора
  - Для их инициализации вызываются конструкторы по умолчанию
- Инициализация полей значением по умолчанию не всегда подходит
  - В классе может не быть конструктора по умолчанию
  - Поле класса может быть константой или ссылкой
- На помощь приходят списки инициализации

### Списки инициализации
- Применяются для инициализации полей класса в конструкторе ДО выполнения его тела
- Использование списков инициализации – единственное решение в случае, когда класс содержит внутри себя
  - поля, являющиеся классами без конструкторов по умолчанию
  - константы
  - ссылки

### Список инициализации в действии
```c++
class Carol {
public:
    Carol(int aliceAge)
        : m_alice{aliceAge} // Вызывается конструктор Alice::Alice(int age).
        , m_name("Luis")   // Инициализируем поле строкового типа.
    {
        std::cout << "Carol is created"s << std::endl; 
    }

    std::string GetName() const {
        return m_name;
    }
private:
    Alice m_alice;
    Bob m_bob;
    std::string m_name;
};

int main() {
    Carol carol{17};
    std::cout << "Name: " << carol.GetName() << std::endl;
}
```

```c++
class TV {
public:
    void TurnOn() { /* ... */ }
};

class RemoteControl {
public:
    RemoteControl(TV& tv, std::istream& input, std::ostream& output)
        : m_tv{ tv }, m_input{input}, m_output{output}
    { }

    bool ExecuteCommand() const {
        std::string command;
        std::getline(m_input, command);
        if (command == "TurnOn") {
            m_tv.TurnOn();
            m_output << "TV is turned on" << std::endl;
            return true;
        }
        return false; // Команда не найдена
    }

private:
    TV& m_tv;
    std::istream& m_input;
    std::ostream& m_output;
};

int main()
{
    TV tv;
    RemoteControl remoteControl{ tv, std::cin, std::cout };
    remoteControl.ExecuteCommand();
}
```

## Converting Constructor
- Конструктор, не объявленный с ключевым словом explicit – называется конвертирующим конструктором
- Конвертирующий конструктор неявно преобразует свои аргументов к типу класса, где этот конструктор объявлен

```c++
class Complex {
public:
  Complex(double re = 0.0, double im = 0.0) {
    m_re = re;
    m_im = im;
  }
  double Re() const { return m_re; }
  double Im() const { return m_im; }
 
private:
  double m_re = 0.0;
  double m_im = 0.0;
};
 
Complex Add(Complex a, Complex b) {
  return {a.Re() + b.Re(), a.Im() + b.Im()};
}
 
int main() {
  auto result = Add(3, {1.2, 2.3}); // 4.2+2.3i
  Complex a = 3.2;                  // 3.2+0.i
  Complex b = { 2, 7.3 };           // 2+7.3i
  Complex c;                        // 0+0i
  Complex d = {};                   // 0+0i
}
```

```c++
class TV {
public:
  TV() = default;
 
  TV(bool isTurnedOn)
    : m_isTurnedOn{ isTurnedOn } {
  }

private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
 
void PrintInfo(const TV& tv) { /* ... */ }
 
int main() {
  TV tv{ /* isTurnedOn = */ true };
  PrintInfo(tv);
  TV tv1 = true;   // WTF?
  PrintInfo(true); // WTF?
}
```


```c++
class TV {
public:
  TV() = default;
 
  explicit TV(bool isTurnedOn)
    : m_isTurnedOn{ isTurnedOn } {
  }

private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
 
void PrintInfo(const TV& tv) { /* ... */ }
 
void Test() {
  TV tv = true;    // Ошибка компиляции
  PrintInfo(true); // Ошибка компиляции
}
```

### Explicit or Implicit?
- Если конструктор имеет один параметр, то очень часто его нужно пометить ключевым словом explicit
  - Кроме случаев, когда необходимо неявное преобразование
- Если конструктор имеет несколько параметров, не помечайте его ключевым словом explicit
- C.46: By default, declare single-argument constructors explicit

## Деинициализация экземпляра класса
- В ходе своей работы объект может использовать определенные системные ресурсы
  - Динамическая память, открытые файлы, сетевые соединения и т.п.
- При разрушении объекта используемые им единолично ресурсы должны освобождаться
- В C++ для освобождения этих ресурсов служит особый метод класса – деструктор

### Деструктор
- Имя деструктора совпадает с именем класса, только перед ним указывается символ ~ (тильда)
- Деструктор вызывается автоматически при уничтожении экземпляра класса:
  - Выход за пределы блока, в котором объявлен экземпляр класса
  - Вызов оператора delete или delete []

### Содержимое тела деструктора
- В деструкторе  программист размещает код, выполняющий действия, завершающие жизненный цикл объекта
  - Освобождение выделенных объектом ресурсов
  - Что-нибудь еще

```c++
class String {
public:
    String() noexcept : m_chars{ s_emptyString } { }

    String(const char* text)
        : m_size{ std::strlen(text) }, m_capacity{ m_size }
        , m_chars{ Allocate(m_capacity + 1) } {
        std::uninitialized_copy_n(text, m_size + 1, m_chars);
    }

    ~String() {
        if (m_chars != s_emptyString) {
            std::destroy_n(m_chars, m_size + 1);
            Deallocate(m_chars);
        }
    }
private:
    static char* Allocate(size_t size) {
        return static_cast<char*>(operator new(size));
    }
    static void Deallocate(char* buffer) noexcept {
        operator delete(buffer);
    }

    inline static char s_emptyString[] = { '\0’ };

    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

### Жизнь после смерти
- В C++ после выполнения тела деструктора происходит автоматический вызов деструкторов членов-данных класса
  - Порядок  вызова деструкторов  полей данных обратен порядку их объявления внутри класса
- Если класс был унаследован от другого класса, будет вызван деструктор родительского класса
  - И т.д. по цепочке
- После этого происходит освобождение занимаемой объектом памяти

Класс «Колесо»
```c++
class Wheel
{
public:
	Wheel(string const& name)
		:m_name(name)
	{
		cout << "Constructing wheel " << m_name << "\n";
	}
	~Wheel()
	{
		cout << "Destroying wheel " << m_name << "\n";
	}
private:
	string m_name;
};
```

Класс «Автомобиль»
```c++
class Car
{
public:
	Car(string const& name):m_name(name)
		,m_frontRight("Front right“),m_rearLeft("Rear left")
		,m_rearRight("Rear right“),m_frontLeft("Front left")
	{
		cout << "Constructing car " << m_name << "\n";
	}
	string GetName()const
	{
		return m_name;
	}
	virtual ~Car()
	{
		cout << "Destroying car " << m_name << "\n";
	}
private:
	string m_name;
	Wheel m_frontLeft;
	Wheel m_frontRight;
	Wheel m_rearLeft;
	Wheel m_rearRight;
};
```

Класс «Супер автомобиль»
```c++
class SuperCar : public Car
{
public:
	SuperCar(string const& name)
		:Car(name)
		,m_fifthWheel("Fifth wheel")
	{
		cout << "Constructing super car " << name << "\n";
	}

	~SuperCar()
	{
		cout << "Destroying super car " << GetName() << "\n";
	}
private:
	Wheel m_fifthWheel;
};
```

### Автоматически сгенерированный деструктор
- Создается компилятором, если в классе не был явно объявлен деструктор
- Автоматически сгенерированный  деструктор  имеет пустое тело
  - Остальные механизмы разрушения объекта работают обычным образом
- Деструктор  примитивных объектов
  - Разрушение обычного указателя не выполняет удаление объекта (объектов), на который он ссылается
    - Деструкторы «умных» указателей выполняют необходимые операции для удаления объекта

## Копирование объектов

### Конструктор копирования (копирующий конструктор)
- В языке C++ существует специальный тип конструкторов, использующийся для создания копии объекта
  - Явное создание копии объекта программистом
  - Неявное создание копии объекта
    - Возврат объекта из функции
    - Передача объекта в функцию по значению
    - Во время работы механизма исключений
- Синтаксис
  - Type(Type const& t);

```c++
class PostCard {
public:
    PostCard(const std::string& text)
        : m_text{ text }
    {
        std::cout << "Post card was created: " << m_text << std::endl;
    }

    // Копирующий конструктор
    PostCard(const PostCard& other)
        : m_text{ other.m_text }
    {
        std::cout << "Post card is copied: " << m_text << std::endl;
    }
    ~PostCard() { std::cout << "Post card was destroyed: " << m_text << std::endl; }

    const std::string& GetText() const { return m_text; }

    void SetText(const std::string& text) { m_text = text; }

private:
    std::string m_text;
};
```

```c++
PostCard MakeModifiedPostCard(PostCard postCard) {
    std::cout << "Enter MakeModifiedPostCard" << std::endl;

    postCard.SetText(postCard.GetText() + " - modified");

    std::cout << "Exit MakeModifiedPostCard" << std::endl;
    return postCard;
}

int main()
{
    PostCard postCard{ "Hello" };
    auto modifiedPostCard = MakeModifiedPostCard(postCard);
    std::cout << modifiedPostCard.GetText() << std::endl;
}
```

### Copy Elision (устранение копирования)
- Оптимизация компилятора, при которой копирование или перемещение объекта пропускается, даже при наличии у класса копирующего конструктора
- Позволяет избегать ненужного создания временных объектов
- Начиная с C++17 copy elision обязателен

#### Copy Elision
```c++
PostCard MakeModifiedPostCard(PostCard postCard) {
    std::cout << "Enter MakeModifiedPostCard" << std::endl;
    postCard.SetText(postCard.GetText() + " - modified");
    std::cout << "Exit MakeModifiedPostCard" << std::endl;
    return postCard;
}

int main()
{
    auto modifiedPostCard = MakeModifiedPostCard("Hello"s);
    std::cout << modifiedPostCard.GetText() << std::endl;
}
```

### Автоматически сгенерированный конструктор копирования
- Если программист не определит конструктор копирования явно, компилятор сгенерирует его во время компиляции
- Автоматически сгенерированный конструктор копирования копирует все поля класса, вызывая для них их конструкторы копирования

```c++
struct Envelope {
    PostCard postCard;
};

Envelope MakeModifiedPostcardInEnvelope(Envelope envelope) {
    std::cout << "Enter MakeModifiedPostCard" << std::endl;
    envelope.postCard.SetText(envelope.postCard.GetText() + " - modified");
    std::cout << "Exit MakeModifiedPostCard" << std::endl;
    return envelope;
}

int main() {
    Envelope env{.postCard = "Hello" };
    auto modifiedEnv = MakeModifiedPostcardInEnvelope(env);
    std::cout << modifiedEnv.postCard.GetText() << std::endl;
}
```

### Пользовательский конструктор копирования
- Автоматически сгенерированный конструктор копирования не всегда подходит
  - Когда создание копии объекта – не только копирование всех его полей
- Пример: класс, реализующий динамический массив
  - Копирование массива требует выделения динамической памяти и копирования элементов исходного массива
- Выход – создавать собственный копирующий конструктор

```c++
class String {
public:
    String() noexcept;
    String(const char* text);

    String(const String& other)
        : m_size{other.m_size}
        , m_capacity{other.m_size}
        , m_chars{ Allocate(m_capacity + 1) }
    {
        std::uninitialized_copy_n(other.m_chars, m_size + 1, m_chars);
    }

    ~String();
private:
    static char* Allocate(size_t size);
    static void Deallocate(char* buffer) noexcept;
    inline static char s_emptyString[] = { '\0' };
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

### Запрещение копирования объектов
- Возможны ситуации, когда операция копирования объекта не имеет смысла и должна быть запрещена
  - Класс, инкапсулирующий сетевое соединение
  - Класс, инкапсулирующий работу с файлом
  - Объект должен существовать в единственном экземпляре внутри приложения, например, «клавиатура»
- Для запрещения копирования объекта, конструктор помечается = delete

## Перегрузка оператора присваивания

### Автоматически сгенерированный оператор присваивания
- Если пользователь не определил в классе операцию присваивания, его сгенерирует компилятор
  - Автоматический сгенерированный оператор присвоит значения всех полей класса и вызове операцию присваивания у родителя (при его наличии)
- Иногда компилятор не может сгенерировать оператор присваивания
  - Класс содержит ссылки или константы
  - В родительском классе оператор присваивания объявлен приватным или удалён

### Когда нужен собственный оператор присваивания?
- Как правило, во всех случаях, когда классу нужен собственный конструктор копирования
  - Создание копии не сводится к обычному копированию полей класса
- Оператор присваивания должен возвращать ссылку на левый операнд, чтобы были возможны следующие выражения, допустимые для встроенных типов:
  - `if ((a = b) == c) {…}`
- Оператор присваивания должен корректно обрабатывать некоторые особенные ситуации
  - Например, присваивание самому себе не должно приводить к порче данных
  - Наиболее надежный способ – использовать конструктор копирования для создания копии

```c++
class PostCard {
public:
  …
  PostCard& operator=(const PostCard& other) {
    std::cout << "Post card " << m_text << " is assigned value " << other.m_text << std::endl;
    m_text = other.m_text;
    return *this;
  }
  …
private:
  std::string m_text;
};

struct Envelope {
    PostCard postCard;
};

int main() {
    Envelope env1{ .postCard = "Hello" };
    Envelope env2{ .postCard = "world" };
    env1 = env2;
    std::cout << env1.postCard.GetText() << std::endl;
}
```

```c++
class String {
public:
  …
  String& operator=(const String& other) {
    if (this != &other) {
      if (m_capacity >= other.m_size && m_chars != s_emptyString) {
        std::destroy_n(m_chars, m_size + 1); // Уничтожили старые символы строки
   
        std::uninitialized_copy_n(other.m_chars, m_size + 1, m_chars);
        m_size = other.m_size;
      } else {
        // Используем идиому copy-and-swap
        String copy{ other };
        std::swap(m_size, copy.m_size);
        std::swap(m_capacity, copy.m_capacity);
        std::swap(m_chars, copy.m_chars);
      }
    }
    return *this;
  }
private:
    …
};
```

### Запрет операции присваивания
- В ряде случае операция присваивания объектов может быть нежелательной
  - С экземпляром объекта связываются какие-то внешние объекты, например, файловый дескриптор или сетевое соединение
- Операцию присваивания для объектов можно запретить

```c++
class NetworkConnection
{
public:
	// …
	NetworkConnection& operator=(const NetwordConnection&) = delete;
};
```

## Перемещающий конструктор

### Проблемы с копированием объектов
- Проблемы с производительностью
  - Избыточное создание временных объектов
    - Оптимизатор не всегда справляется
  - Создание копий «тяжелых» объектов может сильно ударить по производительности
- Не для всех типов объектов имеет смысл семантика копирования
  - fstream, thread, mutex
  - В то же время может быть необходима семантика перемещения содержимого от одного объекта к другому

```c++
class Student {
public:
    explicit Student(const std::string& name)
        : m_name(name)
    {
    }

    const std::string& GetName() const
    {
        return m_name;
    }

private:
    std::string m_name;
};

int main()
{
    // Создаст временную строку из строкового литерала string,
    // а потом в конструкторе копирования скопирует её в m_name
    Student student("Ivan");
}
```

### Избыточное копирование объектов
- В приведенном примере конструктор std::string будет вызван дважды
  - Для создания временного объекта std::string из строкового литерала
  - Для копирования параметра name в поле m_name
- C++11 это позволяет за счет нового типа ссылок на rvalue
  - Все контейнеры STL в стандарте C++11 поддерживают семантику перемещения своих элементов при копировании и присваивании

### Что такое Rvalue и Lvalue?
- Название термина происходит от синтаксиса операции присваивания во многих языках программирования:
  - <выражение1> = <выражение2>
  - <Выражение1> после вычисления должно привести к местоположению объекта данных, в который будет производиться запись (левостороннее значение или lvalue)
  - <Выражение2> после вычисления должно обозначать величину, которая будет присвоена объекту данных (правостороннее значение или rvalue)
- Примеры
  - `ptr = NULL;`
  - `arr[i*2] = b;`
  - `*(pInt + 3) = 42;`

### Два типа ссылок в C++
- Обычные (l-value) ссылки:
  - `Type & ref = someVar;`
  - `const Type & constRef = someVar;`
- В C++11 введен новый тип ссылок: rvalue reference:
  - `Type && ref = someRvalueExpr;`
- Использование rvalue ссылок позволяет реализовать семантику перемещения в конструкторе и операторе присваивания
  - Рассмотрим на следующем примере

```c++
class MovingStudent {
public:
    explicit MovingStudent(const std::string& name)
        : m_name(name) {
        std::cout << "MovingStudent(const std::string& name)\n";
    }

    explicit MovingStudent(std::string&& name)
        : m_name(std::move(name)) {
        std::cout << "MovingStudent(std::string&& name)\n";
    }

    const std::string& GetName() const { return m_name; }
private:
    std::string m_name;
};

int main() {
    std::string name("Ivan");
    MovingStudent student2(name); // Будет вызвано копирование name
    MovingStudent student3("Ivan"); // Будет вызвано перемещение временного объекта
    MovingStudent student4(std::move(name)); // Будет вызвано перемещение из name
}
```

```c++
struct Name {
    Name(const char*) {
        std::cout << "Name(const char*)\n";
    }
    Name(const Name&) {
        std::cout << "Name(const Name&)\n";
    }
    Name(Name&&) {
        std::cout << "Name(Name&&)\n";
    }
};

class ByValueStudent
{
public:
    explicit ByValueStudent(Name name)
        : m_name(std::move(name))
    {
    }

private:
    Name m_name;
};

int main() {
    Name n("Ivan");
    std::cout << "---\n";
    ByValueStudent student5(n); // Copy + Move
    std::cout << "---\n";
    ByValueStudent student6("Ivan"); // Create + Move
    std::cout << "---\n";
    ByValueStudent student7(std::move(n)); // Move + Move
}
```

## Перемещающий конструктор и оператор присваивания
- Перемещающий конструктор
  - Служит для создания нового объекта на основе значения временного объекта
    - Содержимое временного объекта перемещается к создаваемому объекту
- Перемещающий оператор присваивания
  - Служит для изменения значения объекта путем присваивания значения временного объекта
    - Содержимое временного объекта перемещается к объекту в левой части присваивания
    - Перегрузка операторов присваивания будет рассмотрена в следующей лекции

### Что значит «переместить содержимое объекта»?
- Для примитивных значений (int, double, и т.п.) эта операция эквивалентна копированию
- С владеющими указателями сложнее:
  - Вместо выделения памяти и ее инициализации, мы забираем указатель себе, обнуляя соответсвующий указатель временного объекта
    - Применяется, как правило, при эксклюзивном владении данными, переданными по указателю
- Перемещение иных типов данных выполняется с учетом конкретных особенностей их использования объектом

### Требования Стандарта к перемещающему конструктору
- Значение создаваемого объекта должно быть равно значению оригинального объекта до вызова перемещающего конструктора
- После перемещения объект должен остаться в некотором валидном состоянии, возможно, неизвестном
  - В общем случае полагаться на состояние объекта после перемещения нельзя
    - string, vector
- Для некоторых классов (например, unique_ptr) поведение перемещающего конструктора определено
  - Правый указатель будет «пустым»

```c++
class String {
public:
    …
    String(String&& other) noexcept
        : m_size{ std::exchange(other.m_size, 0) }
        , m_capacity{ std::exchange(other.m_capacity, 0) }
        , m_chars{ std::exchange(other.m_chars, s_emptyString) }
    {
    }
    …
private:
    …
    inline static char s_emptyString[] = { '\0' };
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

### Когда создавать перемещающий конструктор?
- Когда компилятор не может сгенерировать перемещающий конструктор
  - В классе есть явно заданный копирующий конструктор, копирующий или перемещающий оператор присваивания или деструктор
- Создание копии объекта является дорогостоящей операцией, а операция перемещения может быть реализована гораздо эффективнее
- Операция копирования для объекта неприменима, но необходима возможность его перемещения
  - Возврат из функции по значению
  - Хранение в контейнерах STL

### Когда нет смысла создавать перемещающий конструктор
- Компилятор может создать его автоматически
- Операция перемещения не может быть реализована эффективнее операции копирования <br>
`class HeavyMovableClass
{
int m_someFixedSizeData[100];
};`
- Операция перемещения в данном случае будет копировать все элементы

# Явное преобразование lvalue в rvalue и std::move
- Неявное преобразование ссылок на lvalue в ссылку на rvalue запрещено Стандартом
  - Именованные объекты (переменные) трактуются компилятором как lvalues
- В ряде случаев требуется явное преобразование из lvalue в rvalue
  - Необходимо выполнить операцию (например, перемещение значения) над объектом, не являющегося временным
- Библиотека STL предоставляет функцию std::move (файл <utility>), для преобразования lvalue в rvalue
  - Программист явно указывает свое намерение выполнить операцию над объектом как над временным
    - Например, выполнить операцию перемещения его значения

```c++
class A
{
public:
	A(int data):m_data(data){}
private:
	int m_data;
};

using namespace std;
int main1()
{
	unique_ptr<A> p;
	{
		unique_ptr<A> p1(new A(1));
		unique_ptr<A> p2(new A(2));
		bool useP1;
		…
		// Ошибка: копирующий оператор присваивания отсутствует
		p = useP1 ? p1 : p2;
		// Перемещаем значение, явно преобразовав lvalue в rvalue
		p = useP1 ? move(p1) : move(p2);// А вот так OK

		// Тут p1 и p2 лучше использовать осторожно, т.к. один из них обнулен
	}

	// Выполняем необходимые действия над p
	return 0;
}
```

## Перегрузка перемещающего оператора присваивания

### Перемещающий оператор присваивания
- Данный оператор используется при присваивании значения временного объекта
  - Как и перемещающий конструктор, вместо копирования он просто забирает данные у переданного объекта
- Значение левого аргумента должно быть эквивалентно значению правого аргумента ДО операции присваивания
- Правый аргумент должен остаться в валидном состоянии
  - Для некоторых стандартных типов состояние объекта после перемещения определено: std::unique_ptr перестаёт владеть объектом

```c++
class String {
public:
    …
    String(String&& other) noexcept
        : m_size{ std::exchange(other.m_size, 0) }
        , m_capacity{ std::exchange(other.m_capacity, 0) }
        , m_chars{ std::exchange(other.m_chars, s_emptyString) }
    {
    }
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            std::swap(m_size, other.m_size);
            std::swap(m_capacity, other.m_capacity);
            std::swap(m_chars, other.m_chars);
        }
        return *this;
    }
private:
    …
    inline static char s_emptyString[] = { '\0' };
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

### Делегирующий конструктор
- Это конструктор, который делегирует инициализацию полей другому  (целевому) конструктору этого же класса
- В списке инициализации указано имя этого же класса
  - Поля указывать нельзя
- Сначала выполнится список инициализации и тело целевого конструктора, затем управление вернётся к делегирующему и выполнится его тело
- Делегирующий конструктор помогает устранить дублирование кода

```c++
class String {
public:
    String(const char* text, size_t size)
        : m_size{ size }
        , m_capacity{ m_size }
        , m_chars{ Allocate(m_capacity + 1) }
    {
        auto end = std::uninitialized_copy_n(text, m_size, m_chars);
        *end = '\0';
    }
    // Следующие конструкторы делегируют работу конструктору String(const char*, size_t size)
    String(const char* text)
        : String(text, std::strlen(text)) {
    }
    String(const String& other)
        : String(other.m_chars, other.m_size) {
    }
    …
private:
    …
    size_t m_size = 0;
    size_t m_capacity = 0;
    char* m_chars;
};
```

## Конструкторы и деструкторы в действии
```c++
struct Foo {
  Foo() { std::cout << "Default ctor\n"; }
  Foo(const Foo&) { std::cout << "Copy ctor\n"; }
  Foo(Foo&&) { std::cout << "Move ctor\n"; }
  Foo& operator=(const Foo&) {
    std::cout << "Copy assign\n"; return *this;
  }
  Foo& operator=(Foo&&) {
    std::cout << "Move assign\n"; return *this;
  }
  ~Foo() { std::cout << "Dtor\n"; }
};
```

## Статические методы класса
```c++
class TV {
public:
    bool SelectChannel(int channel) {
        if (!m_isTurnedOn || !IsValidChannel(channel)) {
            return false;
        }
        m_channel = channel;
        return true;
    }

    bool IsValidChannel(int channel) const {
        return channel >= 1 && channel <= 99;
    }
private:
    bool m_isTurnedOn = false;
    int m_channel = 1;
};

int main() {
    TV tv1, tv2;
    // Не имеет значения, у какого телевизора вызван метод IsValidChannel.
    std::cout << tv1.IsValidChannel(42) << ' ' 
              << tv2.IsValidChannel(100) << std::endl;
}
```

- Обозначаются ключевым словом static
- Внутри класса вызываются по имени
- Вне класса вызываются по полному имени: ИмяКласса::ИмяМетода
- С ними не связан никакой экземпляр класса
  - Они не получают указатель this
- При их вызове нет «текущего объекта»
  - Из статического метода нельзя обратиться к полям класса
  - Можно вызывать только статические методы
- Внутри статических методов можно обращаться к полям и вызывать методы объектов , переданных снаружи или созданных внутри метода
- Есть доступ к приватным полям и методам

```c++
class TV {
public:
  bool SelectChannel(int channel) {
    // Внутри метода класса статический метод вызывается по имени
    if (!m_isTurnedOn || !IsValidChannel(channel)) {
      return false;
    }
    m_channel = channel;
  }

  static bool IsValidChannel(int channel) { // const у статических методов не пишется
    return channel >= 1 && channel <= 99;
  }

private:
  bool m_isTurnedOn = false;
  int m_channel = 1;
};

int main() {
    TV tv;
    // Вне класса статический метод вызывается с указанием имени класса
    std::cout << TV::IsValidChannel(42) << ' ' 
              // Можно указать и имя объекта, но так обычно не делают
              << tv1.IsValidChannel(100) << std::endl;
}
```

```c++
class MyClass {
public:
    static void StaticMethod() {
        // Ошибка: нельзя вызвать нестатический метод из статического.
        NonStaticMethod();

        // Когда есть экземпляр класса, можно вызывать его нестатические методы
        // и обращаться к полям.
        MyClass myObject;
        myObject.NonStaticMethod();
        myObject.m_data = 42;

        // Из статических методов можно вызывать другие статические методы, даже приватные.
        AnotherStaticMethod();
    }

    void NonStaticMethod() { }

private:
    static AnotherStaticMethod() { }
    int m_data = 0;
};
```

## Статические данные класса
```c++
enum class Gear { 
    NEUTRAL = 0, FIRST, SECOND, THIRD, FOURTH, FIFTH, REVERSE = -1 
};

class Car {
public:
    // Определяет, допустимо ли ехать со скоростью speed, когда включена передача gear.
    static bool IsSpeedValidForGear(int speed, Gear gear) {
        if (gear == Gear::NEUTRAL && speed >= 0 && speed <= 150) {
            return true;
        } else if (gear == Gear::FIRST && speed >= 0 && speed <= 30) {
            return true;
        } else if (...) {
            ...
        } ...
    }

private:
    bool m_engineIsOn = false;
    int m_speed = 0;
    Gear m_gear = Gear::NEUTRAL;
};
```

```c++
struct GearSpeedRange {
    Gear gear;    // Передача.
    int minSpeed; // Минимальная скорость на этой передаче.
    int maxSpeed; // Максимальная скорость на этой передаче.
};

class Car {
    // ...
    static bool IsSpeedValidForGear(int speed, Gear gear) { … }

private:
    // Таблица скоростей.
    std::vector<GearSpeedRange> m_speedTable;
};
```

### Статические поля класса
- Статическое поле – общее для всех экземпляров
- Создаётся при запуске программы и уничтожается при её завершении
- Для доступа к статическому полю не нужно указывать объект
  - Можно использовать из статических методов
- Перед объявлением статического поля пишется ключевое слово static

```c++
// car.h

class Car {
public:
    …
    static bool IsSpeedValidForGear(int speed, Gear gear);
private:
    bool m_engineIsOn = false;
    int m_speed = 0;
    Gear m_gear = Gear::NEUTRAL;

    // Объявляем таблицу диапазонов скоростей статической и константной,
    // чтобы она была одна всю программу и не изменялась.
    static const std::vector<GearSpeedRange> s_speedTable;
};
```

```c++
// car.cpp
#include "car.h"

// Так объявляется статическая переменная за пределами класса.
const std::vector<GearSpeedRange> Car::s_speedTable = {
    { Gear::NEUTRAL, 0, 150 },
    { Gear::FIRST, 0, 30 },
    { Gear::SECOND, 20, 50 },
    { Gear::THIRD, 30, 70 },
    { Gear::FOURTH, 40, 100 },
    { Gear::FIFTH, 60, 150 },
    { Gear::REVERSE, 0, 30 },
};

bool Car::IsSpeedValidForGear(int speed, Gear gear) {
    for (auto& range : s_speedTable) {
        if (range.gear == gear) {
            return range.minSpeed <= speed && speed <= range.maxSpeed;
        }
    }
    return false;
}
```

### Определение статического поля внутри класса (начиная с++17)
```c++
class Car {
    
private:
    // Так статическое поле объявляется и определяется внутри класса.
    inline static const std::vector<GearSpeedRange> s_speedTable = {
        { Gear::NEUTRAL, 0, 150 },
        { Gear::FIRST, 0, 30 },
        { Gear::SECOND, 20, 50 },
        { Gear::THIRD, 30, 70 },
        { Gear::FOURTH, 40, 100 },
        { Gear::FIFTH, 60, 150 },
        { Gear::REVERSE, 0, 30 },
    };
};
```

### Статические поля в классах Стандартной Библиотеки
```c++
std::string text = "A quick brown fox jumps over the lazy dog";
std::string needle; // Иголка, которую мы будем искать в стоге сена.
std::cin >> needle; // Вводим текст для поиска.

// Метод find возвращает позицию в строке, с которой начинается искомый текст.
// Если текст не найден, возвращается значение std::string::npos.
if (const size_t foundAt = text.find(needle); foundAt != std::string::npos) {
    std::cout << needle << " is found at position " << found_at << std::endl;
} else {
    std::cout << needle << " was not found" << std::endl;
}
```

### Статические данные и методы – итоги
- Статические методы не привязаны к конкретному экземпляру класса
- Статические поля используются для хранения данных, общих для всех экземпляров класса
- Статические данные часто делают константными





















