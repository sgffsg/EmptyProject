# Основы ООП

## Парадигмы программирования
- Парадигма программирования – способ программирования, не зависящий от конкретного языка
- Стиль программирования как описания намерений программиста
- Модель или подход к решению проблемы
- Современные языки программирования допускают использование разных парадигм

## Структурное программирование
- Последовательное выполнение инструкций
- Явный запрет операции goto
- Ветвление для принятия решений
- Циклы для организации повторяющихся действий

## Процедурное программирование
- Развивает структурный подход
- Последовательно выполняемые операции собираются в подпрограммы: процедуры и функции
- Достоинства
  - Повторное использование кода
  - Улучшение читаемости когда

# Объектно-ориентированное программирование
Парадигма программирования, основанная на представлении предметной области в виде взаимосвязанных абстрактных объектов и их реализаций

## Основные понятия ООП
- Абстракция данных
- Инкапсуляция
- Наследование
- Полиморфизм
- Класс
- Объекты

### Абстракция данных
- Использование только тех характеристики объекта, которые с достаточной точностью описывает его в нашей системе
- Абстракция связывает тип данных с набором операций над ним
  - Пользователь работает с данными не напрямую, а через предоставленный набор операций
- Примеры
  - Класс std:string описывает тип данных «строка» и набор операций над ним
  - Класс Rational описывает тип данных «дробь» и набор операций над дробями
  - Класс Complex описывает «комплексное число» и операции над ним

### Инкапсуляция
- Способность объекта скрывать своё внутреннее устройство
  - Класс рассматривается как черный ящик
- Класс состоит из двух частей: интерфейса и реализации
  - Пользователи класса взаимодействуют только с его интерфейсом
  - Реализация отвечает за сохранение инвариантов класса (непротиворечивое внутреннее состояние объекта)
- Уменьшает число связей между классами и упрощает их независимую реализацию, модификацию и тестирование

```c++
class Car {
public:
  void TurnEngineOn() { m_isTurnedOn = true; }
  bool IsEngineTurnedOn() const { return m_isTurnedOn; }
  void Stop() { m_speed = 0; }
  double GetSpeed() const { return m_speed; }


  bool TurnEngineOff() {
    if (m_speed == 0) {
      m_isTurnedOn = false;
      return true;
    }
    return false;
  }

  bool Drive(double speed) {
    if (m_isTurnedOn && speed >= 0 && speed <= 150) {
      m_speed = speed;
      return true;
    }
    return false;
  }
private:
  bool m_isTurnedOn = false;
  double m_speed = 0;
};
```

### Наследование
- Концепция, при которой новый абстрактный тип данных наследует данные и функциональность существующего типа
- Способствует повторному использованию кода
- Расширение функционала за счёт добавления новых данных и/или операций
- Позволяет строить иерархии классов

```c++
struct Point {
  double x = 0, y = 0;
};

class GameObject {
public:
  Point GetPosition() const { return m_position; }
  void SetPosition(Point pos) { m_position = pos; }
private:
  Point m_position;
};

struct Vector {
  double dx = 0, dy = 0;
};

class Rocket : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) {
    auto pos = GetPosition();
    pos.x += m_speed.dx * timeDelta;
    pos.y += m_speed.dy * timeDelta;
    SetPosition(pos);
  }
private:
  Vector m_speed;
};

int main() {
  Rocket r;
  r.SetSpeed({.dx = 10, .dy = 20});
  r.Update(1);
  auto pos = r.GetPosition();
  std::cout << pos.x << ", " << pos.y << "\n";
}
```

### Полиморфизм
- Полиморфизмом – возможность работать с разными реализациями через один интерфейс
  - Полиморфизм позволяет обрабатывать объекты классов-потомков как однотипные объекты, даже если реализация их методов различается

```c++
struct Point { … };

class GameObject
{
public:
  Point GetPosition() const { return m_position; }
  void SetPosition(Point pos) { m_position = pos; }

  virtual void Update(double timeDelta) {}

private:
  Point m_position;
};

struct Vector { … };

Point MovePoint(Point p, Vector speed, double timeDelta)
{
  p.x += speed.dx * timeDelta;
  p.y += speed.dy * timeDelta;
  return p;
}
```

```c++
class Rocket : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) override {
    SetPosition(MovePoint(GetPosition(), m_speed, timeDelta));
  }

private:
  Vector m_speed;
};

constexpr double GravityConstant = 9.8;

class Ball : public GameObject {
public:
  void SetSpeed(Vector speed) { m_speed = speed; }
  void Update(double timeDelta) override {
    m_speed.dy -= timeDelta * GravityConstant;
    SetPosition(MovePoint(GetPosition(), m_speed,
                          timeDelta));
  }

private:
  Vector m_speed;
};

void UpdateGameObject(GameObject& gameObj) {
  gameObj.Update(10);
}

int main()
{
  Rocket r;
  Ball b;
  b.SetSpeed({ .dx = 10, .dy = 20 });
  r.SetSpeed({ .dx = 10, .dy = 20 });
  UpdateGameObject(r);
  UpdateGameObject(b);
}
```

```c++
#include <cassert>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>

struct Point
{
  int x = 0;
  int y = 0;
};

Point ReadPoint(std::istream& input)
{
  Point p;
  input >> p.x >> p.y;
  return p;
}

void WritePoint(std::ostream& output, Point p)
{
  output << p.x << " " << p.y;
}

int main()
{
  std::istringstream in("3 5 8 10");
  Point p1 = ReadPoint(in);
  assert(p1.x == 3 && p1.y == 5);
  Point p2 = ReadPoint(in);
  assert(p2.x == 8 && p2.y == 10);
  {
    std::ofstream out("points.txt");
    WritePoint(out, p1);
    out << " ";
    WritePoint(out, p2);
  }

  std::ifstream inputFile("points.txt");
  Point p3 = ReadPoint(inputFile);
  Point p4 = ReadPoint(inputFile);
  assert(p3.x == p1.x && p3.y == p1.y);
  assert(p4.x == p2.x && p4.y == p2.y);

  Point p5 = ReadPoint(std::cin);
  WritePoint(std::cout, p5);
}
```

```c++
class Shape {
public:
  virtual ~Shape() = default;
  Color GetColor() const { return m_color; }
  void SetColor(Color c) { m_color = c; }
  virtual double GetArea() const = 0;
private:
  Color m_color = Color::Red;
};
 
class Circle : public Shape {
public:
  double GetArea() const override { return M_PI * m_radius * m_radius; }
  double GetRadius() const { return m_radius; }
  void SetRadius(double r) { m_radius = r; }
private:
  double m_radius = 1.0;
};

void PrintShapeInfo(const Shape& s) {
  std::cout << "Color:" << s.GetColor() << "\n";
  std::cout << "Area:" << s.GetArea () << "\n";
}
```

# Анатомия класса

## Классы и объекты
- В ООП вводится понятие Класса – пользовательского типа данных, объединяющего данные и методы их обработки
  - Класс – тип, описывающий устройство объекта
- Объектом называется экземпляр класса
  - Собака – это класс
  - Собака Жучка из 3 подъезда – это объект, представитель или экземпляр класса «Собака»
  - Чертеж дома – класс, построенный по нему дом - объект

### Объявление класса в С++
```c++
class Car
{
  // Поля класса (данные и методы)
};

// Использование класса
int main()
{
  Car car1;
  Car car2;
}
```

## Данные объекта (переменные объекта, члены-данные)
- Члены-данные (data members) хранят всю необходимую информацию об объекте, формируют его состояние, характеристики и т.п.
- Изменение состояния объекта или его характеристик связано с изменением данных, в нем содержащихся

Пример - Автомобиль
```c++
enum class MakeOfCar {
  Toyota, Mitsubishi, Ford, Volkswagen,
};
 
enum class Color {
  Red, Green, Blue, Black,
};
 
class Car
{
  MakeOfCar m_make = MakeOfCar::Toyota;
  int m_yearOfManufacture = 2019;
  Color m_color = Color::Black;
  double m_fuel = 0;
};
```

Пример - Время
```c++
class Time
{
  int m_hours = 0;
  int m_minutes = 0;
  int m_seconds = 0;
};

class Time
{
  int m_secondsSinceMidnight = 0;
};
```

## Сокрытие данных по умолчанию
- В отличие от структур, по умолчанию доступ к содержимому класса закрыт
  - Снаружи класса нельзя обратиться к его данным

```c++
void Test()
{
  Time t;
  t.m_secondsSinceMidnight = 42;
  // error: cannot access private member declared in class 'Time'
}
```

## Ограничение доступа к содержимому классов и структур
- Каждое поле класса или структуры имеет определённый уровень доступа
- public – публичный уровень доступа. Можно обращаться отовсюду
  - В структурах это уровень доступа по умолчанию
- private – приватный (закрытый) уровень доступа. Нельзя обращаться из кода за пределами класса
  - В классах это уровень доступа по умолчанию
- protected – защищённый уровень доступа. Обращаться может сам класс и его наследники

```c++
// Структура глазами компилятора
struct Time
{
  // Этот спецификатор public неявно подразумевается внутри struct.
public:
  // Всё, что ниже public:, доступно для внешнего кода.
  int hours = 0;
  int minutes = 0;
  int seconds = 0;
};
```

```c++
// Класс глазами компилятора
class Time
{
  // Этот спецификатор private неявно подразумевается внутри class.
private:
  // Всё, что ниже private:, скрыто от внешнего мира.
  int m_hours = 0;
  int m_minutes = 0;
  int m_seconds = 0;
};
```

## Методы
- Вместо прямого доступа к своим данным класс предоставляет методы
- Метод – функция, объявленная внутри класса или структуры
  - Методы также называют функциями-членами класса (class member functions)
- Методы класса задают операции, которые можно выполнить над объектом
- В классах методы делают публичными, а данные – приватными

### Объявление метода класса
```c++
class SomeClass {
public:
  // Это метод класса. Выглядит как функция, описанная внутри класса.
  void SetData(int data) {
    // К приватным данным можно обращаться только внутри методов класса.
    m_data = data;
  }

private:
  // Данные надёжно спрятаны от внешнего мира.
  // Никто, кроме самого класса, не имеет к ним доступа.
  int m_data = 42;
};
```

```c++
class Time
{
public:
  int GetHours() { return m_secondsSinceMidnight / 3600; }
  int GetMinutes() { return (m_secondsSinceMidnight / 60) % 60; }
  int GetSeconds() { return m_secondsSinceMidnight % 60; }

  bool SetTime(int hours, int minutes, int seconds)
  {
    if (hours < 0 || hours >= 24 || minutes < 0 || minutes >= 60 
       || seconds < 0 || seconds >= 60) {
      return false;
    }

    m_secondsSinceMidnight = hours * 60 * 60 + minutes * 60 + seconds;
    return true;
  }

private:
  int m_secondsSinceMidnight = 0;
};
```

```c++
class Circle
{
public:
  void SetRadius(double r)
  {
    m_radius = r;
  }
  double GetRadius() { return m_radius; }
  double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
  double m_radius = 0;
};

int main()
{
  Circle c;
  c.SetRadius(20);
  std::cout << c.GetArea() << std::endl;
}
```

## Методы и состояние класса
- Состояние объекта формируется его членами данными
- Чтобы изменить состояние объекта, нужно изменить его данные
- Когда данные приватные, сделать это можно только в методе класса

### Как быть с константными объектами?
- Когда объект константный, его состояние должно быть нельзя изменить
- Если метод может изменить состояние объекта, значит его нельзя вызвать у константного объекта
- Как быть?

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() { return m_radius; }
    double GetArea() { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

## Константные методы
- Метод, внутри которого не разрешается менять состояние объекта, помечают константным с помощью спецификатора const
- Внутри const-метода нельзя менять состояние объекта
  - Присваивать значения полям класса
  - Вызывать неконстантные методы текущего объекта
  - Вызвать у поля текущего объекта неконстантный метод
  - Передать поле класса в функцию, принимающую аргумент по неконстантной ссылке
- К константных объектов разрешается вызывать только константные методы
  - То же самое касается объектов, доступных по константной ссылке

```c++
class Circle {
public:
    void SetRadius(double r) {
        m_radius = r;
    }
    double GetRadius() const { return m_radius; }
    double GetArea() const { return std::numbers::pi * m_radius * m_radius; }

private:
    double m_radius = 0;
};

void PrintCircle(const Circle& c) {
    std::cout << "radius=" << c.GetRadius() << ", area=" << c.GetArea() << std::endl;
}

int main()
{
    Circle c;
    c.SetRadius(10);
    PrintCircle(c);
}
```

## Физическая и логическая константность

- Физическая константность
  - Объект объявлен как const
  - Его состояние не изменяется
- Логическая константность
  - Объект неизменен внешне
  - Внутреннее состояние может меняться
    - Объект может кешировать данные


## Изменчивые (mutable) данные класса
- Спецификатор mutable разрешает изменять поле, даже если содержащий объект объявлен константным
  - Mutable-поля можно изменять внутри константных методов
- Означает, что поле не влияет на наблюдаемое извне состояние класса
  - Мьютексы
  - Кеширование вычисленных значений
  - Ленивые вычисления

```c++
size_t GetHash(const std::string& s) {
  std::hash<std::string> hasher;
  return hasher(s);
}

class PasswordCracker {
public:
  std::string CrackPassword(size_t hash, size_t maxChars) const {
    std::string prefix;
    return CrackPassword(prefix, hash, maxChars);
  }
private:
  std::string CrackPassword(std::string& prefix, size_t hash, size_t maxChars) const {
    if (GetHash(prefix) == hash) {
      return prefix; // Пароль найден
    }
    if (maxChars == 0)
      return {}; // Пароль не найден, перебор закончен

    for (char ch = 'A'; ch <= 'Z'; ++ch) {
      prefix += ch;
      if (auto pass = CrackPassword(prefix, hash, maxChars - 1); !pass.empty())
        return pass;
      prefix.pop_back();
    }
    return {};
  }
};
```

### Брутфорсим пароли
```c++
using Clock = std::chrono::high_resolution_clock;
using Seconds = std::chrono::duration<double>;

int main() {
  PasswordCracker cracker;

  const auto start = Clock::now();
  auto password = cracker.CrackPassword(GetHash("HELLO"), 5);
  const auto end = Clock::now();

  if (!password.empty()) {
    std::cout << "Cracked password: " << password << "\n";
    std::cout << "Time elapsed: " << Seconds(end - start).count() << "s\n";
  } else {
    std::cout << "Failed to crack password\n";
  }
}
```

```c++
class PasswordCracker {
public:
  std::string CrackPassword(size_t hash, size_t maxChars) const {
    if (auto it = m_passwordCache.find(hash); it != m_passwordCache.end())
      return it->second;
    std::string prefix;
    return CrackPassword(prefix, hash, maxChars);
  }
private:
  std::string CrackPassword(std::string& prefix, size_t hash, size_t maxChars) const {
    if (GetHash(prefix) == hash) {
      m_passwordCache.emplace(hash, prefix);
      return prefix; // Пароль найден
    }
    if (maxChars == 0)
      return {}; // Пароль не найден, перебор закончен

    for (char ch = 'A'; ch <= 'Z'; ++ch) {
      prefix += ch;
      if (auto pass = CrackPassword(prefix, hash, maxChars - 1); !pass.empty())
        return pass;
      prefix.pop_back();
    }
    return {};
  }
  mutable std::unordered_map<size_t, std::string> m_passwordCache;
};
```

## Мьютекс
- Мьютекс – примитив синхронизации, разрешающий доступ к объекту только одному из потоков
  - std::mutex
- Когда в классе содержится мьютекс, его практически всегда помечают mutable

## Используйте mutable-поля аккуратно
- Используйте mutable, чтобы обеспечить логическую константность
- Наблюдаемое состояние должно оставаться неизменным, когда объект меняет внутреннее состояние
- Не нарушайте правила доступа к константным объектам

```c++
class Mutable
{
public:
  int GetValue() const
  {
    if (m_value == -1)
    {
      m_value = 42;
    }
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Mutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Mutable::Change"
              << std::endl;
  }
private:
  mutable int m_value = -1;
  int m_counter = 0;
};
```

```c++
class Immutable
{
public:
  int GetValue() const
  {
    return m_value;
  }
  int GetCounter() const { return m_counter; }
  void Change()
  {
    std::cout << "Enter Immutable::Change"
              << std::endl;
    ++m_counter;
    std::cout << "Exit Immutable::Change"
              << std::endl;
  }
private:
    int m_value = 42;
    int m_counter = 0;
};
```

```c++
const Mutable mut;
const Immutable immut;

int main()
{
    std::cout << "Immutable: " << &immut << " - " << immut.GetValue() << std::endl;
    std::cout << "  Mutable: " << &mut << " - " << mut.GetValue() << std::endl;

    const_cast<Mutable&>(mut).Change();
    std::cout << mut.GetCounter() << std::endl;

    const_cast<Immutable&>(immut).Change();
    std::cout << immut.GetCounter() << std::endl;
}
```

## Размещение классов в файлах
- Общепринятой практикой является размещение объявления классов в заголовочных файлах .h, а их реализации – в файлах .cpp
  - Облегчается использование класса
  - Легко найти класс
- Каждый класс может быть подключен для дальнейшего использования при помощи директивы #include "имя заголовочного файла"
  - При внесении изменений в реализацию метода класса перекомпиляции подвергнутся только измененные файлы

## Спецификаторы уровня доступа
- Public-методы и данные класса определяют его интерфейс
  - доступ к ним возможен из любой части кода
  - Public-область определяет то, как класс может использоваться пользователями класса
- Размещайте в публичной области класса только необходимый набор операций высокого уровня
- Вызов public-метода должен переводить объект из одного валидного состояния в другое валидное состояние, либо не менять состояние объекта
- Публичные данные – чаще всего, плохая практика
  - Класс сам должен управлять своими данными

## Закрытые (приватные) поля и методы класса
- Private-данные и методы класса определяют его реализацию 
  - Доступ разрешен только из методов этого класса
- Рекомендуется все данные класса делать закрытыми, их обработку осуществлять внутри методов
- Закрытые методы класса обычно используются публичными и защищенными методами, решая внутренние задачи класса
  - Если приватный метод не используется, удалите его

```c++
class Time {
public:
    … 
    bool Set(int hours, int minutes, int seconds) {
        if (hours < 0 || hours >= 24 || minutes < 0
            || minutes >= 60 || seconds < 0 || seconds >= 60) {
            return false;
        }

        // Вызываем приватный метод.
        SetUnchecked(hours, minutes, seconds);
        return true;
    }

    void SetMidnight() {
        SetUnchecked(0, 0, 0);
    }

private:
    // Приватный метод. Устанавливает время, не проверяя аргументы.
    void SetUnchecked(int hours, int minutes, int seconds) {
        m_seconds = (hours * 60 + minutes) * 60 + seconds;
        return ;
    }

    int m_seconds = 0;
};
```

## Защищенные поля класса
- Protected-данные и методы определяют интерфейс для производных классов
  - Доступ к ним разрешен изнутри методов данного класса и всех его потомков
- В защищенной зоне размещают методы, которые не должны быть видны снаружи класса, но реализация которых может быть переопределена или использована производными классами

## Свойства
- Свойство – составляющая часть объекта, доступ к которой осуществляется программистом как к полю
  - При записи свойства можно выполнить валидацию или преобразование входных данных
  - При чтении свойства можно вычислить результат
- Свойства могут быть доступны на чтение, запись или на чтение и запись
- Отладчик может IDE может отображать значения свойств наравне со значениями полей
  - Getter-ы свойств не должны иметь видимых побочных эффектов
- В C++ и некоторых других языках программирования свойства, как элемент языка, отсутствуют
  - В этом случае эмулируют свойства за счёт get- и  set- методов

### Пример – свойства в языке C#
```c++
public class TimePeriod
{
    private double _seconds;

    public double Hours
    {
        get { return _seconds / 3600; }
        set
        {
            if (value < 0 || value >= 24)
                throw new ArgumentOutOfRangeException(nameof(value),
                      "The valid range is between 0 and 24.");

            _seconds = value * 3600;
        }
    }
}
```

```c++
internal class Circle
{
    private double _radius = 0;
    public double Radius
    {
        get { return _radius; }
        set
        {
            if (value < 0) throw new ArgumentException("Radius must not be negative");
            _radius = value;
        }
    }

    public double Area
    {
        get { return Radius * Radius * Math.PI; }
    }

    public Circle(double radius)
    {
         if (radius < 0) throw new ArgumentException("Radius must not be negative");
        _radius = radius;
    }
}

Circle c = new(10);
c.Radius = 3;

Console.WriteLine("Area:" + c.Area.ToString());
```

```c++
internal class Counter
{
    private int _value = 0;

    // Поле _value будет увеличиваться всякий раз, когда происходит чтение свойства Value.
    // Даже, если просматривать его под отладчиком.
    // Это может вызвать удивление.
    public int Value {  get { return _value++; } }

    // Это свойство будет долго вычисляться при просмотре под отладчиком.
    public int LongCalculation
    {
        get
        {
            int sum = 0;
            for (int i = 0; i < 1000000000; ++i)
            {
                ++sum;
            }
            return sum;
        }
    }
}
```

```c++
class Point
{
public:
  double x, y;
};
 
class Triangle
{
public:
  double GetArea() const;
  double GetPerimeter() const;
  Point GetCenter() const;
 
  void Move(double dx, double dy);
  void Scale(double sx, double sy);
  void Rotate(Point center, double angle);
 
private:
  Point m_p0, m_p1, m_p2;
};
```

## Какие данные должен иметь Rectangle?
```c++
struct Point
{
  double x;
  double y;
};
 
class Rectangle
{
public:
  Point GetLeftTop() const;
  Point GetRightBottom() const;
  double GetWidth() const;
  double GetHeight() const;
  /* прочие методы */
private:
  /* данные */
};
```

## Указатель this

### Отличие методов от функций
- Методы объявляются внутри класса. Могут быть определены как внутри, так и снаружи
- Методы могут без ограничений обращаться к приватным и защищённым методам этого же класса
- Могут быть виртуальными и чисто виртуальными
- При вызове метода нужно указывать ассоциированный объект

```c++
struct Point {
    double x = 0, y = 0;
};

struct Vector {
    double x = 0, y = 0;
};

// Функция принимает ссылку на точку, которую нужно переместить.
void MovePoint(Point& p, Vector offset) {
    p.x += offset.x;
    p.y += offset.y;
}

int main() {
    Point p1, p2;

    // Сдвигаем точку p1 на вектор с координатами (1, 2.5).
    MovePoint(p1, {1, 2.5});

    // Сдвигаем точку p1 на вектор с координатами (-1, -1).
    MovePoint(p2, {-1, -1});
}
```

```c++
struct Vector {
    double x = 0, y = 0;
};

struct Point {
    double x = 0, y = 0;

    void MoveBy(Vector v) {
        // Внутри метода обращаемся к своим полям, указывая их имена.
        x += v.x;
        y += v.y;
    }
};

int main() {
    Point p1, p2;

    // Для вызова метода указываем объект.
    p1.MoveBy({1, 2.5});
    p2.MovePoint({-1, -1});
}
```

### Ссылка на себя
- Внутри методов класса для обращения к данным и методам можно использовать их имена
- В метод класса неявно передается указатель на объект, для которого он вызывается
  - Этот указатель указатель доступен по ключевому слову this

```c++
// Структура глазами компилятора
struct Point {
    double x = 0, y = 0;

    // Первым параметром в метод передаётся неявный параметр this.
    void MoveBy(/* Point* const this, */ Vector v) {
        // При обращении к полям и методам через this вместо точки
        // используется стрелочка ->, состоящая из символов - и >.
        this->x += v.x;
        this->y += v.y;
    }
};
```

```c++
struct Point {
    double x = 0, y = 0;

    void Set(double x, double y) {
        // Область видимости параметров x и y ограничена 
        // методом Point::Set. Поэтому внутри метода Set 
        // имена x и y относятся к параметрам, а не к полям.

        // Когда мы пишем this->x и this->y, то явно сообщаем 
        // компилятору, что обращаемся к полям текущего объекта.
        this->x = x;
        this->y = y;

        // Если напишем x = x, то присвоим параметру x его собственное значение.
    }
};
```

### Когда в C++ использовать this внутри методов классов?
- Используйте this, если должны. Во всех остальных случаях не используйте
  - Не надо превращать C++ в javascript
- Когда нужно писать this?
  - Если нужно вернуть или передать ссылку или указатель на текущий объект
  - Если в шаблонном классе нужно обратиться к методу или полю базового класса, зависящему от шаблонного параметра

```c++
struct Vector
{
  double x = 0, y = 0;

  // Оператор += возвращает ссылку на текущий объект,
  // чтобы можно было использовать цепочку вызовов:
  // Vector v1, v2, v3;
  // v1 += v2 += v3;
  Vector& operator+=(Vector const& other)
  {
    x += other.x;
    y += other.y;
    
    return *this;
  }
};
```

```c++
template <typename T>
class Base {
public:
    void SetValue(T v) {
        m_value = v;
    }

protected:
    T m_value = {};
};

template <typename T>
class Derived : public Base<T> {
public:
    void PrintValue() {
        // Без this-> будет ошибка компиляции
        std::cout << this->m_value << std::endl;
    }
};

int main() {
    Derived<int> derived;
    derived.PrintValue();
}
```

## Инициализация класса

### Начальное состояние объекта
- Состояние экземпляра класса определяется значением его полей
- Поля класса делают приватными, чтобы нельзя было нарушить инварианты класса
- Вызов публичного метода переводит объект из одного валидного состояния в другое валидное
  - Либо не изменяет состояние объекта
- Следствие: после своего создания объект должен быть в валидном состоянии
  - Для этого должен выполниться некоторый код


```c++
class Rational
{
public:
  int GetNumerator() const {
    return m_numerator;
  }

  int GetDenominator() const {
    return m_denominator;
  }

  void SetNumerator(int numerator) {
    m_numerator = numerator;
  }

  void SetDenominator(int denominator) {
    if (denominator != 0) {// Знаменатель не может быть равен нулю
      m_denominator = denominator;
    }
  }
private:
  int m_numerator = 0; // Числитель
  int m_denominator = 1; // Знаменатель
};
```

```c++
int main()
{
  Rational four;
  four.SetNumerator(4);

  // Создаём дробь 2/3 в три шага:
  Rational twoTrird; // 1. Объявляем переменную
  twoTrird.SetNumerator(2); // 2. Задаём числитель
  twoTrird.SetDenominator(3); // 3. Задаём знаменатель
}

const Rational two_third;

two_third.SetNumerator(2);   // <-- Ошибка.
two_third.SetDenominator(3); // <-- Ошибка.
```

## Конструктор
- Специальная функция-член класса для инициализации объекта в момент его создания
- Конструктор вызывается один раз в момент создания экземпляра класса (объявление переменной класса или вызов оператора new)
- В классе может быть несколько конструкторов, чтобы инициализировать по-разному
  - Они должны различаться количеством или типами аргументов
  - Для инициализации объекта может быть вызван только один из них

```c++
class Rational {
public:
  // Это конструктор, который инициализирует дробь нужными
  // значениями числителя и знаменателя.
  Rational(int numerator, int denominator)
  {
    assert(denominator != 0);
    m_numerator = numerator;
    m_denominator = denominator;
  }
  …
private:
  int m_numerator;
  int m_denominator;
};

int main() {
  // Конструктор можно вызвать, создав объект.
  // Параметры можно передать в фигурных скобках.
  Rational half{ 1, 2 };

  // После работы конструктора Rational поля
  // получили переданные в параметрах значения.
  assert(half.GetNumerator() == 1 && half.GetDenominator() == 2);

  // Вызвать конструктор явно нельзя.
  // Единственный способ — создать новый объект.
  half.Rational(10, 15); // <-- Ошибка!
}
```

## Конструктор по умолчанию
- Некоторые объекты могут иметь состояние по умолчанию
  - Пустая строка
  - Пустой вектор
  - Точка в начале координат
- Конструктор, не имеющий параметров, называется конструктором по умолчанию
  - Поля данных в таком конструкторе инициализируются значениями по умолчанию
- Может быть неявно сгенерирован компилятором
  - Если не объявлены другие конструкторы

### Объявление конструктора по умолчанию
```c++
class TV
{
public:
  TV()
  {
    m_isTurnedOn = false;
    m_currentChannel = 1;
  }
private:
  bool m_isTurnedOn;
  int m_currentChannel;
};
```

Можно проще:
```c++
class TV
{
public:
  /*Компилятор сгенерирует конструктор по умолчанию*/
private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
```

### Автоматическое генерирование конструктора по умолчанию
```c++
class TV {
public:
 // Явно объявив конструктор с параметрами,
  // запрещаем компилятору неявно создать конструктор по умолчанию
  TV(bool isTurnedOn, int currentChannel)
  {
    assert(currentChannel > 0 && currentChannel < 100);
    m_isTurnedOn = isTurnedOn;
    m_currentChannel = currentChannel;
  }

  // Явно просим компилятор сгенерировать конструктор по умолчанию
  TV() = default;
 
private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
```

## Список инициализации конструктора

### Момент вызова конструктора
```c++
#include <iostream>

using namespace std;

class Alice {
public:
    Alice() { std::cout << "Alice is created"s << std::endl; }
};

class Bob {
public:
    Bob() { std::cout << "Bob is created"s << std::endl; }
};

int main() {
    std::cout << "Enter main"s << std::endl;
    Alice alice;
    Bob bob;
    Alice alice2;
    std::cout << "Exit main"s << std::endl;
}
```

### Инициализация полей класса
```c++
class Carol {
public:
    Carol() { std::cout << "Carol is created"s << std::endl; }
private:
    // Теперь Алиса и Боб — поля класса Carol.
    Alice m_alice;
    Bob m_bob;
};

int main() {
    std::cout << "Enter main"s << std::endl;
    Carol carol;
    std::cout << "Exit main"s << std::endl;
}
```

### Проблема инициализации полей класса
```c++
class Alice {
public:
    Alice() {
        std::cout << "Alice is created"s << std::endl;
    }
    Alice(int age) {
        std::cout << "Alice("s << age << ") is created"s << std::endl;
    }
};

class Carol {
public:
    Carol(int age) { 
        std::cout << "Carol is created"s << std::endl; 
        m_alice = Alice(age);
    }

private:
    Alice m_alice;
};
```

### Как проинициализировать поле, если его тип не имеет конструктора по умолчанию
```c++
class Alice {
public:
    Alice(int age) {
        std::cout << "Alice("s << age << ") is created"s << std::endl;
    }
};

class Carol {
public:
    Carol(int aliceAge) { 
        std::cout << "Carol is created"s << std::endl; 
        m_alice = Alice(aliceAge);
    }

private:
    Alice m_alice; // Ошибка! Не можем создать объект без
                   // параметров конструктора.
};
```

### Инициализация данных экземпляра класса
- В качестве данных класса могут выступать другие классы
  - Их инициализация осуществляется ДО выполнения тела конструктора
  - Для их инициализации вызываются конструкторы по умолчанию
- Инициализация полей значением по умолчанию не всегда подходит
  - В классе может не быть конструктора по умолчанию
  - Поле класса может быть константой или ссылкой
- На помощь приходят списки инициализации

### Списки инициализации
- Применяются для инициализации полей класса в конструкторе ДО выполнения его тела
- Использование списков инициализации – единственное решение в случае, когда класс содержит внутри себя
  - поля, являющиеся классами без конструкторов по умолчанию
  - константы
  - ссылки

### Список инициализации в действии
```c++
class Carol {
public:
    Carol(int aliceAge)
        : m_alice{aliceAge} // Вызывается конструктор Alice::Alice(int age).
        , m_name("Luis")   // Инициализируем поле строкового типа.
    {
        std::cout << "Carol is created"s << std::endl; 
    }

    std::string GetName() const {
        return m_name;
    }
private:
    Alice m_alice;
    Bob m_bob;
    std::string m_name;
};

int main() {
    Carol carol{17};
    std::cout << "Name: " << carol.GetName() << std::endl;
}
```

```c++
class TV {
public:
    void TurnOn() { /* ... */ }
};

class RemoteControl {
public:
    RemoteControl(TV& tv, std::istream& input, std::ostream& output)
        : m_tv{ tv }, m_input{input}, m_output{output}
    { }

    bool ExecuteCommand() const {
        std::string command;
        std::getline(m_input, command);
        if (command == "TurnOn") {
            m_tv.TurnOn();
            m_output << "TV is turned on" << std::endl;
            return true;
        }
        return false; // Команда не найдена
    }

private:
    TV& m_tv;
    std::istream& m_input;
    std::ostream& m_output;
};

int main()
{
    TV tv;
    RemoteControl remoteControl{ tv, std::cin, std::cout };
    remoteControl.ExecuteCommand();
}
```

## Converting Constructor
- Конструктор, не объявленный с ключевым словом explicit – называется конвертирующим конструктором
- Конвертирующий конструктор неявно преобразует свои аргументов к типу класса, где этот конструктор объявлен

```c++
class Complex {
public:
  Complex(double re = 0.0, double im = 0.0) {
    m_re = re;
    m_im = im;
  }
  double Re() const { return m_re; }
  double Im() const { return m_im; }
 
private:
  double m_re = 0.0;
  double m_im = 0.0;
};
 
Complex Add(Complex a, Complex b) {
  return {a.Re() + b.Re(), a.Im() + b.Im()};
}
 
int main() {
  auto result = Add(3, {1.2, 2.3}); // 4.2+2.3i
  Complex a = 3.2;                  // 3.2+0.i
  Complex b = { 2, 7.3 };           // 2+7.3i
  Complex c;                        // 0+0i
  Complex d = {};                   // 0+0i
}
```

```c++
class TV {
public:
  TV() = default;
 
  TV(bool isTurnedOn)
    : m_isTurnedOn{ isTurnedOn } {
  }

private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
 
void PrintInfo(const TV& tv) { /* ... */ }
 
int main() {
  TV tv{ /* isTurnedOn = */ true };
  PrintInfo(tv);
  TV tv1 = true;   // WTF?
  PrintInfo(true); // WTF?
}
```


```c++
class TV {
public:
  TV() = default;
 
  explicit TV(bool isTurnedOn)
    : m_isTurnedOn{ isTurnedOn } {
  }

private:
  bool m_isTurnedOn = false;
  int m_currentChannel = 1;
};
 
void PrintInfo(const TV& tv) { /* ... */ }
 
void Test() {
  TV tv = true;    // Ошибка компиляции
  PrintInfo(true); // Ошибка компиляции
}
```

### Explicit or Implicit?
- Если конструктор имеет один параметр, то очень часто его нужно пометить ключевым словом explicit
  - Кроме случаев, когда необходимо неявное преобразование
- Если конструктор имеет несколько параметров, не помечайте его ключевым словом explicit
- C.46: By default, declare single-argument constructors explicit

## Деинициализация экземпляра класса


































