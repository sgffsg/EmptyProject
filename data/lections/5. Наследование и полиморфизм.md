# Наследование

## Программист и рабочий
- Рассмотрим две сущности — программиста и рабочего, представленные следующими классами
  - Programmer — умеет программировать на разных языках;
  - Worker — владеет одной или несколькими профессиями.

### Программист
```c++
enum class ProgrammingLanguage {CPP, JAVA, PYTHON, PHP };
 
enum class Gender{ MALE, FEMALE };
 
class Programmer
{
public:
  Programmer(const std::string& name, int age, Gender gender);
  const std::string& GetName() const;
  int GetAge() const;
  Gender GetGender() const;
  void AddProgrammingLanguage(ProgrammingLanguage language);
  bool CanProgram(ProgrammingLanguage language) const;
private:
  std::string m_name;
  int m_age;
  Gender m_gender;
  std::unordered_set<ProgrammingLanguage> m_programmingLanguages;
};
```

### Рабочий
```c++
enum class WorkerSpeciality { BLACKSMITH, CARPENTER, WOOD_CHOPPER, 
  ENGINEER, PLUMBER 
};
 
class Worker
{
public:
  Worker(const std::string& name, int age, Gender gender);
  const std::string& GetName() const;
  int GetAge() const;
  Gender GetGender() const;
  void AddSpeciality(WorkerSpeciality speciality);
  bool HasSpeciality(WorkerSpeciality speciality) const;
private:
  std::string m_name;
  int m_age;
  Gender m_gender;
  std::unordered_set<WorkerSpeciality> m_specialities;
};
```

### Классы Worker и Programmer
- Частично совпадает набор данных и методов
  - Имя, возраст, пол
- Есть специфичные для профессий данные и методы
  - Программист: языки программирования
  - Рабочий: специализации
- Рабочий и программист – являются людьми
  - Всё, что верно для людей, верно и для рабочих, и программистов
- Рабочий и программист сохраняют свойства людей, добавляя к ним свои данные и методы

## Наследование
- Выражает отношение «является» между классами
  - Программист является Человеком
  - Рабочий является Человеком
- Помогает повторному использованию кода
  - Новый класс наследует данные и поведение базового класса
- Делает возможным модификацию и расширение
  - Класс-потомок может добавить свои поля и методы
  - Можно переопределить поведение базового класса

## Основные понятия
- `Класс-родитель` – класс, от которого наследуются другие классы
- `Класс-потомок` – класс, созданный на основе другого класса с помощью наследования
- `Базовый класс` – класс, находящийся на вершине иерархии
  - Он не наследуется от других классов
- `Иерархия наследования` – структура, отношение между классами
  - В простейшем случае – дерево.
    - Узлы – потомки
    - Корень – базовый класс
- Один базовый класс может иметь множество потомков

```c++
struct Point
{
  double x = 0;
  double y = 0;
};
enum class Color { BLACK, RED, GREEN, BLUE };
 
class Shape
{
public:
  Color GetColor() const;
  void SetColor(Color color);
 
private:
  Color m_color = Color::BLACK;
};

class Circle : public Shape
{
public:
  Point GetCenter() const;
  void SetCenter(Point center);
  double GetRadius() const;
  void SetRadius(double radius);
 
private:
  Point m_center;
  double m_radius = 1.0;
};

int main()
{
  Circle c;
  c.SetColor(Color::RED);
  c.SetRadius(2);
}
```

### Передача параметров конструктору родителя
```c++
struct Point
{
  double x = 0;
  double y = 0;
};
 
enum class Color { BLACK, RED, GREEN, BLUE };
 
class Shape
{
public:
  explicit Shape(Color color)
    : color_(color)
  { }

  Color GetColor() const { return color_; } 
private:
  Color color_;
};
```

```c++
class Circle : public Shape
{
public:
  Circle(Color color, Point center, double radius)
    : Shape(color) // Передаём цвет конструктору родительского класса
    , center_(center)
    , radius_(radius)
  {}
 
  Point GetCenter() const{ return center_; }
  void SetCenter(Point center){ center_ = center; }
 
  double GetRadius() const { return radius_; }
  void SetRadius(double radius) { radius_ = radius; }
private:
  Point center_;
  double radius_;
};
 
int main()
{
  // Красная окружность с центром в точке {1, 2} радиусом 5
  Circle c{ Color::RED, { 1, 2 }, 5 };
}
```

## Базовый класс Person
```c++
class Person {
public:
  Person(const std::string& name, int age, Gender gender)
    : m_name(name)
    , m_age(age)
    , m_gender(gender)
  {
  }

  const std::string& GetName() const { return m_name; }
  int GetAge() const { return m_age; }
  Gender GetGender() const { return m_gender; }

protected:
  std::string m_name;
  int m_age;
  Gender m_gender;
};
```

## Классы Programmer и Worker
```c++
class Programmer : public Person {
public:
  // Используем конструктор с той же сигнатурой, что и в Person
  using Person::Person;

  void AddProgrammingLanguage(ProgrammingLanguage lang) { m_programmingLanguages.insert(lang); }
  bool CanProgram(ProgrammingLanguage lang) const { return m_programmingLanguages.contains(lang); }
private:
  std::unordered_set<ProgrammingLanguage> m_programmingLanguages;
};

class Worker : public Person {
public:
  using Person::Person;

  void AddSpeciality(WorkerSpeciality speciality) { m_specialities.insert(speciality); }
  bool HasSpeciality(WorkerSpeciality speciality) const { return m_specialities.contains(speciality); }
private:
  std::unordered_set<WorkerSpeciality> m_specialities;
};
```

## Приведение типа вверх по иерархии классов

### Публичное наследование
- Выражает отношение «Является» («is a»)
  - Дочерний класс является частным случаем родительского
  - Кнопка является элементом управления
  - `ifstream` и `istringstream` являются частными случаями istream
- Это позволяет использовать экземпляры наследников везде, где ожидается ссылка или указатель на родительский класс

## Приведение типа вверх по иерархии классов
```c++
class Person {
public:
  Person(const string& name, int age)
    : name_(name)
    , age_(age)
  {
  }

  int GetAge() const { return age_; }
  const string& GetName() const { return name_; }
  void Dance() const
  {
    cout << name_ << " is dancing"s << endl;
  }
 
private:
  string name_;
  int age_;
};
```

### Приведение типа вверх по иерархии классов – продолжение
```c++
enum class WorkerSpeciality {
  BLACKSMITH, CARPENTER, WOOD_CHOPPER, ENGINEER, PLUMBER
};
 
class Worker : public Person {
public:
  Worker(const string& name, int age, WorkerSpeciality speciality)
    : Person(name, age)
    , m_speciality(speciality)
  {
  }
  void Work()
  {
    cout << GetName() << " is working"s << endl;
  }
private:
  WorkerSpeciality m_speciality;
};
```

### Работа с наследниками через ссылку или указатель на базовый класс
```c++
void VisitNightClub(const Person& person)
{
  if (person.GetAge() >= 18)
    person.Dance();
  else
    cout << person.GetName() << " is too young to visit night clubs"s << endl;
}

int main()
{
  Person boy("Harry Potter"s, 11);
  VisitNightClub(boy);
 
  Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
  VisitNightClub(worker);
}
```

## Приведение ссылок и указателей вверх по иерархии
```c++
int main()
{
  Person boy("Harry Potter"s, 11);
  Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
  vector<const Person*> people{ &boy, &worker };
 
  for (const Person* person : people)
  {
    VisitNightClub(*person);
  }
}
```

# Виртуальные методы, полиморфизм

## Виртуальные методы
```c++
class Person
{
public:
  …
  // Реализация виртуального метода может быть переопределена
  // его наследниками
  virtual void Dance() const
  {
    cout << name_ << " is dancing"s << endl;
  }
 
private:
  string name_;
  int age_;
};
```

### Переопределение виртуального метода
```c++
class Worker : public Person
{
public:
  …
  // Метод Dance переопределяет (override) реализацию родителя
  void Dance() const override
  {
    // Сначала вызываем метод Dance родительского класса
    Person::Dance();
    // Добавляем дополнительное поведение
    cout << "Oppa!"s << endl;
  }
  …
};
```

```c++
int main()
{
  Person person("Ivan Ivanov"s, 30);
  VisitNightClub(person);
 
  Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
  VisitNightClub(worker);
}
```

## Полиморфизм
- Полиморфизм – возможность работы с разными реализациями через один и тот же интерфейс
  - Полиморфизм времени выполнения
  - Полиморфизм времени компиляции
- В C++ переопределяемый метод родительского класса должен быть объявлен виртуальным
  - Компилятор будет знать, что метод может быть переопределён подклассами
  - Объект с виртуальными методами хранит дополнительную информацию, позволяющую узнать о типе объекта во время выполнения

### Замещение метода родительского класса
```c++
class Person
{
public:
  // Метод Dance умышленно объявлен невиртуальным
  void Dance() const
  {
    cout << name_ << " is dancing"s << endl;
  }
};
 
class Worker : public Person
{
public:
  // Метод Dance класса Worker замещает собой невиртуальный метод Dance родителя
  void Dance() const
  {
    Person::Dance();
    cout << "Oppa!"s << endl;
  }
};
```

### Замещение метода родительского класса
```c++
void VisitNightClub(const Person& person)
{
  if (person.GetAge() >= 18)
  {
    // Компилятор вызовет метод Person::Dance, так как он не виртуальный
    person.Dance();
  }
  else
    cout << person.GetName() << " is too young to visit night club"s << endl;
}
 
int main()
{
  Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
  // Вызовется метод Worker::Dance, так он вызывается у переменной типа Worker
  worker.Dance();
 
  VisitNightClub(worker);
}
```

## Спецификатор override
```c++
class Person
{
public:
  // Метод Dance умышленно объявлен невиртуальным
  void Dance() const
  {
    cout << name_ << " is dancing"s << endl;
  }
};
 
class Worker : public Person
{
public:
  void Dance() const override
  {
    Person::Dance();
    cout << "Oppa!"s << endl;
  }
};

error C3668: 'Worker::Dance': method with override specifier 'override' did not override any base class methods
```

- Объявляйте метод родителя виртуальным, чтобы подклассы могли переопределить реализацию этого метода
  - В дочерних классах используйте спецификатор override
- Если не требуется переопределять метод в наследниках, не объявляйте его виртуальным
  - В наследниках не создавайте метод с таким же именем
- Виртуальный метод остаётся виртуальным в классах наследниках

## Защищённые данные и методы класса

### Публичные и приватные данные и методы
- Публичные данные и методы формируют интерфейс класса
- Приватные данные и методы формируют реализацию
  - Данные обычно объявляются приватными, чтобы защитить состояние класса от изменения извне
- Приватная часть скрыта в том числе и от наследников
  - Иногда это бывает неудобно

#### Добавляем уровень удовлетворённости
```c++
class Person
{
public:
  int GetAge() const { return age_; }
  int GetSatisfaction() const { return satisfaction_; }
  // Танец поднимает настроение
  virtual void Dance()
  {
    ++satisfaction_;
  }
 
private:
  int satisfaction_; // Уровень удовлетворения
  int age_;
};
```

- Рабочие в возрасте от 30 до 40 лет должны эмоционально реагировать во время танца
  - Восклицают «Оппа»
  - Уровень удовлетворённости увеличивается на два пункта
- Работа уменьшает уровень удовлетворения рабочего на один пункт
- Пользователи класса Person имеют доступ к значению удовлетворённости только на чтение

## Защищённые члены класса
- Worker нужен доступ к полю satisfaction_ родителя
- Можно объявить класс Worker другом класса Person
  - Это даст доступ ко всем полям
  - Придётся вносить изменения в Person, если другие наследники тоже захотят изменять уровень удовлетворённости
- Решение – использовать спецификатор protected

```c++
class Person {
public:
  virtual void Dance();
protected:
  // Уровень удовлетворения теперь доступен наследникам Person
  int satisfaction_ = 100;
private:
  int age_;
};

class Worker : public Person
{
public:
  void Dance() override {
    Person::Dance();
    if (const int age = GetAge(); age > 30 && age < 40) {
      cout << "Oppa!" << endl;
      ++satisfaction_;
    }
  }
  void Work() {
    --satisfaction_;
  }
};
```

```c++
class Person {
public:
  …
  int GetSatisfaction() const { return satisfaction_; }
protected:
  int SetSatisfaction(int value) { satisfaction_ = value; }
private:
  int satisfaction_;
  int age_;
};
 
class Worker : public Person {
public:
  void Dance() override {
    Person::Dance();
    if (const int age = GetAge(); age > 30 && age < 40) {
      cout << "Oppa!" << endl;
      SetSatisfaction(GetSatisfaction() + 1);
    }
  }
  void Work() {
    SetSatisfaction(GetSatisfaction() - 1);
  }
};
```

## Защищённый конструктор
- Доступен лишь классам наследникам
  - Код вне класса не может создать экземпляр класса напрямую
- Защищённый конструктор в родительском классе запрещает создание экземпляров родителя
  - Вместо этого создаются экземпляры классов-наследников

```c++
class Shape {
protected:
  explicit Shape(Color color)
    : color_(color)
  {}

  …
 
private:
  Color color_;
  ...
};
 
class Circle : public Shape {
public:
  Circle(double radius, Color color)
    : Shape(color)
    , radius_(radius){}
...
private:
  double radius_;
  ...
};

int main() {
  // Ошибка компиляции - конструктор Shape недоступен
  Shape shape(Color::RED);
  // OK - экземпляр Circle имеет публичный конструктор
  Circle circle(10.0, Color::RED);
}
```

## Деструкторы и наследование

### Создание объектов в динамической памяти
```c++
// Функция DoSomething может обработать вектор указателей на любые фигуры
void DoSomething(const vector<Shape*>& shapes);
 
int main()
{
  Circle* circle = new Circle(10, Color::RED);
  Rectangle* rectangle = new Rectangle(10, 20, Color::BLUE);
  vector<Shape*> shapes = { &circle, &rectangle };
 
  DoSomething(shapes);
 
  delete circle;
  delete rectangle;
}
```

### Виртуальный деструктор
```c++
class Shape
{
public:
  virtual ~Shape() = default;
  /* Также можно написать тело деструктора вручную
  virtual ~Shape() { … }
  */
};
 
class Circle : public Shape
{
  ...
};
 
int main()
{
  Shape* shape = new Circle(10, Color::RED);
  delete shape; // OK, так как деструктор Shape виртуальный
}
```

### Виртуальный деструктор в базовом классе
```c++
class Shape
{
public:
  virtual ~Shape() = default;
};
 
class Circle : public Shape { … };
class Rectangle : public Shape { … };
 
int main()
{
  vector<unique_ptr<Shape>> shapes;
  shapes.emplace_back(make_unique<Circle>(10.0, Color::RED));
  shapes.emplace_back(make_unique<Rectangle>(10.0, 20.0, Color::BLUE));
  // Деструктор unique_ptr корректно удалит фигуры
  // через указатель на класс Shape.
}
```

## Публичный невиртуальный деструктор
- Если программист не напишет в классе или структуре деструктор явно, компилятор сгенерирует публичный невиртуальный* деструктор
- Применение:
  - Классы без наследников
  - Базовые и родительские классы, которые одновременно удовлетворяют двум критериям:
    - Не удаляются полиморфно
    - Используются не только как родительские классы, но и сами по себе

- *Если в в одном из классов-родителей деструктор был виртуальным, то деструктор наследника тоже будет виртуальным

```c++
// Структура, хранящая данные, общие для всех типов HTTP-запросов.
// Она не будет использоваться для полиморфного удаления наследников.
// По умолчанию у неё публичный невиртуальный деструктор, чтобы
// не иметь накладных расходов на таблицу виртуальных функций.
struct BaseHttpRequest {
  // У всех запросов есть target и заголовки
  std::string target;
  std::unordered_map<std::string, std::string> headers;
};

struct GetRequest : BaseHttpRequest {
  // У GET-запроса нет тела
};
struct PutRequest : BaseHttpRequest {
  std::string body;
};
struct PostRequest : BaseHttpRequest {
  std::string body;
};
struct DeleteRequest : BaseHttpRequest {
  // DELETE-запрос не имеет тело
};

// Запрос — один из указанных видов запросов (подробнее про std::variant в конце темы)
using Request = std::variant<GetRequest, PostRequest, PutRequest, DeleteRequest>;
```

### Использование Request
```c++
void Print(const Request& request, std::ostream& out);

int main() {
  Print(PostRequest{
        "/log_in",
        {
          { "Host", "example.com" },
          { "Content-Type", "application/json" },
        },
        R"({"login": "john.doe", "password": "12345"})",
      },
    std::cout);
}
```

## Публичный виртуальный деструктор
- Применяется, когда наследники класса будут удаляться полиморфно (по указателю на родительский класс)
  - `Base* base = new Derived(); … delete base;`
  - `unique_ptr<Base> base = make_unique<Derived>();`
- Виртуальный деструктор нужен, чтобы корректно разрушить объект

```c++
class Shape {
public:
  // Публичный виртуальный деструктор позволит безопасно
  // удалять наследников, используя указатель на класс Shape.
  virtual ~Shape() = default;

  void SetColor(uint32_t color) { m_color = color; }
  uint32_t GetColor() const { return m_color; }

protected:
  Shape(uint32_t color): m_color{ color } { }
private:
  uint32_t m_color = 0;
};

class Circle : public Shape {
public:
  Circle(double r, uint32_t color)
        : Shape{ color }, m_radius{ r } {}
  // Так как деструктор родителя виртуальный,
  // он остаётся виртуальным и в Circle
private:
  double m_radius;
};

class Rectangle : public Shape {
public:
  Rectangle(double w, double h,
              uint32_t color)
    : Shape{ color }
        , m_width{ w }, m_height{ h }
  { }

private:
  double m_width;
  double m_height;
};
```

#### Единоличное владение полиморфными объектами в динамической памяти
```c++
int main()
{
  // Создаём в куче окружность
  std::unique_ptr<Circle> c = std::make_unique<Circle>(10, 0xFF00FF);
  std::unique_ptr<Rectangle> r = std::make_unique<Rectangle>(10, 20, 0xFF00FF);

  std::vector<std::unique_ptr<Shape>> shapes;
  shapes.push_back(std::move(c));
  shapes.push_back(std::move(r));

  // При разрушении векторов, все указатели на Shape будут разрушены и удалять объекты в куче
}
```

#### Совместное владение полиморфными объектами в динамической памяти
```c++
void SharedPtrCollection()
{
  std::vector<std::shared_ptr<Shape>> shapes;
  auto c = std::make_shared<Circle>(10, 0xFF00FF);
  auto r = std::make_shared<Rectangle>(10, 20, 0xFF00FF);
  shapes.push_back(c);
  shapes.push_back(r);

  assert(shapes[0] == c);
}
```

```c++
#include <memory>

std::vector<std::unique_ptr<Shape>> CreateShapes() {
  std::vector<std::unique_ptr<Shape>> shapes;

  shapes.push_back(std::make_unique<Circle>(20.0, 0xff0000));
  shapes.push_back(std::make_unique<Rectangle>(20.0, 30.0, 0xff00ff));
  
  return shapes;
}

void TestShapes() {
  std::vector<std::unique_ptr<Shape>> shapes = CreateShapes();

  /* ... */

  // Деструктор класса vector безопасно удалит хранящиеся в нём
  // указатели unique_ptr, а каждый из указателей — свою фигуру.
  // Виртуальный деструктор класса Shape позволит безопасно
  // разрушить наследников Shape по указателю на базовый класс
}
```

## Защищённый невиртуальный деструктор
- Используется в базовом классе, не предназначенном для полиморфного удаления
  - Не создаётся напрямую (создаются только наследники)
  - Не удаляется полиморфно
- Уменьшает количество виртуальных функций

```c++
class Drawable {
public:
  virtual void Draw() const = 0;
protected:
  // Класс Drawable не предназначен для
  // полиморфного удаления своих подклассов,
  // поэтому его деструктор — защищённый
  // невиртуальный
  ~Drawable() = default;
};

class Animal : public Drawable {
public:
  void Eat() {
    std::cout << "Nom-nom" << std::endl;
  }
  virtual void Move() = 0;
  // Наследники класса Animal
  // будут удаляться полиморфно.
  virtual ~Animal() = default;
};
```

```c++
class Fish : public Animal {
public:
  // Реализуем метод
  void Move() override {
    std::cout << "Swim" << std::endl;
  }
  void Draw() const override {
    std::cout << "><(((*>" << std::endl;
  }
};

class Cat : public Animal {
public:
  void Move() override {
    std::cout << "Run" << std::endl;
  }
  void Draw() const override {
    std::cout << "(^w^)" << std::endl;
  }
};

class Robot : public Drawable {
public:
  void Draw() const override {
    std::cout << "~[o_o]~" << std::endl;
  }
};
```

```c++
void DrawPicture(const std::vector<const Drawable*>& picture) {
  for (const auto* drawable : picture) {
    drawable->Draw();
  }
}

void PlayWithDrawables() {
  // Вектор animals владеет животными. При его разрушении будут удалены животные.
  std::vector<std::unique_ptr<Animal>> animals;
  animals.push_back(std::make_unique<Cat>());
  animals.push_back(std::make_unique<Fish>());

  // Вектор picture не владеет своими drawable-объектами, так как хранит обычные указатели. 
  // При разрушении picture не будут удалены drawable-объекты.
  std::vector<const Drawable*> picture;
  for (auto& animal : animals) {
    // Animal* можно преобразовывать в const Drawable*, так как Animal — наследник Drawable.
    picture.push_back(animal.get());
  }

  const Robot robot;
  // Робот унаследован от Drawable, поэтому указатель const Robot* конвертируется в const Drawable*.
  picture.push_back(&robot);
  DrawPicture(picture);

  // Деструктор вектора animals удалит животных, а robot удалится сам.
}
```

## Ключевое слово final
- Класс можно объявить конечным классом иерархии, используя ключевое слово final
  - `class SomeClass final { … };`
  - От такого класса нельзя будет унаследоваться
- Виртуальный метод можно объявить финальным
  - Этот метод нельзя переопределить в подклассе
- Применение:
  - Явно запретить наследовать классы и переопределять методы, не предназначенные для этого
  - Компилятор может оптимизировать вызов виртуального метода, если знает, что метод не переопределяется в подклассе
    - Это называется девиртуализацией

```c++
class IShape {
public:
  virtual double GetArea() const = 0;
  virtual std::string ToString() const = 0;
  virtual ~IShape() = default;
};

class Shape : public IShape {
public:
  // Подклассы не могут переопределить этот финальный метод
  std::string ToString() const final {
    std::ostringstream s;
    s << GetType() << " ";
    AppendProperties(s); // выводим специфичные для фигуры свойства
    s << " area: " << GetArea(); // выводим общие для всех фигур свойства
    return s.str();
  }

private:
  // Наследники не смогут могут вызвать приватные виртуальные методы,
    // но смогут их переопределить
  virtual std::string GetType() const = 0;
  virtual void AppendProperties(std::ostream&) const {}
};
```

```c++
class Circle final : public Shape {
public:
  explicit Circle(double radius): m_radius{ radius } { }
  double GetArea() const override { return std::numbers::pi * m_radius * m_radius; }

private:
  std::string GetType() const override { return "Circle"; }
  void AppendProperties(std::ostream& s) const override { s << "radius: " << m_radius; }

  double m_radius;
};

class Square final : public Shape {
public:
  explicit Square(double size): m_size(size) { }
  double GetArea() const override { return m_size * m_size; }


private:
  std::string GetType() const override { return "Square"; }
  void AppendProperties(std::ostream& s) const override { s << "size: " << m_size; }

  double m_size;
};
```

```c++
void ProcessShapes(const std::vector<std::unique_ptr<Shape>>& shapes) {
  double totalArea = 0;
  for (const auto& sh : shapes) {
    std::cout << sh->ToString() << std::endl;
    totalArea += sh->GetArea();
  }
  std::cout << "Total area:" << totalArea << std::endl;
}

int main() {
  std::vector<std::unique_ptr<IShape>> shapes;

  shapes.push_back(std::make_unique<Circle>(10));
  shapes.push_back(std::make_unique<Square>(5));

  ProcessShapes(shapes);
}
```

# Виды наследования

## Варианты наследования
- По типу доступа к членам базового класса:
  - Публичное наследование — открытые и защищённые члены базового класса сохраняют свой уровень доступа.
  - Защищённое наследование — открытые и защищённые члены становятся защищёнными.
  - Приватное наследование — открытые и защищённые члены становятся приватными.
- По количеству базовых классов:
  - Одиночное наследование — класс наследуется от одного базового класса.
  - Множественное наследование — класс наследуется от нескольких базовых классов.

## Открытое (публичное) наследование
- Используется для выражения отношения «является» (is-a).
  - «Собака является животным»
  - «Прямоугольник является замкнутой фигурой»
- Производный класс сохраняет интерфейс базового класса:
  - публичные члены базового класса остаются публичными
  - защищённые члены остаются защищёнными
- Производный класс можно использовать там, где ожидается базовый:
  - это наследование типа
  - обеспечивает полиморфизм

```c++
class Shape {
public:
  virtual double Area() const {
    return 0.0;
  }
  
  virtual ~Shape() = default;
};
  
class Rectangle : public Shape {
public:
  Rectangle(double w, double h) : m_width(w), m_height(h) {}
  
  double Area() const override {
    return m_width * m_height;
  }

private:
  double m_width;
  double m_height;
};

class Circle : public Shape { … };
```

## Публичное наследование как наследование интерфейса
- Публичное наследование означает, что класс-потомок является базовым классом — он реализует его интерфейс
- Это позволяет использовать объекты производного класса там, где ожидаются объекты базового класса
  - Такой код должен работать корректно без знания о производных классах
- Указатели и ссылки на производный класс могут неявно приводиться к указателям и ссылкам на базовый
- Если класс-потомок не полностью поддерживает поведение базового, публичное наследование — ошибка проектирования

```c++
class Shape {
public:
  virtual double Area() const;
  virtual ~Shape() = default;
};

class Rectangle : public Shape {
public:
  Rectangle(double width, double height);
  double Area() const override;
private:
  double m_width;
  double m_height;
};

class Circle : public Shape {
public:
  Circle(double radius);
  double Area() const override;
private:
  double m_radius;
};

double TotalArea(const std::vector<Shape*>& shapes) {
  double total = 0.0;
  for (auto* s : shapes)
    total += s->Area();
  return total;
}

int main() {
  Circle circle{ 10.0 };
  Rectangle rectangle{ 10.0, 20.0 };
  std::vector<Shape*> shapes{ &circle, &rectangle };
  std::cout << TotalArea(shapes) << "\n";
}
```

```c++
class Array {
public:
  void Add(int value) {
    m_data.push_back(value);
  }

  int Get(size_t index) const {
    return m_data.at(index);
  }

  void Set(size_t index, int value) {
    m_data.at(index) = value;
  }

  size_t Size() const {
    return m_data.size();
  }

protected:
  std::vector<int> m_data;
};

class Stack : public Array {
public:
  void Push(int value) {
    Add(value);
  }

  void Pop() {
    if (!m_data.empty()) m_data.pop_back();
  }

  int Top() const {
    return m_data.back();
  }
};

void CorruptArray(Array& arr) {
  if (arr.Size() > 0)
    arr.Set(0, 42);
}

int main() {
  Stack s;
  s.Push(10);
  CorruptArray(s); // Нарушает логику стека
}
```

### Пример неправильного использования публичного наследования
- Неправильный ход мыслей:
  - «Окружность можно получить, добавив к точке радиус, а цилиндр – добавив к окружности высоту»
- Неправильный контекст использования открытого наследования:
  - Открытое наследование должно использоваться не для того, чтобы производный класс мог использовать код базового для реализации своей функциональности
  - Класс-наследник должен представлять собой частный случай более общей абстракции
- Здесь:
  - Окружность не является частным случаем точки
  - Цилиндр не является частным случаем окружности, и, тем более, точки

## Приватное наследование — наследование реализации
- Приватное наследование используется для повторного использования реализации, а не интерфейса
  - Открытые и защищённые члены базового класса становятся закрытыми в производном
- Производный класс не является подтипом базового и не должен использоваться как таковой
- Производный класс использует базовый как внутреннюю реализацию, а наружу предоставляет собственный интерфейс
- Выражает отношение «реализован на основе» (implemented as)
  - Stack реализован на основе Array
  - Logger реализован на основе OutputStream

Stack на основе Array
```c++
class Array {
public:
  void Add(int value) {
    m_data.push_back(value);
  }

  int GetItem(size_t index) const {
    return m_data.at(index);
  }

  void RemoveLast() {
    m_data.pop_back();
  }

  size_t GetSize() const {
    return m_data.size();
  }
private:
  std::vector<int> m_data;
};

class Stack : private Array {
public:
  void Push(int value) {
    Add(value);
  }

  void Pop() {
    RemoveLast();
  }

  int Top() const {
    return GetItem(GetSize() - 1);
  }

  bool IsEmpty() const {
    return GetSize() == 0;
  }
};
```

### Композиция – предпочтительная альтернатива приватному наследованию
- В композируемом классе могут быть несколько экземпляров существующего класса, что делает его более гибким
- Композиция снижает зависимость классов друг от друга, в отличие от наследования, которое тесно связывает классы
- В некоторых случаях приватное наследование может быть более подходящим, например, если требуется доступ к защищенным методам родительского класса
- С точки зрения интерфейса нового класса – композиция и приватное наследование эквивалентны

```c++
class Engine {
public:
  void Start() { std::cout << "Engine started" << std::endl; }
  void Stop() { std::cout << "Engine stopped" << std::endl; }
};

class Car {
public:
  void Drive() {
    m_engine.Start();
    std::cout << "Car is driving" << std::endl;
  }

  void Stop() {
    m_engine.Stop();
    std::cout << "Car has stopped" << std::endl;
  }
private:
  Engine m_engine; // Композиция
};
```

## Защищенное наследование
- Защищенное наследование – наследование реализации, доступной для последующего наследования
- При защищенном наследовании открытые поля и методы родительского класса становятся защищёнными в производном классе
- Защищённые члены родительского класса доступны всем его наследникам
- Порождённый класс может использовать эти члены, но должен предоставить собственный публичный интерфейс для работы с ними.

```c++
class Logger {
public:
  void Log(const std::string& message) const {
    std::cout << "[LOG]: " << message << std::endl;
  }
};

class SystemComponent : protected Logger {
public:
  SystemComponent() {
    Log("SystemComponent initialized."); // Внутреннее использование логирования
  }
  virtual ~SystemComponent() = default;
};

class NetworkManager : public SystemComponent {
public:
  NetworkManager() {
    Log("NetworkManager initialized."); // Внутреннее использование логирования
  }
  void Connect() {
    Log("NetworkManager connected to server."); // Доступ к Log через protected-наследование
  }
};

int main() {
  NetworkManager networkManager;
  networkManager.Connect();
  // networkManager.Log("...");        // Ошибка: Log недоступен вне иерархии
  // Logger* ptr = &networkManager;    // Ошибка: NetworkManager не является подтипом Logger
}
```

### Защищённое vs. закрытое наследование
- Защищённое наследование:
  - Публичные и защищённые члены базового класса становятся защищёнными в производном
  - Эти члены доступны как самому производному классу, так и его наследникам
- Закрытое наследование
  - Все публичные и защищённые члены базового класса становятся закрытыми в производном
  - Эти члены доступны только самому производному классу, не доступны его наследникам
- Разница проявляется только в поведении классов производных от производного класса.

## Вызов конструкторов и деструкторов при наследовании

### Порядок вызова конструкторов
- При создании объекта производного класса сначала вызывается конструктор базового класса
  - Вызов конструктора базового класса происходит до инициализации членов производного класса
- Конструктор производного класса может явно вызвать нужный конструктор базового класса через список инициализации
  - Если вызов конструктора базового класса не указан, компилятор попытается вызвать его конструктор по умолчанию
  - Если у базового класса нет конструктора по умолчанию, будет ошибка компиляции

### Порядок вызова деструкторов
- В C++ деструкторы вызываются в порядке, обратном порядку вызова конструкторов
- Последовательно происходят следующие этапы:
  - Выполняется тело деструктора производного класса
  - Затем вызываются деструкторы членов производного класса (в порядке, обратном их объявлению)
  - После этого вызывается деструктор базового класса
- Такой порядок гарантирует, что ресурсы, зависящие от других объектов, освобождаются после этих объектов

```c++
struct Computer {
  Computer() { std::cout << "Computer::Computer" << std::endl; }
  ~Computer() { std::cout << "Computer::~Computer" << std::endl; }
};

class Person {
public:
  Person(std::string name) : m_name(std::move(name)) {
    std::cout << "Person::Person(" << m_name << ")" << std::endl;
  }
  ~Person() { std::cout << "Person::~Person" << std::endl; }
private:
  std::string m_name;
};

class Programmer : public Person {
public:
  Programmer(std::string name) : Person{ std::move(name) } {
    std::cout << "Programmer::Programmer" << std::endl;
  }
  ~Programmer() { std::cout << "Programmer::~Programmer" << std::endl; }
private:
  Computer m_computer;
};

int main() {
  Programmer programmer{ "John Carmack" };
}
```

### Особенности работы виртуальных методов в конструкторе и деструкторе
- Во время работы конструктора объект ещё полностью не сконструирован
  - Обращаться к полям класса-наследника нельзя, пока они не сконструированы
- Во время работы деструктора объект уже частично разрушен
  - Нельзя обращаться к полям класса-наследника, если они уже разрушены
- При вызове виртуального метода из конструктора или деструктора будет вызвана реализация текущего класса, а не класса-наследника

```c++
class Base {
public:
  Base() {
    std::cout << "Base::Base" << std::endl;
    PrintInfo();
  }
  ~Base() {
    std::cout << "Base::~Base" << std::endl;
    PrintInfo();
  }
  virtual void PrintInfo() const {
    std::cout << "Base::PrintInfo"
              << std::endl;
  }
};

class Derived : public Base {
public:
  Derived() {
    std::cout << "Derived::Derived"
              << std::endl;
    PrintInfo();
  }
  ~Derived() {
    std::cout << "Derived::~Derived"
              << std::endl;
    PrintInfo();
  }
  void PrintInfo() const override {
    std::cout << "Derived::PrintInfo"
              << std::endl;
  }
};

int main() {
  Derived d;
  std::cout << "----" << std::endl;
  d.PrintInfo();
  std::cout << "----" << std::endl;
}
```

# Абстрактные классы
- Родительский класс может представлять абстрактное понятие и служить каркасом для производных классов
- В нём могут быть методы, не имеющие универсальной реализации
  - Например: как вычислить площадь или нарисовать объект?
- Такие методы объявляются чисто виртуальными: добавляется инициализатор = 0
- Класс считается абстрактным, если:
  - содержит хотя бы одну чисто виртуальную функцию, или не реализует хотя бы одну чисто виртуальную функцию унаследованную от базового класса
- Экземпляры абстрактного класса создать невозможно

```c++
// Абстрактный класс
class Shape {
public:
  virtual double GetArea() const = 0; // Чисто виртуальная функция
  virtual void Draw() const = 0;      // Чисто виртуальная функция
  virtual ~Shape() = default;         // Виртуальный деструктор
};

// Производный класс — Круг
class Circle : public Shape {
public:
  Circle(double radius): m_radius(radius) {}
  double GetArea() const override { return std::numbers::pi * m_radius * m_radius; }
  void Draw() const override { std::cout << "Drawing a circle with radius " << m_radius << "\n"; }
private:
  double m_radius;
};

// Производный класс — Прямоугольник
class Rectangle : public Shape {
public:
  Rectangle(double width, double height): m_width(width), m_height(height) {}
  double GetArea() const override { return m_width * m_height; }
  void Draw() const override { std::cout << "Drawing a rectangle " << m_width << " x " << m_height << "\n"; }
private:
  double m_width;
  double m_height;
};
```

## Интерфейс
- Интерфейс - предельный случай абстрактного класса
  - Все методы интерфейса (кроме деструктора) – чисто виртуальные
- Не имеет ни состояния (членов-данных), ни поведения (реализованных методов)
- Описывает протокол взаимодействия с объектом
  - Реализация интерфейса означает соответствие этому протоколу
- Примеры из реального мира
  - Интерфейс USB для подключения периферийных устройств
  - Разъём Mini-Jack для подключения аудиоустройств
- В некоторых языках программирования для обозначения интерфейса используется отдельное ключевое слово
  - interface в Java/C#
  - protocol в Swift

### Интерфейс как способ описания контрактов
- Интерфейс — это способ задать обязательный набор операций, которые должен поддерживать объект.
- Хотя интерфейс не содержит реализации, он критически важен для проектирования архитектуры программ: он позволяет определять контракты между частями системы
  - Объекты могут быть взаимозаменяемыми, если они реализуют один и тот же интерфейс, даже если их реализация совершенно разная.
- Интерфейсы широко используются в паттернах проектирования
  - В паттерне «Стратегия» или «Наблюдатель», где взаимодействие между объектами осуществляется через интерфейсы.

### Связи между интерфейсами
```c++
// Интерфейс Graphics предоставляет методы для рисования графических примитивов
class Graphics {
public:
  virtual ~Graphics() = default;
  virtual void MoveTo(Point p) = 0;
  virtual void LineTo(Point p) = 0;
  virtual void DrawEllipse(Point leftTop, Point rightBottom) = 0;
  virtual void SetColor(Color color) = 0;
  // Прочие методы рисования графических примитивов
};

// Объекты, которые можно нарисовать с помощью Graphics
class Drawable {
public:
  virtual ~Drawable() = default;
  virtual void Draw(Graphics& g) const = 0;
};
```

#### Класс Shape - абстрактная фигура
```c++
class Shape : public Drawable {
public:
  explicit Shape(Color color);
  Color GetColor() const;
  void SetColor(Color color);
private:
  Color m_color;
};
```

#### Окружность – конкретная фигура
```c++
class Circle : public Shape {
public:
  Circle(Color color, Point center, double radius)
    : Shape(color) , m_center{center} , m_radius{radius} {
  }

  void Draw(Graphics& g) const override {
    g.SetColor(GetColor());
    g.DrawEllipse(
      { m_center.x - m_radius, m_center.y - m_radius },
      { m_center.x + m_radius, m_center.y + m_radius }
    );
  }
private:
  Point m_center;
  double m_radius;
};
```

## Применение интерфейсов
- Интерфейс - это контракт, который обязуется выполнить любой класс, реализующий данный интерфейс
- Позволяет использовать полиморфизм времени выполнения
  - Объекты, реализующие интерфейс, можно обрабатывать единообразно, не зная их конкретного типа
  - Реализация может различаться, но внешний способ взаимодействия остаётся единым
- Достоинства интерфейсов
  - Устраняют зависимость от конкретных реализаций
  - Повышают гибкость архитектуры
  - Упрощают тестирование (можно использовать реализации-заглушки)
  - Позволяют применять Принцип Инверсии Зависимостей и программированию через интерфейсы

### Приведение типов в пределах иерархии классов
- Приведение типов вверх по иерархии происходит неявно
  - Всякая собака является животным
  - Всякий ястреб является птицей
  - Исключение – ромбовидное множественное наследование
- Приведение типов вниз по иерархии не всегда возможно
  - Не всякое млекопитающее – собака, но некоторые млекопитающие могут быть собаками
  - В C++ для такого приведения типов используется  оператор dynamic_cast
- Приведение типа между несвязанными классами иерархии недопустимо
  - Собаки не являются птицами
  - Кошка – не ястреб и не собака
  - Ястреб – не млекопитающее

```c++
class Animal {
public:
  virtual ~Animal() = default;

protected:
  int health_ = 10;
};

class Mouse : public Animal {
public:
  void EatCheese() {
  health_ += 10;
  }
};

class Hedgehog : public Animal {
public:
  void Sing(string song) {
  sing_history_.push_back(move(song));
  }

private:
  vector<string> sing_history_;
};

void PlayWithAnimal(Animal& animal) {
  Mouse& mouse = static_cast<Mouse&>(animal);
  cout << "Mouse eats cheese"sv << endl;
  mouse.EatCheese();

  Hedgehog& hedgehog = static_cast<Hedgehog&>(animal);
  cout << "Hedgehog sings songs"sv << endl;
  hedgehog.Sing("Jingle Bells"s);
  hedgehog.Sing("Yesterday"s);
}

int main() {
  Mouse mouse;
  PlayWithAnimal(mouse);
  cout << "---"sv << endl;
  Hedgehog hedgehog;
  PlayWithAnimal(hedgehog);
}
```

## Оператор dynamic_cast
- Выполняет безопасное приведение типа во время выполнения программы
- Используется для приведения:
  - указателей (Base* → Derived*) — возвращает nullptr, если приведение невозможно
  - ссылок (Base& → Derived&) — генерирует исключение std::bad_cast, если приведение невозможно
- Требует наличия хотя бы одного виртуального метода в базовом классе (для поддержки RTTI — Run-Time Type Information)
- Часто используется при работе с полиморфными объектами

```c++
void PlayWithAnimal(Animal& animal) {
  if (Mouse* mouse = dynamic_cast<Mouse*>(&animal)) {
    cout << "Mouse eats cheese"sv << endl;
    mouse->EatCheese();
  }

  if (Hedgehog* hedgehog = dynamic_cast<Hedgehog*>(&animal)) {
    cout << "Hedgehog sings songs"sv << endl;
    hedgehog->Sing("Jingle Bells"s);
    hedgehog->Sing("Yesterday"s);
  }
}

int main() {
  Mouse mouse;
  PlayWithAnimal(mouse);
  cout << "---"sv << endl;
  Hedgehog hedgehog;
  PlayWithAnimal(hedgehog);
}
```

```c++
void PlayWithAnimal2(Animal& animal) {
  try {
    // При невозможности приведения ссылки к нужному типу 
    // оператор dynaic_cast выбросит исключение std::bad_cast
    Mouse& mouse = dynamic_cast<Mouse&>(animal);
    cout << "Mouse eats cheese"sv << endl;
    mouse.EatCheese();
  } catch (const std::bad_cast&) {
  }

  try {
    Hedgehog& hedgehog = dynamic_cast<Hedgehog&>(animal);
    cout << "Hedgehog sings songs"sv << endl;
    hedgehog.Sing("Jingle Bells"s);
    hedgehog.Sing("Yesterday"s);
  } catch (const std::bad_cast&) {
  }
}
```

### Неудачное применение dynamic_cast
```c++
class Shape { ... };
class Rectangle : public Shape { ... };
class Circe : public Shape { ... };

void DrawShape(const Shape& shape, Canvas& canvas) {
  if (const Rectangle* r = dynamic_cast<const Rectangle*>(&shape)) {
    // рисуем прямоугольник r на холсте canvas
  } else if (const Circle* c = dynamic_cast<const Circle*>(&shape)) {
    // рисуем окружность c на холсте canvas
  }
}
```

### Не злоупотребляйте использованием dynamic_cast
- Код оказывается жёстко привязанным к конкретным типам
- Нарушается принцип открытости-закрытости: при добавлении нового класса придётся менять существующий код
- Снижается производительность (выполняется во время выполнения и требует поддержки RTTI)
- Предпочтительнее использовать виртуальные функции:
  - Не нужно вручную определять тип объекта
  - Облегчают расширяемость и читаемость кода
  - Работают быстрее dynamic_cast

### Когда dynamic_cast полезен?
- Нет возможности сделать метод виртуальным
  - Например, если базовый класс находится в сторонней библиотеке
  - Приведите ссылку или указатель к конкретному классу оператором dynamic_cast и вызовите нужную операцию
- Зная один интерфейс объекта, нужно запросить у него другой

## Запрос интерфейса
```c++
class IPlugin {
public:
  virtual ~IPlugin() = default;
  // прочие методы
};

class IRenderable {
public:
  virtual ~IRenderable() = default;
  virtual void Render() = 0;
};

class ConcretePlugin : public IPlugin
  , public IRenderable
{
public:
  void Render() override { … }
};

void Process(IPlugin& plugin)
{
  // Если plugin поддерживает рендеринг?
  if (auto renderable 
        = dynamic_cast<IRenderable*>(&plugin))
  {
    renderable->Render();
  }
  // проводим прочие операции над плагином
}

int main()
{
  ConcretePlugin plugin;
  Process(plugin);
}
```

## Множественное наследование
- В языке C++ класс может наследоваться от нескольких базовых классов
  - Такое наследование называется множественным
- Производный класс объединяет интерфейсы и/или реализации всех своих родительских классов
- Может быть полезно:
  - для реализации нескольких интерфейсов
  - при повторном использовании функциональности из разных иерархий
- Пример:
  - Класс DrawableLogger может наследоваться одновременно от IDrawable и ILogger

```c++
class Speakable {
public:
  virtual ~Speakable() = default;
  virtual void Speak() const = 0;
};

class Drawable {
public:
  virtual ~Drawable() = default;
  virtual void Draw() const = 0;
};

class Animal {
public:
  virtual ~Animal() = default;
  void Eat(string_view food) {
    cout << GetType() << " is eating "sv
       << food << endl;
    ++m_energy;
  }
  virtual string GetType() const = 0;

private:
  int m_energy = 100;
};

class Fish
  : public Animal
  , public Drawable {
public:
  string GetType() const override {
    return "fish"s;
  }
  void Draw() const override {
    cout << "><(((*>"sv << endl;
  }
};

class Cat 
  : public Animal
  , public Speakable
  , public Drawable {
public:
  void Speak() const override {
    cout << "Meow-meow"sv << endl;
  }
  void Draw() const override {
    cout << "(^w^)"sv << endl;
  }
  string GetType() const override {
    return "cat"s;
  }
};

void Feed(Animal& animal) {
  animal.Eat("meat"sv);
}

// Рыб и кошек можно кормить
int main() {
  Cat cat;
  Fish fish;

  // И кошка, и рыба — животные, поэтому их можно покормить
  Feed(cat);
  Feed(fish);
}

//С кошкой можно поговорить
void Talk(Speakable& speakable) {
  speakable.Speak();
}

int main() {
  Cat cat;
  Talk(cat);
}

void DrawPicture(const std::vector<const Drawable*>& drawables) {
  for (const Drawable* drawable : drawables) {
    drawable->Draw();
  }
}

int main() {
  Cat cat;
  Fish fish;

  // Рисование поддерживают и коты, и рыбы
  std::vector<const Drawable*> picture{&cat, &fish};
  DrawPicture(picture);
}
```

### Кормим сома
```c++
int main() {
  CatFish cat_fish;
  
  // Кормим сома сначала как кота
  Feed(static_cast<Cat&>(cat_fish));
  
  // Затем кормим сома как рыбу
  Feed(static_cast<Fish&>(cat_fish));

  // Также можно явно указать, какой из методов Eat() нужно вызвать
  cat_fish.Cat::Eat("milk");
}
```

### Решение – виртуальное наследование
```c++
class Fish 
  : public virtual Animal
  , public virtual Drawable { ... };

class Cat 
  : public virtual Animal
  , public Speakable
  , public virtual Drawable { ... };

class CatFish : public Cat, public Fish {
public:
  string GetType() const override {
    return "catfish"s;
  }
  void Draw() const override {
    // Рисуем сома несколько иначе, чем рыбу
    cout << "><(((*){"sv << endl;
  }
};
```

### Ограничения виртуального наследования
- Классы-предки не могут одновременно переопределять одни и те же методы своего родителя
  - В нашем случае – нельзя переопределить метод Draw() одновременно и в  Cat, и в Fish – будет ошибка компиляции, но не переопределять в CatFish

```c++
class CatFish : public Cat, public Fish {
public:
  string GetType() const override {
    return "catfish"s;
  }
  // void Draw() const override {
  //  cout << "><(((*){"sv << endl;
  //}
};
```

### Когда множественное наследование может быть полезным
- При аккуратном и осознанном использовании множественное наследование может быть эффективным инструментом
- Позволяет:
  - Создавать классы, сочетающие поведение нескольких реализаций
  - Реализовывать несколько интерфейсов в одном классе
- Активно используется в библиотеках ATL и WTL
- Важное правило: избегайте ромбовидного наследования, если в нём нет явной необходимости

#### Окно, описанное в библиотеке WTL
```c++
class CMainFrame
  : public WTL::CFrameWindowImpl<CMainFrame>
  , public WTL::CUpdateUI<CMainFrame>
  , public WTL::CMessageFilter
  , public WTL::CIdleHandler
{
public:

};
```

## Преимущества использования наследования
- Расширение существующего функционала
  - Новый класс может унаследовать и переопределить поведение базового класса
  - Устраняет необходимость дублирования кода
- Полиморфизм
  - Возможность использовать общий интерфейс для работы с различными реализациями
  - Упрощает добавление новых типов без изменения существующего кода
- Инкапсуляция различий
  - Разные реализации одного интерфейса скрываются за единым типом
  - Заменяет условные конструкции (switch-case, if-else) вызовами виртуальных функций
- Унификация API
  - Можно писать код, не зная конкретного типа объекта, а лишь его базовый интерфейс

## Наследование и вопросы проектирования
- Сильная связь между классами
  - Наследование — вторая по силе форма связи после дружбы
  - Подразумевает тесную зависимость от базового класса
- Контракт с базовым классом
  - Подкласс обязуется следовать интерфейсу и ожиданиям базового класса
  - Нарушение контракта может привести к ошибкам проектирования или нарушению инвариантов
- Хрупкость иерархий
  - Изменения в базовом классе могут непредсказуемо повлиять на производные классы
  - Критично в больших проектах и при работе с чужим кодом
- Избегайте глубоких иерархий
  - Многоуровневое наследование затрудняет понимание, тестирование и сопровождение
  - Предпочтительны композиция и делегирование, если не требуется полиморфизм
  - Многие паттерны проектирования заменяют наследование композицией или агрегацией

## Runtime-полиморфизм с std::variant
- std::variant — типобезопасный объединённый тип, введённый в C++17
- Позволяет объекту в каждый момент времени содержать значение одного из заранее перечисленных типов
- Альтернатива классической иерархии с виртуальными функциями:
  - Не требует наследования и виртуальных методов
  - Не требует new или указателей
- Позволяет реализовать полиморфное поведение через визиторы
- Хорошо сочетается с современным стилем программирования в C++

```c++
#include <cmath>
#include <variant>

using namespace std;
using Solution = variant<monostate, double, pair<double, double>>;

Solution SolveQuadraticEquation(double a, double b, double c) {
  if (a == 0) {
    throw invalid_argument("Not a quadratic equation"s);
  }

  const double d = b * b - 4 * a * c;
  if (d > 0) {
    const double sqrt_d = sqrt(d);
    const double dbl_a = 2.0 * a;
    return pair{(-b - sqrt_d) / dbl_a, (-b + sqrt_d) / dbl_a};
  } else if (d == 0) {
    return -b / (2 * a);
  } else {
    return monostate{};
    // либо return {}, так как monostate - самый первый элемент списка типов Solution
  }
}

int main() {
  cout << "sizeof(Solution)"sv << sizeof(Solution) << endl; // 24 байта
}
```

### Как получить доступ к содержимому?
- Используйте Посетителя (visitor) — объект с перегруженными operator() для всех типов, которые может содержать variant
- Вызовите `std::visit(visitor, variant_value);`
- `std::visit` выберет нужную перегрузку и вызовет её с текущим значением

#### Вывод корней уравнения
```c++
struct SolutionPrinter {
  void operator()(monostate) const {
    cout << "No roots"sv << endl;
  }
  void operator()(double root) const {
    cout << "One root: "sv << root << endl;
  }
  void operator()(pair<double, double> roots) const {
    cout << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
  }
};

int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);
  // Функция visit вызовет оператор (), принимающий тот тип,
  // который хранится в variant
  visit(SolutionPrinter{}, solution);
}
``` 

#### Нужно определить операцию () для всех типов
```c++
struct IncompleteSolutionPrinter {
  /* Забыли перегрузить оператор () для monostate */
  void operator()(double root) const {
    cout << "One root: "sv << root << endl;
  }
  void operator()(pair<double, double> roots) const {
    cout << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
  }
};

int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);

  // Эта строчка не скомпилируется
  visit(IncompleteSolutionPrinter{}, solution);
}
```

### Чтобы добавить новую операцию – создайте новый класс-посетитель
```c++
struct GreatestRootGetter {
  optional<double> operator()(monostate) const { return nullopt; }
  optional<double> operator()(double root) const { return root; }
  optional<double> operator()(pair<double, double> roots) const {
    return std::max(roots.first, roots.second);
  }
};

int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);

  if (const auto greatest_root = visit(GreatestRootGetter{}, solution)) {
    cout << "Greatest root: "sv << *greatest_root << endl;
  } else {
    cout << "No roots"sv << endl;
  }
}
```

#### Посетитель может обладать состоянием
```c++
struct OstreamSolutionPrinter {
  ostream& out;
  void operator()(monostate) const {
    out << "No roots"sv << endl;
  }
  void operator()(double root) const {
    out << "One root: "sv << root << endl;
  }
  void operator()(pair<double, double> roots) const {
    out << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
  }
};

int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);

  ostringstream strm;
  // Выводим в поток strm
  visit(OstreamSolutionPrinter{strm}, solution);
  cout << strm.str();
}
```

### Использование универсальной лямбда-функции
```c++
void PrintRoots(ostream& out, monostate) {
  out << "No roots"sv << endl;
}
void PrintRoots(ostream& out, double root) {
  out << "One root: "sv << root << endl;
}
void PrintRoots(ostream& out, pair<double, double> roots) {
  out << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
}

int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);
  ostringstream strm;
  visit([&strm](auto value) {
      // Это универсальная лямбда-функция (generic lambda).
      // Внутри неё нужная функция PrintRoots будет выбрана за счёт перегрузки функций.
      PrintRoots(strm, value);
    }, solution);
  cout << strm.str();
}
```

```c++
int main() {
  const auto solution = SolveQuadraticEquation(1, 0, -4);

  // Проверка типа при помощи std::holds_alternative().
  if (holds_alternative<double>(solution)) {
    // Когда мы убедились, что variant сейчас хранит double,
    // можно смело брать это значение при помощи std::get.
    cout << "One root: "sv << get<double>(solution) << endl;
  }

  // std::get_if вернёт указатель на значение нужного типа 
  // либо nullptr, если variant содержит значение другого типа.
  if (const auto* roots = get_if<pair<double, double>>(&solution)) {
    assert(roots != nullptr);
    cout << "Two roots: "sv << roots->first << " and "sv << roots->second << endl;
  } else {
    assert(roots == nullptr);
  }

  try {
    // Если solution хранит значение типа double, получим ссылку на него.
    const double& root = get<double>(solution);
    cout << "One root: "sv << root << endl;
  } catch (const bad_variant_access& e) {
    // Либо словим std::bad_variant_access в случае ошибки.
    cout << e.what() << endl;
  }
}
```

## Overloaded pattern
```c++
template <class... Ts>
struct overloaded : Ts... {
  using Ts::operator()...;
};

// explicit deduction guide (не требуется, начиная с C++20)
template <class... Ts>
overloaded(Ts...) -> overloaded<Ts...>;

using Number = std::variant<int, double>;

void Print(Number x) {
  std::visit(
    overloaded{
      [](int i) { std::cout << "Int " << i << "\n"; },
      [](double d) { std::cout << "Double " << d << "\n"; },
    }, x);
}

int main() {
  Print(10);   // Int 10
  Print(10.5); // Double 10.5
}
```

### Посещение нескольких variant-ов
```c++
Number Add(Number x, Number y) {
  return std::visit(
    overloaded{
      [](auto x, auto y) -> Number { return x + y; },
    },
    x, y);
}

int main()
{
  Print(Add(30, 12));   // Int 42
  Print(Add(10, 12.5)); // Double 22.5
}
```

```c++
struct SpaceShip { };
struct Missile { };
struct Asteroid { };

using GameObject = std::variant<SpaceShip, Missile, Asteroid>;

namespace detail {
struct Collider {
  void operator()(SpaceShip& obj1, SpaceShip& obj2) { std::cout << "SpaceShip vs SpaceShip\n"; }
  void operator()(SpaceShip& obj1, Missile & obj2) { std::cout << "SpaceShip vs Missile\n"; }
  void operator()(SpaceShip& obj1, Asteroid& obj2) { std::cout << "SpaceShip vs Asteroid\n"; }
  void operator()(Missile& obj1, Missile& obj2) { std::cout << "Missile vs Missile\n"; }
  void operator()(Missile& obj1, Asteroid& obj2) { std::cout << "Missile vs Asteroid\n"; }
  void operator()(Asteroid& obj1, Asteroid& obj2) { std::cout << "Asteroid vs Asteroid\n"; }
  void operator()(auto& obj1, auto& obj2) { (*this)(obj2, obj1); }
};
} // namespace detail

void Collide(GameObject& obj1, GameObject& obj2) {
  detail::Collider collider;
  std::visit(collider, obj1, obj2);
}

int main() {
  GameObject obj1 = SpaceShip{};
  GameObject obj2 = Missile{};
  Collide(obj1, obj2); // SpaceShip vs Missile
  Collide(obj2, obj1); // SpaceShip vs Missile
}
```

### Достоинства std::variant
- Не использует динамического выделения памяти
  - Объекты создаются на стеке, не используют new/delete
- Легкость добавления новых операций, зависящих от типа объекта
  - Создаётся новый visitor
- Нет базового класса
  - Может работать с несвязанными типами (например, string и Point)
- Можно использовать примитивные типы данных

- При небольшом количестве типов visit может работать быстрее виртуальных методов

### Недостатки std::variant
- Все типы внутри variant должны быть известны на этапе компиляции
  - В программах, поддерживающих плагины, не получится добавить новый тип
- Сложно добавлять новые типы
  - Требуется модифицировать всех посетителей
- Возможно неэффективное использование памяти
  - std::variant резервирует место под самый большой тип
- Для каждой новой операции нужен отдельный посетитель
  - Без должного контроля они могут быть разбросаны по разным файлам
- Передача аргументов — громоздка
  - Параметры операции хранятся в полях посетителя
- Может проигрывать виртуальным методам по производительности
  - При большом числе типов вызов std::visit может стать узким местом




